
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Person
 * 
 */
export type Person = {
  id: string
  created_at: Date
  updated_at: Date
  name: string
  email: string
  cpf: string | null
  rg: string | null
  rgss: string | null
  birth_date: Date | null
  status: boolean
  privacy: boolean
  avatar: string | null
  phone_id: string | null
  address_id: string | null
}

/**
 * Model AddressPerson
 * 
 */
export type AddressPerson = {
  id: string
  created_at: Date
  updated_at: Date
  number: number
  street: string
  complement: string | null
  zip_code: string
  city: string
  state: string
  neighborhood: string
  person_id: string
}

/**
 * Model PhonePerson
 * 
 */
export type PhonePerson = {
  id: string
  created_at: Date
  updated_at: Date
  phone: string
  person_id: string
}

/**
 * Model Group
 * 
 */
export type Group = {
  id: string
  created_at: Date
  updated_at: Date
  name: string
  description: string
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  created_at: Date
  updated_at: Date
  password: string
  is_verified: boolean
  person_id: string
}

/**
 * Model UserGroup
 * 
 */
export type UserGroup = {
  created_at: Date
  updated_at: Date
  user_id: string
  group_id: string
}

/**
 * Model RefresheToken
 * 
 */
export type RefresheToken = {
  id: string
  created_at: Date
  updated_at: Date
  refresh_token: string
  device: string
  expires_date: Date
  user_id: string
}

/**
 * Model Category
 * 
 */
export type Category = {
  id: string
  created_at: Date
  updated_at: Date
  name: string
  type: TypeCategoryEnum
  slug: string | null
  description: string
  photo: string | null
}

/**
 * Model Politic
 * 
 */
export type Politic = {
  id: string
  created_at: Date
  updated_at: Date
  name: string
  reading_time: number
  slug: string
  description: string
}

/**
 * Model SubCategory
 * 
 */
export type SubCategory = {
  id: string
  created_at: Date
  updated_at: Date
  name: string
}

/**
 * Model Order
 * 
 */
export type Order = {
  id: string
  created_at: Date
  updated_at: Date
  total: Prisma.Decimal
  freight: Prisma.Decimal
  canceled_at: Date | null
  status: StatusOrderEnum
  user_id: string
}

/**
 * Model Product
 * 
 */
export type Product = {
  id: string
  created_at: Date
  updated_at: Date
  sku: string | null
  bar_code: string | null
  other: Prisma.JsonValue | null
  canceled_at: Date | null
  status: boolean
  status_freight: boolean
  status_product: boolean
  price_id: string | null
  description_id: string
  subcategory_id: string
  product_info_id: string
}

/**
 * Model CategoryProduct
 * 
 */
export type CategoryProduct = {
  created_at: Date
  updated_at: Date
  category_id: string
  product_id: string
}

/**
 * Model Photo
 * 
 */
export type Photo = {
  id: string
  created_at: Date
  updated_at: Date
  name: string
  priority: number
  product_id: string
}

/**
 * Model Price
 * 
 */
export type Price = {
  id: string
  created_at: Date
  updated_at: Date
  price: Prisma.Decimal
  price_promotion: Prisma.Decimal
  product_id: string
  user_id: string
}

/**
 * Model Video
 * 
 */
export type Video = {
  id: string
  created_at: Date
  updated_at: Date
  name: string
  slug: string
  product_id: string
}

/**
 * Model Review
 * 
 */
export type Review = {
  id: string
  created_at: Date
  updated_at: Date
  comment: string
  status: ReviewsStatusEnum
  product_id: string
  author_id: string | null
}

/**
 * Model Comment
 * 
 */
export type Comment = {
  id: string
  text: string
}

/**
 * Model Description
 * 
 */
export type Description = {
  id: string
  created_at: Date
  updated_at: Date
  description: string
}

/**
 * Model Banner
 * 
 */
export type Banner = {
  id: string
  created_at: Date
  updated_at: Date
  name: string
  type: string
  status: boolean
  priority: number
}

/**
 * Model Stock
 * 
 */
export type Stock = {
  id: string
  created_at: Date
  updated_at: Date
  stock: number
  status: StocksStatusEnum
  action: StockActionEnum
  product_id: string
}

/**
 * Model OrderProduct
 * 
 */
export type OrderProduct = {
  id: string
  created_at: Date
  updated_at: Date
  subtotal: Prisma.Decimal
  quantity: number
  status: StatusOrderEnum
  order_id: string
  product_id: string
  user_id: string
  price_id: string
}

/**
 * Model Transaction
 * 
 */
export type Transaction = {
  id: string
  created_at: Date
  updated_at: Date
  transaction_id: string
  status: string
  brand: string
  authorization_code: string
  authorized_amount: Prisma.Decimal
  tid: string
  installments: string
  order_id: string
}

/**
 * Model ProductInfo
 * 
 */
export type ProductInfo = {
  id: string
  created_at: Date
  updated_at: Date
  price: Prisma.Decimal
  price_promotion: Prisma.Decimal
  freight: Prisma.Decimal
  link: string
  stock: number
  company: string
  currency: string
  user_id: string
}

/**
 * Model ForgotToken
 * 
 */
export type ForgotToken = {
  id: string
  created_at: Date
  updated_at: Date
  token: string
  code: string
  expires_date: Date
  user_id: string
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const TypeCategoryEnum: {
  MENU: 'MENU',
  SLIDE: 'SLIDE'
};

export type TypeCategoryEnum = (typeof TypeCategoryEnum)[keyof typeof TypeCategoryEnum]


export const StatusOrderEnum: {
  AWAITING: 'AWAITING',
  PROCESSING: 'PROCESSING',
  PROCESSED: 'PROCESSED',
  CANCELED: 'CANCELED'
};

export type StatusOrderEnum = (typeof StatusOrderEnum)[keyof typeof StatusOrderEnum]


export const ReviewsStatusEnum: {
  ACCREDITED: 'ACCREDITED',
  DISAPPROVED: 'DISAPPROVED',
  AWAITING_ANALYSIS: 'AWAITING_ANALYSIS'
};

export type ReviewsStatusEnum = (typeof ReviewsStatusEnum)[keyof typeof ReviewsStatusEnum]


export const StocksStatusEnum: {
  STOCK_IN: 'STOCK_IN',
  STOCK_OUT: 'STOCK_OUT'
};

export type StocksStatusEnum = (typeof StocksStatusEnum)[keyof typeof StocksStatusEnum]


export const StockActionEnum: {
  ACQUISITION: 'ACQUISITION',
  DEVOLUTION: 'DEVOLUTION',
  SALE: 'SALE',
  OTHERS: 'OTHERS'
};

export type StockActionEnum = (typeof StockActionEnum)[keyof typeof StockActionEnum]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more People
 * const people = await prisma.person.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more People
   * const people = await prisma.person.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: { maxWait?: number, timeout?: number }): Promise<R>;

      /**
   * `prisma.person`: Exposes CRUD operations for the **Person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more People
    * const people = await prisma.person.findMany()
    * ```
    */
  get person(): Prisma.PersonDelegate<GlobalReject>;

  /**
   * `prisma.addressPerson`: Exposes CRUD operations for the **AddressPerson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddressPeople
    * const addressPeople = await prisma.addressPerson.findMany()
    * ```
    */
  get addressPerson(): Prisma.AddressPersonDelegate<GlobalReject>;

  /**
   * `prisma.phonePerson`: Exposes CRUD operations for the **PhonePerson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhonePeople
    * const phonePeople = await prisma.phonePerson.findMany()
    * ```
    */
  get phonePerson(): Prisma.PhonePersonDelegate<GlobalReject>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.userGroup`: Exposes CRUD operations for the **UserGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGroups
    * const userGroups = await prisma.userGroup.findMany()
    * ```
    */
  get userGroup(): Prisma.UserGroupDelegate<GlobalReject>;

  /**
   * `prisma.refresheToken`: Exposes CRUD operations for the **RefresheToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefresheTokens
    * const refresheTokens = await prisma.refresheToken.findMany()
    * ```
    */
  get refresheToken(): Prisma.RefresheTokenDelegate<GlobalReject>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<GlobalReject>;

  /**
   * `prisma.politic`: Exposes CRUD operations for the **Politic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Politics
    * const politics = await prisma.politic.findMany()
    * ```
    */
  get politic(): Prisma.PoliticDelegate<GlobalReject>;

  /**
   * `prisma.subCategory`: Exposes CRUD operations for the **SubCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubCategories
    * const subCategories = await prisma.subCategory.findMany()
    * ```
    */
  get subCategory(): Prisma.SubCategoryDelegate<GlobalReject>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.categoryProduct`: Exposes CRUD operations for the **CategoryProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoryProducts
    * const categoryProducts = await prisma.categoryProduct.findMany()
    * ```
    */
  get categoryProduct(): Prisma.CategoryProductDelegate<GlobalReject>;

  /**
   * `prisma.photo`: Exposes CRUD operations for the **Photo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos
    * const photos = await prisma.photo.findMany()
    * ```
    */
  get photo(): Prisma.PhotoDelegate<GlobalReject>;

  /**
   * `prisma.price`: Exposes CRUD operations for the **Price** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prices
    * const prices = await prisma.price.findMany()
    * ```
    */
  get price(): Prisma.PriceDelegate<GlobalReject>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate<GlobalReject>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<GlobalReject>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<GlobalReject>;

  /**
   * `prisma.description`: Exposes CRUD operations for the **Description** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Descriptions
    * const descriptions = await prisma.description.findMany()
    * ```
    */
  get description(): Prisma.DescriptionDelegate<GlobalReject>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **Banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banner.findMany()
    * ```
    */
  get banner(): Prisma.BannerDelegate<GlobalReject>;

  /**
   * `prisma.stock`: Exposes CRUD operations for the **Stock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stocks
    * const stocks = await prisma.stock.findMany()
    * ```
    */
  get stock(): Prisma.StockDelegate<GlobalReject>;

  /**
   * `prisma.orderProduct`: Exposes CRUD operations for the **OrderProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderProducts
    * const orderProducts = await prisma.orderProduct.findMany()
    * ```
    */
  get orderProduct(): Prisma.OrderProductDelegate<GlobalReject>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<GlobalReject>;

  /**
   * `prisma.productInfo`: Exposes CRUD operations for the **ProductInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductInfos
    * const productInfos = await prisma.productInfo.findMany()
    * ```
    */
  get productInfo(): Prisma.ProductInfoDelegate<GlobalReject>;

  /**
   * `prisma.forgotToken`: Exposes CRUD operations for the **ForgotToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForgotTokens
    * const forgotTokens = await prisma.forgotToken.findMany()
    * ```
    */
  get forgotToken(): Prisma.ForgotTokenDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.14.0
   * Query Engine version: 2b0c12756921c891fec4f68d9444e18c7d5d4a6a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Person: 'Person',
    AddressPerson: 'AddressPerson',
    PhonePerson: 'PhonePerson',
    Group: 'Group',
    User: 'User',
    UserGroup: 'UserGroup',
    RefresheToken: 'RefresheToken',
    Category: 'Category',
    Politic: 'Politic',
    SubCategory: 'SubCategory',
    Order: 'Order',
    Product: 'Product',
    CategoryProduct: 'CategoryProduct',
    Photo: 'Photo',
    Price: 'Price',
    Video: 'Video',
    Review: 'Review',
    Comment: 'Comment',
    Description: 'Description',
    Banner: 'Banner',
    Stock: 'Stock',
    OrderProduct: 'OrderProduct',
    Transaction: 'Transaction',
    ProductInfo: 'ProductInfo',
    ForgotToken: 'ForgotToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    postgresdb?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;


  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PersonCountOutputType
   */


  export type PersonCountOutputType = {
    users: number
    addresses: number
    phones: number
  }

  export type PersonCountOutputTypeSelect = {
    users?: boolean
    addresses?: boolean
    phones?: boolean
  }

  export type PersonCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PersonCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PersonCountOutputType
    : S extends undefined
    ? never
    : S extends PersonCountOutputTypeArgs
    ?'include' extends U
    ? PersonCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PersonCountOutputType ? PersonCountOutputType[P] : never
  } 
    : PersonCountOutputType
  : PersonCountOutputType




  // Custom InputTypes

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PersonCountOutputType
     * 
    **/
    select?: PersonCountOutputTypeSelect | null
  }



  /**
   * Count Type AddressPersonCountOutputType
   */


  export type AddressPersonCountOutputType = {
    mainAddressPersons: number
  }

  export type AddressPersonCountOutputTypeSelect = {
    mainAddressPersons?: boolean
  }

  export type AddressPersonCountOutputTypeGetPayload<
    S extends boolean | null | undefined | AddressPersonCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? AddressPersonCountOutputType
    : S extends undefined
    ? never
    : S extends AddressPersonCountOutputTypeArgs
    ?'include' extends U
    ? AddressPersonCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof AddressPersonCountOutputType ? AddressPersonCountOutputType[P] : never
  } 
    : AddressPersonCountOutputType
  : AddressPersonCountOutputType




  // Custom InputTypes

  /**
   * AddressPersonCountOutputType without action
   */
  export type AddressPersonCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AddressPersonCountOutputType
     * 
    **/
    select?: AddressPersonCountOutputTypeSelect | null
  }



  /**
   * Count Type PhonePersonCountOutputType
   */


  export type PhonePersonCountOutputType = {
    mainPhonePersons: number
  }

  export type PhonePersonCountOutputTypeSelect = {
    mainPhonePersons?: boolean
  }

  export type PhonePersonCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PhonePersonCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PhonePersonCountOutputType
    : S extends undefined
    ? never
    : S extends PhonePersonCountOutputTypeArgs
    ?'include' extends U
    ? PhonePersonCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PhonePersonCountOutputType ? PhonePersonCountOutputType[P] : never
  } 
    : PhonePersonCountOutputType
  : PhonePersonCountOutputType




  // Custom InputTypes

  /**
   * PhonePersonCountOutputType without action
   */
  export type PhonePersonCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PhonePersonCountOutputType
     * 
    **/
    select?: PhonePersonCountOutputTypeSelect | null
  }



  /**
   * Count Type GroupCountOutputType
   */


  export type GroupCountOutputType = {
    usersGroups: number
  }

  export type GroupCountOutputTypeSelect = {
    usersGroups?: boolean
  }

  export type GroupCountOutputTypeGetPayload<
    S extends boolean | null | undefined | GroupCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? GroupCountOutputType
    : S extends undefined
    ? never
    : S extends GroupCountOutputTypeArgs
    ?'include' extends U
    ? GroupCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof GroupCountOutputType ? GroupCountOutputType[P] : never
  } 
    : GroupCountOutputType
  : GroupCountOutputType




  // Custom InputTypes

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     * 
    **/
    select?: GroupCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    prices: number
    orders: number
    reviews: number
    usersGroups: number
    refreshesTokens: number
    productsInfo: number
    OrderProduct: number
    ForgotToken: number
  }

  export type UserCountOutputTypeSelect = {
    prices?: boolean
    orders?: boolean
    reviews?: boolean
    usersGroups?: boolean
    refreshesTokens?: boolean
    productsInfo?: boolean
    OrderProduct?: boolean
    ForgotToken?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type CategoryCountOutputType
   */


  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect = {
    products?: boolean
  }

  export type CategoryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CategoryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CategoryCountOutputType
    : S extends undefined
    ? never
    : S extends CategoryCountOutputTypeArgs
    ?'include' extends U
    ? CategoryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CategoryCountOutputType ? CategoryCountOutputType[P] : never
  } 
    : CategoryCountOutputType
  : CategoryCountOutputType




  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     * 
    **/
    select?: CategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type SubCategoryCountOutputType
   */


  export type SubCategoryCountOutputType = {
    products: number
  }

  export type SubCategoryCountOutputTypeSelect = {
    products?: boolean
  }

  export type SubCategoryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SubCategoryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SubCategoryCountOutputType
    : S extends undefined
    ? never
    : S extends SubCategoryCountOutputTypeArgs
    ?'include' extends U
    ? SubCategoryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SubCategoryCountOutputType ? SubCategoryCountOutputType[P] : never
  } 
    : SubCategoryCountOutputType
  : SubCategoryCountOutputType




  // Custom InputTypes

  /**
   * SubCategoryCountOutputType without action
   */
  export type SubCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SubCategoryCountOutputType
     * 
    **/
    select?: SubCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type OrderCountOutputType
   */


  export type OrderCountOutputType = {
    ordersProducts: number
    transactions: number
  }

  export type OrderCountOutputTypeSelect = {
    ordersProducts?: boolean
    transactions?: boolean
  }

  export type OrderCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OrderCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OrderCountOutputType
    : S extends undefined
    ? never
    : S extends OrderCountOutputTypeArgs
    ?'include' extends U
    ? OrderCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OrderCountOutputType ? OrderCountOutputType[P] : never
  } 
    : OrderCountOutputType
  : OrderCountOutputType




  // Custom InputTypes

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     * 
    **/
    select?: OrderCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    categories: number
    photos: number
    reviews: number
    videos: number
    stocks: number
    ordersProducts: number
    prices: number
  }

  export type ProductCountOutputTypeSelect = {
    categories?: boolean
    photos?: boolean
    reviews?: boolean
    videos?: boolean
    stocks?: boolean
    ordersProducts?: boolean
    prices?: boolean
  }

  export type ProductCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductCountOutputType
    : S extends undefined
    ? never
    : S extends ProductCountOutputTypeArgs
    ?'include' extends U
    ? ProductCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProductCountOutputType ? ProductCountOutputType[P] : never
  } 
    : ProductCountOutputType
  : ProductCountOutputType




  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     * 
    **/
    select?: ProductCountOutputTypeSelect | null
  }



  /**
   * Count Type PriceCountOutputType
   */


  export type PriceCountOutputType = {
    actualProduct: number
    OrderProduct: number
  }

  export type PriceCountOutputTypeSelect = {
    actualProduct?: boolean
    OrderProduct?: boolean
  }

  export type PriceCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PriceCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PriceCountOutputType
    : S extends undefined
    ? never
    : S extends PriceCountOutputTypeArgs
    ?'include' extends U
    ? PriceCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PriceCountOutputType ? PriceCountOutputType[P] : never
  } 
    : PriceCountOutputType
  : PriceCountOutputType




  // Custom InputTypes

  /**
   * PriceCountOutputType without action
   */
  export type PriceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PriceCountOutputType
     * 
    **/
    select?: PriceCountOutputTypeSelect | null
  }



  /**
   * Count Type DescriptionCountOutputType
   */


  export type DescriptionCountOutputType = {
    products: number
  }

  export type DescriptionCountOutputTypeSelect = {
    products?: boolean
  }

  export type DescriptionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DescriptionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DescriptionCountOutputType
    : S extends undefined
    ? never
    : S extends DescriptionCountOutputTypeArgs
    ?'include' extends U
    ? DescriptionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DescriptionCountOutputType ? DescriptionCountOutputType[P] : never
  } 
    : DescriptionCountOutputType
  : DescriptionCountOutputType




  // Custom InputTypes

  /**
   * DescriptionCountOutputType without action
   */
  export type DescriptionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DescriptionCountOutputType
     * 
    **/
    select?: DescriptionCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Person
   */


  export type AggregatePerson = {
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  export type PersonMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    email: string | null
    cpf: string | null
    rg: string | null
    rgss: string | null
    birth_date: Date | null
    status: boolean | null
    privacy: boolean | null
    avatar: string | null
    phone_id: string | null
    address_id: string | null
  }

  export type PersonMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    email: string | null
    cpf: string | null
    rg: string | null
    rgss: string | null
    birth_date: Date | null
    status: boolean | null
    privacy: boolean | null
    avatar: string | null
    phone_id: string | null
    address_id: string | null
  }

  export type PersonCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    email: number
    cpf: number
    rg: number
    rgss: number
    birth_date: number
    status: number
    privacy: number
    avatar: number
    phone_id: number
    address_id: number
    _all: number
  }


  export type PersonMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    email?: true
    cpf?: true
    rg?: true
    rgss?: true
    birth_date?: true
    status?: true
    privacy?: true
    avatar?: true
    phone_id?: true
    address_id?: true
  }

  export type PersonMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    email?: true
    cpf?: true
    rg?: true
    rgss?: true
    birth_date?: true
    status?: true
    privacy?: true
    avatar?: true
    phone_id?: true
    address_id?: true
  }

  export type PersonCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    email?: true
    cpf?: true
    rg?: true
    rgss?: true
    birth_date?: true
    status?: true
    privacy?: true
    avatar?: true
    phone_id?: true
    address_id?: true
    _all?: true
  }

  export type PersonAggregateArgs = {
    /**
     * Filter which Person to aggregate.
     * 
    **/
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     * 
    **/
    orderBy?: Enumerable<PersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned People
    **/
    _count?: true | PersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonMaxAggregateInputType
  }

  export type GetPersonAggregateType<T extends PersonAggregateArgs> = {
        [P in keyof T & keyof AggregatePerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerson[P]>
      : GetScalarType<T[P], AggregatePerson[P]>
  }




  export type PersonGroupByArgs = {
    where?: PersonWhereInput
    orderBy?: Enumerable<PersonOrderByWithAggregationInput>
    by: Array<PersonScalarFieldEnum>
    having?: PersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonCountAggregateInputType | true
    _min?: PersonMinAggregateInputType
    _max?: PersonMaxAggregateInputType
  }


  export type PersonGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    name: string
    email: string
    cpf: string | null
    rg: string | null
    rgss: string | null
    birth_date: Date | null
    status: boolean
    privacy: boolean
    avatar: string | null
    phone_id: string | null
    address_id: string | null
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  type GetPersonGroupByPayload<T extends PersonGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonGroupByOutputType[P]>
            : GetScalarType<T[P], PersonGroupByOutputType[P]>
        }
      >
    >


  export type PersonSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    email?: boolean
    cpf?: boolean
    rg?: boolean
    rgss?: boolean
    birth_date?: boolean
    status?: boolean
    privacy?: boolean
    avatar?: boolean
    users?: boolean | UserFindManyArgs
    phone_id?: boolean
    phone?: boolean | PhonePersonArgs
    address_id?: boolean
    address?: boolean | AddressPersonArgs
    addresses?: boolean | AddressPersonFindManyArgs
    phones?: boolean | PhonePersonFindManyArgs
    _count?: boolean | PersonCountOutputTypeArgs
  }

  export type PersonInclude = {
    users?: boolean | UserFindManyArgs
    phone?: boolean | PhonePersonArgs
    address?: boolean | AddressPersonArgs
    addresses?: boolean | AddressPersonFindManyArgs
    phones?: boolean | PhonePersonFindManyArgs
    _count?: boolean | PersonCountOutputTypeArgs
  }

  export type PersonGetPayload<
    S extends boolean | null | undefined | PersonArgs,
    U = keyof S
      > = S extends true
        ? Person
    : S extends undefined
    ? never
    : S extends PersonArgs | PersonFindManyArgs
    ?'include' extends U
    ? Person  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'phone' ? PhonePersonGetPayload<S['include'][P]> | null :
        P extends 'address' ? AddressPersonGetPayload<S['include'][P]> | null :
        P extends 'addresses' ? Array < AddressPersonGetPayload<S['include'][P]>>  :
        P extends 'phones' ? Array < PhonePersonGetPayload<S['include'][P]>>  :
        P extends '_count' ? PersonCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'phone' ? PhonePersonGetPayload<S['select'][P]> | null :
        P extends 'address' ? AddressPersonGetPayload<S['select'][P]> | null :
        P extends 'addresses' ? Array < AddressPersonGetPayload<S['select'][P]>>  :
        P extends 'phones' ? Array < PhonePersonGetPayload<S['select'][P]>>  :
        P extends '_count' ? PersonCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Person ? Person[P] : never
  } 
    : Person
  : Person


  type PersonCountArgs = Merge<
    Omit<PersonFindManyArgs, 'select' | 'include'> & {
      select?: PersonCountAggregateInputType | true
    }
  >

  export interface PersonDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Person that matches the filter.
     * @param {PersonFindUniqueArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PersonFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PersonFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Person'> extends True ? CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>> : CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>

    /**
     * Find the first Person that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PersonFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PersonFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Person'> extends True ? CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>> : CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>

    /**
     * Find zero or more People that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all People
     * const people = await prisma.person.findMany()
     * 
     * // Get first 10 People
     * const people = await prisma.person.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personWithIdOnly = await prisma.person.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PersonFindManyArgs>(
      args?: SelectSubset<T, PersonFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Person>>, PrismaPromise<Array<PersonGetPayload<T>>>>

    /**
     * Create a Person.
     * @param {PersonCreateArgs} args - Arguments to create a Person.
     * @example
     * // Create one Person
     * const Person = await prisma.person.create({
     *   data: {
     *     // ... data to create a Person
     *   }
     * })
     * 
    **/
    create<T extends PersonCreateArgs>(
      args: SelectSubset<T, PersonCreateArgs>
    ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>

    /**
     * Create many People.
     *     @param {PersonCreateManyArgs} args - Arguments to create many People.
     *     @example
     *     // Create many People
     *     const person = await prisma.person.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PersonCreateManyArgs>(
      args?: SelectSubset<T, PersonCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Person.
     * @param {PersonDeleteArgs} args - Arguments to delete one Person.
     * @example
     * // Delete one Person
     * const Person = await prisma.person.delete({
     *   where: {
     *     // ... filter to delete one Person
     *   }
     * })
     * 
    **/
    delete<T extends PersonDeleteArgs>(
      args: SelectSubset<T, PersonDeleteArgs>
    ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>

    /**
     * Update one Person.
     * @param {PersonUpdateArgs} args - Arguments to update one Person.
     * @example
     * // Update one Person
     * const person = await prisma.person.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PersonUpdateArgs>(
      args: SelectSubset<T, PersonUpdateArgs>
    ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>

    /**
     * Delete zero or more People.
     * @param {PersonDeleteManyArgs} args - Arguments to filter People to delete.
     * @example
     * // Delete a few People
     * const { count } = await prisma.person.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PersonDeleteManyArgs>(
      args?: SelectSubset<T, PersonDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many People
     * const person = await prisma.person.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PersonUpdateManyArgs>(
      args: SelectSubset<T, PersonUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Person.
     * @param {PersonUpsertArgs} args - Arguments to update or create a Person.
     * @example
     * // Update or create a Person
     * const person = await prisma.person.upsert({
     *   create: {
     *     // ... data to create a Person
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Person we want to update
     *   }
     * })
    **/
    upsert<T extends PersonUpsertArgs>(
      args: SelectSubset<T, PersonUpsertArgs>
    ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>

    /**
     * Count the number of People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonCountArgs} args - Arguments to filter People to count.
     * @example
     * // Count the number of People
     * const count = await prisma.person.count({
     *   where: {
     *     // ... the filter for the People we want to count
     *   }
     * })
    **/
    count<T extends PersonCountArgs>(
      args?: Subset<T, PersonCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonAggregateArgs>(args: Subset<T, PersonAggregateArgs>): PrismaPromise<GetPersonAggregateType<T>>

    /**
     * Group by Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonGroupByArgs['orderBy'] }
        : { orderBy?: PersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Person.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PersonClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    phone<T extends PhonePersonArgs = {}>(args?: Subset<T, PhonePersonArgs>): CheckSelect<T, Prisma__PhonePersonClient<PhonePerson | null >, Prisma__PhonePersonClient<PhonePersonGetPayload<T> | null >>;

    address<T extends AddressPersonArgs = {}>(args?: Subset<T, AddressPersonArgs>): CheckSelect<T, Prisma__AddressPersonClient<AddressPerson | null >, Prisma__AddressPersonClient<AddressPersonGetPayload<T> | null >>;

    addresses<T extends AddressPersonFindManyArgs = {}>(args?: Subset<T, AddressPersonFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AddressPerson>>, PrismaPromise<Array<AddressPersonGetPayload<T>>>>;

    phones<T extends PhonePersonFindManyArgs = {}>(args?: Subset<T, PhonePersonFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PhonePerson>>, PrismaPromise<Array<PhonePersonGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Person findUnique
   */
  export type PersonFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Person
     * 
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PersonInclude | null
    /**
     * Throw an Error if a Person can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Person to fetch.
     * 
    **/
    where: PersonWhereUniqueInput
  }


  /**
   * Person findFirst
   */
  export type PersonFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Person
     * 
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PersonInclude | null
    /**
     * Throw an Error if a Person can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Person to fetch.
     * 
    **/
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     * 
    **/
    orderBy?: Enumerable<PersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     * 
    **/
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     * 
    **/
    distinct?: Enumerable<PersonScalarFieldEnum>
  }


  /**
   * Person findMany
   */
  export type PersonFindManyArgs = {
    /**
     * Select specific fields to fetch from the Person
     * 
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PersonInclude | null
    /**
     * Filter, which People to fetch.
     * 
    **/
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     * 
    **/
    orderBy?: Enumerable<PersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing People.
     * 
    **/
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PersonScalarFieldEnum>
  }


  /**
   * Person create
   */
  export type PersonCreateArgs = {
    /**
     * Select specific fields to fetch from the Person
     * 
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PersonInclude | null
    /**
     * The data needed to create a Person.
     * 
    **/
    data: XOR<PersonCreateInput, PersonUncheckedCreateInput>
  }


  /**
   * Person createMany
   */
  export type PersonCreateManyArgs = {
    /**
     * The data used to create many People.
     * 
    **/
    data: Enumerable<PersonCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Person update
   */
  export type PersonUpdateArgs = {
    /**
     * Select specific fields to fetch from the Person
     * 
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PersonInclude | null
    /**
     * The data needed to update a Person.
     * 
    **/
    data: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
    /**
     * Choose, which Person to update.
     * 
    **/
    where: PersonWhereUniqueInput
  }


  /**
   * Person updateMany
   */
  export type PersonUpdateManyArgs = {
    /**
     * The data used to update People.
     * 
    **/
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     * 
    **/
    where?: PersonWhereInput
  }


  /**
   * Person upsert
   */
  export type PersonUpsertArgs = {
    /**
     * Select specific fields to fetch from the Person
     * 
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PersonInclude | null
    /**
     * The filter to search for the Person to update in case it exists.
     * 
    **/
    where: PersonWhereUniqueInput
    /**
     * In case the Person found by the `where` argument doesn't exist, create a new Person with this data.
     * 
    **/
    create: XOR<PersonCreateInput, PersonUncheckedCreateInput>
    /**
     * In case the Person was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
  }


  /**
   * Person delete
   */
  export type PersonDeleteArgs = {
    /**
     * Select specific fields to fetch from the Person
     * 
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PersonInclude | null
    /**
     * Filter which Person to delete.
     * 
    **/
    where: PersonWhereUniqueInput
  }


  /**
   * Person deleteMany
   */
  export type PersonDeleteManyArgs = {
    /**
     * Filter which People to delete
     * 
    **/
    where?: PersonWhereInput
  }


  /**
   * Person without action
   */
  export type PersonArgs = {
    /**
     * Select specific fields to fetch from the Person
     * 
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PersonInclude | null
  }



  /**
   * Model AddressPerson
   */


  export type AggregateAddressPerson = {
    _count: AddressPersonCountAggregateOutputType | null
    _avg: AddressPersonAvgAggregateOutputType | null
    _sum: AddressPersonSumAggregateOutputType | null
    _min: AddressPersonMinAggregateOutputType | null
    _max: AddressPersonMaxAggregateOutputType | null
  }

  export type AddressPersonAvgAggregateOutputType = {
    number: number | null
  }

  export type AddressPersonSumAggregateOutputType = {
    number: number | null
  }

  export type AddressPersonMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    number: number | null
    street: string | null
    complement: string | null
    zip_code: string | null
    city: string | null
    state: string | null
    neighborhood: string | null
    person_id: string | null
  }

  export type AddressPersonMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    number: number | null
    street: string | null
    complement: string | null
    zip_code: string | null
    city: string | null
    state: string | null
    neighborhood: string | null
    person_id: string | null
  }

  export type AddressPersonCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    number: number
    street: number
    complement: number
    zip_code: number
    city: number
    state: number
    neighborhood: number
    person_id: number
    _all: number
  }


  export type AddressPersonAvgAggregateInputType = {
    number?: true
  }

  export type AddressPersonSumAggregateInputType = {
    number?: true
  }

  export type AddressPersonMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    number?: true
    street?: true
    complement?: true
    zip_code?: true
    city?: true
    state?: true
    neighborhood?: true
    person_id?: true
  }

  export type AddressPersonMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    number?: true
    street?: true
    complement?: true
    zip_code?: true
    city?: true
    state?: true
    neighborhood?: true
    person_id?: true
  }

  export type AddressPersonCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    number?: true
    street?: true
    complement?: true
    zip_code?: true
    city?: true
    state?: true
    neighborhood?: true
    person_id?: true
    _all?: true
  }

  export type AddressPersonAggregateArgs = {
    /**
     * Filter which AddressPerson to aggregate.
     * 
    **/
    where?: AddressPersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressPeople to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressPersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AddressPersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressPeople from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressPeople.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddressPeople
    **/
    _count?: true | AddressPersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressPersonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressPersonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressPersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressPersonMaxAggregateInputType
  }

  export type GetAddressPersonAggregateType<T extends AddressPersonAggregateArgs> = {
        [P in keyof T & keyof AggregateAddressPerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddressPerson[P]>
      : GetScalarType<T[P], AggregateAddressPerson[P]>
  }




  export type AddressPersonGroupByArgs = {
    where?: AddressPersonWhereInput
    orderBy?: Enumerable<AddressPersonOrderByWithAggregationInput>
    by: Array<AddressPersonScalarFieldEnum>
    having?: AddressPersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressPersonCountAggregateInputType | true
    _avg?: AddressPersonAvgAggregateInputType
    _sum?: AddressPersonSumAggregateInputType
    _min?: AddressPersonMinAggregateInputType
    _max?: AddressPersonMaxAggregateInputType
  }


  export type AddressPersonGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    number: number
    street: string
    complement: string | null
    zip_code: string
    city: string
    state: string
    neighborhood: string
    person_id: string
    _count: AddressPersonCountAggregateOutputType | null
    _avg: AddressPersonAvgAggregateOutputType | null
    _sum: AddressPersonSumAggregateOutputType | null
    _min: AddressPersonMinAggregateOutputType | null
    _max: AddressPersonMaxAggregateOutputType | null
  }

  type GetAddressPersonGroupByPayload<T extends AddressPersonGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AddressPersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressPersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressPersonGroupByOutputType[P]>
            : GetScalarType<T[P], AddressPersonGroupByOutputType[P]>
        }
      >
    >


  export type AddressPersonSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    number?: boolean
    street?: boolean
    complement?: boolean
    zip_code?: boolean
    city?: boolean
    state?: boolean
    neighborhood?: boolean
    person_id?: boolean
    person?: boolean | PersonArgs
    mainAddressPersons?: boolean | PersonFindManyArgs
    _count?: boolean | AddressPersonCountOutputTypeArgs
  }

  export type AddressPersonInclude = {
    person?: boolean | PersonArgs
    mainAddressPersons?: boolean | PersonFindManyArgs
    _count?: boolean | AddressPersonCountOutputTypeArgs
  }

  export type AddressPersonGetPayload<
    S extends boolean | null | undefined | AddressPersonArgs,
    U = keyof S
      > = S extends true
        ? AddressPerson
    : S extends undefined
    ? never
    : S extends AddressPersonArgs | AddressPersonFindManyArgs
    ?'include' extends U
    ? AddressPerson  & {
    [P in TrueKeys<S['include']>]:
        P extends 'person' ? PersonGetPayload<S['include'][P]> :
        P extends 'mainAddressPersons' ? Array < PersonGetPayload<S['include'][P]>>  :
        P extends '_count' ? AddressPersonCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'person' ? PersonGetPayload<S['select'][P]> :
        P extends 'mainAddressPersons' ? Array < PersonGetPayload<S['select'][P]>>  :
        P extends '_count' ? AddressPersonCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof AddressPerson ? AddressPerson[P] : never
  } 
    : AddressPerson
  : AddressPerson


  type AddressPersonCountArgs = Merge<
    Omit<AddressPersonFindManyArgs, 'select' | 'include'> & {
      select?: AddressPersonCountAggregateInputType | true
    }
  >

  export interface AddressPersonDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AddressPerson that matches the filter.
     * @param {AddressPersonFindUniqueArgs} args - Arguments to find a AddressPerson
     * @example
     * // Get one AddressPerson
     * const addressPerson = await prisma.addressPerson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressPersonFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AddressPersonFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AddressPerson'> extends True ? CheckSelect<T, Prisma__AddressPersonClient<AddressPerson>, Prisma__AddressPersonClient<AddressPersonGetPayload<T>>> : CheckSelect<T, Prisma__AddressPersonClient<AddressPerson | null >, Prisma__AddressPersonClient<AddressPersonGetPayload<T> | null >>

    /**
     * Find the first AddressPerson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressPersonFindFirstArgs} args - Arguments to find a AddressPerson
     * @example
     * // Get one AddressPerson
     * const addressPerson = await prisma.addressPerson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressPersonFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AddressPersonFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AddressPerson'> extends True ? CheckSelect<T, Prisma__AddressPersonClient<AddressPerson>, Prisma__AddressPersonClient<AddressPersonGetPayload<T>>> : CheckSelect<T, Prisma__AddressPersonClient<AddressPerson | null >, Prisma__AddressPersonClient<AddressPersonGetPayload<T> | null >>

    /**
     * Find zero or more AddressPeople that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressPersonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddressPeople
     * const addressPeople = await prisma.addressPerson.findMany()
     * 
     * // Get first 10 AddressPeople
     * const addressPeople = await prisma.addressPerson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressPersonWithIdOnly = await prisma.addressPerson.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressPersonFindManyArgs>(
      args?: SelectSubset<T, AddressPersonFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AddressPerson>>, PrismaPromise<Array<AddressPersonGetPayload<T>>>>

    /**
     * Create a AddressPerson.
     * @param {AddressPersonCreateArgs} args - Arguments to create a AddressPerson.
     * @example
     * // Create one AddressPerson
     * const AddressPerson = await prisma.addressPerson.create({
     *   data: {
     *     // ... data to create a AddressPerson
     *   }
     * })
     * 
    **/
    create<T extends AddressPersonCreateArgs>(
      args: SelectSubset<T, AddressPersonCreateArgs>
    ): CheckSelect<T, Prisma__AddressPersonClient<AddressPerson>, Prisma__AddressPersonClient<AddressPersonGetPayload<T>>>

    /**
     * Create many AddressPeople.
     *     @param {AddressPersonCreateManyArgs} args - Arguments to create many AddressPeople.
     *     @example
     *     // Create many AddressPeople
     *     const addressPerson = await prisma.addressPerson.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressPersonCreateManyArgs>(
      args?: SelectSubset<T, AddressPersonCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AddressPerson.
     * @param {AddressPersonDeleteArgs} args - Arguments to delete one AddressPerson.
     * @example
     * // Delete one AddressPerson
     * const AddressPerson = await prisma.addressPerson.delete({
     *   where: {
     *     // ... filter to delete one AddressPerson
     *   }
     * })
     * 
    **/
    delete<T extends AddressPersonDeleteArgs>(
      args: SelectSubset<T, AddressPersonDeleteArgs>
    ): CheckSelect<T, Prisma__AddressPersonClient<AddressPerson>, Prisma__AddressPersonClient<AddressPersonGetPayload<T>>>

    /**
     * Update one AddressPerson.
     * @param {AddressPersonUpdateArgs} args - Arguments to update one AddressPerson.
     * @example
     * // Update one AddressPerson
     * const addressPerson = await prisma.addressPerson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressPersonUpdateArgs>(
      args: SelectSubset<T, AddressPersonUpdateArgs>
    ): CheckSelect<T, Prisma__AddressPersonClient<AddressPerson>, Prisma__AddressPersonClient<AddressPersonGetPayload<T>>>

    /**
     * Delete zero or more AddressPeople.
     * @param {AddressPersonDeleteManyArgs} args - Arguments to filter AddressPeople to delete.
     * @example
     * // Delete a few AddressPeople
     * const { count } = await prisma.addressPerson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressPersonDeleteManyArgs>(
      args?: SelectSubset<T, AddressPersonDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddressPeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressPersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddressPeople
     * const addressPerson = await prisma.addressPerson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressPersonUpdateManyArgs>(
      args: SelectSubset<T, AddressPersonUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AddressPerson.
     * @param {AddressPersonUpsertArgs} args - Arguments to update or create a AddressPerson.
     * @example
     * // Update or create a AddressPerson
     * const addressPerson = await prisma.addressPerson.upsert({
     *   create: {
     *     // ... data to create a AddressPerson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddressPerson we want to update
     *   }
     * })
    **/
    upsert<T extends AddressPersonUpsertArgs>(
      args: SelectSubset<T, AddressPersonUpsertArgs>
    ): CheckSelect<T, Prisma__AddressPersonClient<AddressPerson>, Prisma__AddressPersonClient<AddressPersonGetPayload<T>>>

    /**
     * Count the number of AddressPeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressPersonCountArgs} args - Arguments to filter AddressPeople to count.
     * @example
     * // Count the number of AddressPeople
     * const count = await prisma.addressPerson.count({
     *   where: {
     *     // ... the filter for the AddressPeople we want to count
     *   }
     * })
    **/
    count<T extends AddressPersonCountArgs>(
      args?: Subset<T, AddressPersonCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressPersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddressPerson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressPersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressPersonAggregateArgs>(args: Subset<T, AddressPersonAggregateArgs>): PrismaPromise<GetAddressPersonAggregateType<T>>

    /**
     * Group by AddressPerson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressPersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressPersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressPersonGroupByArgs['orderBy'] }
        : { orderBy?: AddressPersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressPersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressPersonGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddressPerson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressPersonClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    person<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>;

    mainAddressPersons<T extends PersonFindManyArgs = {}>(args?: Subset<T, PersonFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Person>>, PrismaPromise<Array<PersonGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AddressPerson findUnique
   */
  export type AddressPersonFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AddressPerson
     * 
    **/
    select?: AddressPersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressPersonInclude | null
    /**
     * Throw an Error if a AddressPerson can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AddressPerson to fetch.
     * 
    **/
    where: AddressPersonWhereUniqueInput
  }


  /**
   * AddressPerson findFirst
   */
  export type AddressPersonFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AddressPerson
     * 
    **/
    select?: AddressPersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressPersonInclude | null
    /**
     * Throw an Error if a AddressPerson can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AddressPerson to fetch.
     * 
    **/
    where?: AddressPersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressPeople to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressPersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddressPeople.
     * 
    **/
    cursor?: AddressPersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressPeople from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressPeople.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddressPeople.
     * 
    **/
    distinct?: Enumerable<AddressPersonScalarFieldEnum>
  }


  /**
   * AddressPerson findMany
   */
  export type AddressPersonFindManyArgs = {
    /**
     * Select specific fields to fetch from the AddressPerson
     * 
    **/
    select?: AddressPersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressPersonInclude | null
    /**
     * Filter, which AddressPeople to fetch.
     * 
    **/
    where?: AddressPersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressPeople to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressPersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddressPeople.
     * 
    **/
    cursor?: AddressPersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressPeople from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressPeople.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AddressPersonScalarFieldEnum>
  }


  /**
   * AddressPerson create
   */
  export type AddressPersonCreateArgs = {
    /**
     * Select specific fields to fetch from the AddressPerson
     * 
    **/
    select?: AddressPersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressPersonInclude | null
    /**
     * The data needed to create a AddressPerson.
     * 
    **/
    data: XOR<AddressPersonCreateInput, AddressPersonUncheckedCreateInput>
  }


  /**
   * AddressPerson createMany
   */
  export type AddressPersonCreateManyArgs = {
    /**
     * The data used to create many AddressPeople.
     * 
    **/
    data: Enumerable<AddressPersonCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AddressPerson update
   */
  export type AddressPersonUpdateArgs = {
    /**
     * Select specific fields to fetch from the AddressPerson
     * 
    **/
    select?: AddressPersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressPersonInclude | null
    /**
     * The data needed to update a AddressPerson.
     * 
    **/
    data: XOR<AddressPersonUpdateInput, AddressPersonUncheckedUpdateInput>
    /**
     * Choose, which AddressPerson to update.
     * 
    **/
    where: AddressPersonWhereUniqueInput
  }


  /**
   * AddressPerson updateMany
   */
  export type AddressPersonUpdateManyArgs = {
    /**
     * The data used to update AddressPeople.
     * 
    **/
    data: XOR<AddressPersonUpdateManyMutationInput, AddressPersonUncheckedUpdateManyInput>
    /**
     * Filter which AddressPeople to update
     * 
    **/
    where?: AddressPersonWhereInput
  }


  /**
   * AddressPerson upsert
   */
  export type AddressPersonUpsertArgs = {
    /**
     * Select specific fields to fetch from the AddressPerson
     * 
    **/
    select?: AddressPersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressPersonInclude | null
    /**
     * The filter to search for the AddressPerson to update in case it exists.
     * 
    **/
    where: AddressPersonWhereUniqueInput
    /**
     * In case the AddressPerson found by the `where` argument doesn't exist, create a new AddressPerson with this data.
     * 
    **/
    create: XOR<AddressPersonCreateInput, AddressPersonUncheckedCreateInput>
    /**
     * In case the AddressPerson was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AddressPersonUpdateInput, AddressPersonUncheckedUpdateInput>
  }


  /**
   * AddressPerson delete
   */
  export type AddressPersonDeleteArgs = {
    /**
     * Select specific fields to fetch from the AddressPerson
     * 
    **/
    select?: AddressPersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressPersonInclude | null
    /**
     * Filter which AddressPerson to delete.
     * 
    **/
    where: AddressPersonWhereUniqueInput
  }


  /**
   * AddressPerson deleteMany
   */
  export type AddressPersonDeleteManyArgs = {
    /**
     * Filter which AddressPeople to delete
     * 
    **/
    where?: AddressPersonWhereInput
  }


  /**
   * AddressPerson without action
   */
  export type AddressPersonArgs = {
    /**
     * Select specific fields to fetch from the AddressPerson
     * 
    **/
    select?: AddressPersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressPersonInclude | null
  }



  /**
   * Model PhonePerson
   */


  export type AggregatePhonePerson = {
    _count: PhonePersonCountAggregateOutputType | null
    _min: PhonePersonMinAggregateOutputType | null
    _max: PhonePersonMaxAggregateOutputType | null
  }

  export type PhonePersonMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    phone: string | null
    person_id: string | null
  }

  export type PhonePersonMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    phone: string | null
    person_id: string | null
  }

  export type PhonePersonCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    phone: number
    person_id: number
    _all: number
  }


  export type PhonePersonMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    phone?: true
    person_id?: true
  }

  export type PhonePersonMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    phone?: true
    person_id?: true
  }

  export type PhonePersonCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    phone?: true
    person_id?: true
    _all?: true
  }

  export type PhonePersonAggregateArgs = {
    /**
     * Filter which PhonePerson to aggregate.
     * 
    **/
    where?: PhonePersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhonePeople to fetch.
     * 
    **/
    orderBy?: Enumerable<PhonePersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PhonePersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhonePeople from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhonePeople.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhonePeople
    **/
    _count?: true | PhonePersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhonePersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhonePersonMaxAggregateInputType
  }

  export type GetPhonePersonAggregateType<T extends PhonePersonAggregateArgs> = {
        [P in keyof T & keyof AggregatePhonePerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhonePerson[P]>
      : GetScalarType<T[P], AggregatePhonePerson[P]>
  }




  export type PhonePersonGroupByArgs = {
    where?: PhonePersonWhereInput
    orderBy?: Enumerable<PhonePersonOrderByWithAggregationInput>
    by: Array<PhonePersonScalarFieldEnum>
    having?: PhonePersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhonePersonCountAggregateInputType | true
    _min?: PhonePersonMinAggregateInputType
    _max?: PhonePersonMaxAggregateInputType
  }


  export type PhonePersonGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    phone: string
    person_id: string
    _count: PhonePersonCountAggregateOutputType | null
    _min: PhonePersonMinAggregateOutputType | null
    _max: PhonePersonMaxAggregateOutputType | null
  }

  type GetPhonePersonGroupByPayload<T extends PhonePersonGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PhonePersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhonePersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhonePersonGroupByOutputType[P]>
            : GetScalarType<T[P], PhonePersonGroupByOutputType[P]>
        }
      >
    >


  export type PhonePersonSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    phone?: boolean
    person_id?: boolean
    person?: boolean | PersonArgs
    mainPhonePersons?: boolean | PersonFindManyArgs
    _count?: boolean | PhonePersonCountOutputTypeArgs
  }

  export type PhonePersonInclude = {
    person?: boolean | PersonArgs
    mainPhonePersons?: boolean | PersonFindManyArgs
    _count?: boolean | PhonePersonCountOutputTypeArgs
  }

  export type PhonePersonGetPayload<
    S extends boolean | null | undefined | PhonePersonArgs,
    U = keyof S
      > = S extends true
        ? PhonePerson
    : S extends undefined
    ? never
    : S extends PhonePersonArgs | PhonePersonFindManyArgs
    ?'include' extends U
    ? PhonePerson  & {
    [P in TrueKeys<S['include']>]:
        P extends 'person' ? PersonGetPayload<S['include'][P]> :
        P extends 'mainPhonePersons' ? Array < PersonGetPayload<S['include'][P]>>  :
        P extends '_count' ? PhonePersonCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'person' ? PersonGetPayload<S['select'][P]> :
        P extends 'mainPhonePersons' ? Array < PersonGetPayload<S['select'][P]>>  :
        P extends '_count' ? PhonePersonCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PhonePerson ? PhonePerson[P] : never
  } 
    : PhonePerson
  : PhonePerson


  type PhonePersonCountArgs = Merge<
    Omit<PhonePersonFindManyArgs, 'select' | 'include'> & {
      select?: PhonePersonCountAggregateInputType | true
    }
  >

  export interface PhonePersonDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PhonePerson that matches the filter.
     * @param {PhonePersonFindUniqueArgs} args - Arguments to find a PhonePerson
     * @example
     * // Get one PhonePerson
     * const phonePerson = await prisma.phonePerson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PhonePersonFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PhonePersonFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PhonePerson'> extends True ? CheckSelect<T, Prisma__PhonePersonClient<PhonePerson>, Prisma__PhonePersonClient<PhonePersonGetPayload<T>>> : CheckSelect<T, Prisma__PhonePersonClient<PhonePerson | null >, Prisma__PhonePersonClient<PhonePersonGetPayload<T> | null >>

    /**
     * Find the first PhonePerson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhonePersonFindFirstArgs} args - Arguments to find a PhonePerson
     * @example
     * // Get one PhonePerson
     * const phonePerson = await prisma.phonePerson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PhonePersonFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PhonePersonFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PhonePerson'> extends True ? CheckSelect<T, Prisma__PhonePersonClient<PhonePerson>, Prisma__PhonePersonClient<PhonePersonGetPayload<T>>> : CheckSelect<T, Prisma__PhonePersonClient<PhonePerson | null >, Prisma__PhonePersonClient<PhonePersonGetPayload<T> | null >>

    /**
     * Find zero or more PhonePeople that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhonePersonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhonePeople
     * const phonePeople = await prisma.phonePerson.findMany()
     * 
     * // Get first 10 PhonePeople
     * const phonePeople = await prisma.phonePerson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phonePersonWithIdOnly = await prisma.phonePerson.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PhonePersonFindManyArgs>(
      args?: SelectSubset<T, PhonePersonFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PhonePerson>>, PrismaPromise<Array<PhonePersonGetPayload<T>>>>

    /**
     * Create a PhonePerson.
     * @param {PhonePersonCreateArgs} args - Arguments to create a PhonePerson.
     * @example
     * // Create one PhonePerson
     * const PhonePerson = await prisma.phonePerson.create({
     *   data: {
     *     // ... data to create a PhonePerson
     *   }
     * })
     * 
    **/
    create<T extends PhonePersonCreateArgs>(
      args: SelectSubset<T, PhonePersonCreateArgs>
    ): CheckSelect<T, Prisma__PhonePersonClient<PhonePerson>, Prisma__PhonePersonClient<PhonePersonGetPayload<T>>>

    /**
     * Create many PhonePeople.
     *     @param {PhonePersonCreateManyArgs} args - Arguments to create many PhonePeople.
     *     @example
     *     // Create many PhonePeople
     *     const phonePerson = await prisma.phonePerson.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PhonePersonCreateManyArgs>(
      args?: SelectSubset<T, PhonePersonCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PhonePerson.
     * @param {PhonePersonDeleteArgs} args - Arguments to delete one PhonePerson.
     * @example
     * // Delete one PhonePerson
     * const PhonePerson = await prisma.phonePerson.delete({
     *   where: {
     *     // ... filter to delete one PhonePerson
     *   }
     * })
     * 
    **/
    delete<T extends PhonePersonDeleteArgs>(
      args: SelectSubset<T, PhonePersonDeleteArgs>
    ): CheckSelect<T, Prisma__PhonePersonClient<PhonePerson>, Prisma__PhonePersonClient<PhonePersonGetPayload<T>>>

    /**
     * Update one PhonePerson.
     * @param {PhonePersonUpdateArgs} args - Arguments to update one PhonePerson.
     * @example
     * // Update one PhonePerson
     * const phonePerson = await prisma.phonePerson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PhonePersonUpdateArgs>(
      args: SelectSubset<T, PhonePersonUpdateArgs>
    ): CheckSelect<T, Prisma__PhonePersonClient<PhonePerson>, Prisma__PhonePersonClient<PhonePersonGetPayload<T>>>

    /**
     * Delete zero or more PhonePeople.
     * @param {PhonePersonDeleteManyArgs} args - Arguments to filter PhonePeople to delete.
     * @example
     * // Delete a few PhonePeople
     * const { count } = await prisma.phonePerson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PhonePersonDeleteManyArgs>(
      args?: SelectSubset<T, PhonePersonDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhonePeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhonePersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhonePeople
     * const phonePerson = await prisma.phonePerson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PhonePersonUpdateManyArgs>(
      args: SelectSubset<T, PhonePersonUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PhonePerson.
     * @param {PhonePersonUpsertArgs} args - Arguments to update or create a PhonePerson.
     * @example
     * // Update or create a PhonePerson
     * const phonePerson = await prisma.phonePerson.upsert({
     *   create: {
     *     // ... data to create a PhonePerson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhonePerson we want to update
     *   }
     * })
    **/
    upsert<T extends PhonePersonUpsertArgs>(
      args: SelectSubset<T, PhonePersonUpsertArgs>
    ): CheckSelect<T, Prisma__PhonePersonClient<PhonePerson>, Prisma__PhonePersonClient<PhonePersonGetPayload<T>>>

    /**
     * Count the number of PhonePeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhonePersonCountArgs} args - Arguments to filter PhonePeople to count.
     * @example
     * // Count the number of PhonePeople
     * const count = await prisma.phonePerson.count({
     *   where: {
     *     // ... the filter for the PhonePeople we want to count
     *   }
     * })
    **/
    count<T extends PhonePersonCountArgs>(
      args?: Subset<T, PhonePersonCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhonePersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhonePerson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhonePersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhonePersonAggregateArgs>(args: Subset<T, PhonePersonAggregateArgs>): PrismaPromise<GetPhonePersonAggregateType<T>>

    /**
     * Group by PhonePerson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhonePersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhonePersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhonePersonGroupByArgs['orderBy'] }
        : { orderBy?: PhonePersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhonePersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhonePersonGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhonePerson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PhonePersonClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    person<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>;

    mainPhonePersons<T extends PersonFindManyArgs = {}>(args?: Subset<T, PersonFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Person>>, PrismaPromise<Array<PersonGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PhonePerson findUnique
   */
  export type PhonePersonFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PhonePerson
     * 
    **/
    select?: PhonePersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhonePersonInclude | null
    /**
     * Throw an Error if a PhonePerson can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PhonePerson to fetch.
     * 
    **/
    where: PhonePersonWhereUniqueInput
  }


  /**
   * PhonePerson findFirst
   */
  export type PhonePersonFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PhonePerson
     * 
    **/
    select?: PhonePersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhonePersonInclude | null
    /**
     * Throw an Error if a PhonePerson can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PhonePerson to fetch.
     * 
    **/
    where?: PhonePersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhonePeople to fetch.
     * 
    **/
    orderBy?: Enumerable<PhonePersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhonePeople.
     * 
    **/
    cursor?: PhonePersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhonePeople from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhonePeople.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhonePeople.
     * 
    **/
    distinct?: Enumerable<PhonePersonScalarFieldEnum>
  }


  /**
   * PhonePerson findMany
   */
  export type PhonePersonFindManyArgs = {
    /**
     * Select specific fields to fetch from the PhonePerson
     * 
    **/
    select?: PhonePersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhonePersonInclude | null
    /**
     * Filter, which PhonePeople to fetch.
     * 
    **/
    where?: PhonePersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhonePeople to fetch.
     * 
    **/
    orderBy?: Enumerable<PhonePersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhonePeople.
     * 
    **/
    cursor?: PhonePersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhonePeople from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhonePeople.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PhonePersonScalarFieldEnum>
  }


  /**
   * PhonePerson create
   */
  export type PhonePersonCreateArgs = {
    /**
     * Select specific fields to fetch from the PhonePerson
     * 
    **/
    select?: PhonePersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhonePersonInclude | null
    /**
     * The data needed to create a PhonePerson.
     * 
    **/
    data: XOR<PhonePersonCreateInput, PhonePersonUncheckedCreateInput>
  }


  /**
   * PhonePerson createMany
   */
  export type PhonePersonCreateManyArgs = {
    /**
     * The data used to create many PhonePeople.
     * 
    **/
    data: Enumerable<PhonePersonCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PhonePerson update
   */
  export type PhonePersonUpdateArgs = {
    /**
     * Select specific fields to fetch from the PhonePerson
     * 
    **/
    select?: PhonePersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhonePersonInclude | null
    /**
     * The data needed to update a PhonePerson.
     * 
    **/
    data: XOR<PhonePersonUpdateInput, PhonePersonUncheckedUpdateInput>
    /**
     * Choose, which PhonePerson to update.
     * 
    **/
    where: PhonePersonWhereUniqueInput
  }


  /**
   * PhonePerson updateMany
   */
  export type PhonePersonUpdateManyArgs = {
    /**
     * The data used to update PhonePeople.
     * 
    **/
    data: XOR<PhonePersonUpdateManyMutationInput, PhonePersonUncheckedUpdateManyInput>
    /**
     * Filter which PhonePeople to update
     * 
    **/
    where?: PhonePersonWhereInput
  }


  /**
   * PhonePerson upsert
   */
  export type PhonePersonUpsertArgs = {
    /**
     * Select specific fields to fetch from the PhonePerson
     * 
    **/
    select?: PhonePersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhonePersonInclude | null
    /**
     * The filter to search for the PhonePerson to update in case it exists.
     * 
    **/
    where: PhonePersonWhereUniqueInput
    /**
     * In case the PhonePerson found by the `where` argument doesn't exist, create a new PhonePerson with this data.
     * 
    **/
    create: XOR<PhonePersonCreateInput, PhonePersonUncheckedCreateInput>
    /**
     * In case the PhonePerson was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PhonePersonUpdateInput, PhonePersonUncheckedUpdateInput>
  }


  /**
   * PhonePerson delete
   */
  export type PhonePersonDeleteArgs = {
    /**
     * Select specific fields to fetch from the PhonePerson
     * 
    **/
    select?: PhonePersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhonePersonInclude | null
    /**
     * Filter which PhonePerson to delete.
     * 
    **/
    where: PhonePersonWhereUniqueInput
  }


  /**
   * PhonePerson deleteMany
   */
  export type PhonePersonDeleteManyArgs = {
    /**
     * Filter which PhonePeople to delete
     * 
    **/
    where?: PhonePersonWhereInput
  }


  /**
   * PhonePerson without action
   */
  export type PhonePersonArgs = {
    /**
     * Select specific fields to fetch from the PhonePerson
     * 
    **/
    select?: PhonePersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhonePersonInclude | null
  }



  /**
   * Model Group
   */


  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    description: string | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    description: string | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    description: number
    _all: number
  }


  export type GroupMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    description?: true
    _all?: true
  }

  export type GroupAggregateArgs = {
    /**
     * Filter which Group to aggregate.
     * 
    **/
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs = {
    where?: GroupWhereInput
    orderBy?: Enumerable<GroupOrderByWithAggregationInput>
    by: Array<GroupScalarFieldEnum>
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }


  export type GroupGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    name: string
    description: string
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    description?: boolean
    usersGroups?: boolean | UserGroupFindManyArgs
    _count?: boolean | GroupCountOutputTypeArgs
  }

  export type GroupInclude = {
    usersGroups?: boolean | UserGroupFindManyArgs
    _count?: boolean | GroupCountOutputTypeArgs
  }

  export type GroupGetPayload<
    S extends boolean | null | undefined | GroupArgs,
    U = keyof S
      > = S extends true
        ? Group
    : S extends undefined
    ? never
    : S extends GroupArgs | GroupFindManyArgs
    ?'include' extends U
    ? Group  & {
    [P in TrueKeys<S['include']>]:
        P extends 'usersGroups' ? Array < UserGroupGetPayload<S['include'][P]>>  :
        P extends '_count' ? GroupCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'usersGroups' ? Array < UserGroupGetPayload<S['select'][P]>>  :
        P extends '_count' ? GroupCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Group ? Group[P] : never
  } 
    : Group
  : Group


  type GroupCountArgs = Merge<
    Omit<GroupFindManyArgs, 'select' | 'include'> & {
      select?: GroupCountAggregateInputType | true
    }
  >

  export interface GroupDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GroupFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Group'> extends True ? CheckSelect<T, Prisma__GroupClient<Group>, Prisma__GroupClient<GroupGetPayload<T>>> : CheckSelect<T, Prisma__GroupClient<Group | null >, Prisma__GroupClient<GroupGetPayload<T> | null >>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GroupFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Group'> extends True ? CheckSelect<T, Prisma__GroupClient<Group>, Prisma__GroupClient<GroupGetPayload<T>>> : CheckSelect<T, Prisma__GroupClient<Group | null >, Prisma__GroupClient<GroupGetPayload<T> | null >>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GroupFindManyArgs>(
      args?: SelectSubset<T, GroupFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Group>>, PrismaPromise<Array<GroupGetPayload<T>>>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
    **/
    create<T extends GroupCreateArgs>(
      args: SelectSubset<T, GroupCreateArgs>
    ): CheckSelect<T, Prisma__GroupClient<Group>, Prisma__GroupClient<GroupGetPayload<T>>>

    /**
     * Create many Groups.
     *     @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     *     @example
     *     // Create many Groups
     *     const group = await prisma.group.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupCreateManyArgs>(
      args?: SelectSubset<T, GroupCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
    **/
    delete<T extends GroupDeleteArgs>(
      args: SelectSubset<T, GroupDeleteArgs>
    ): CheckSelect<T, Prisma__GroupClient<Group>, Prisma__GroupClient<GroupGetPayload<T>>>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupUpdateArgs>(
      args: SelectSubset<T, GroupUpdateArgs>
    ): CheckSelect<T, Prisma__GroupClient<Group>, Prisma__GroupClient<GroupGetPayload<T>>>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupDeleteManyArgs>(
      args?: SelectSubset<T, GroupDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupUpdateManyArgs>(
      args: SelectSubset<T, GroupUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
    **/
    upsert<T extends GroupUpsertArgs>(
      args: SelectSubset<T, GroupUpsertArgs>
    ): CheckSelect<T, Prisma__GroupClient<Group>, Prisma__GroupClient<GroupGetPayload<T>>>

    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GroupClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    usersGroups<T extends UserGroupFindManyArgs = {}>(args?: Subset<T, UserGroupFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserGroup>>, PrismaPromise<Array<UserGroupGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupInclude | null
    /**
     * Throw an Error if a Group can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Group to fetch.
     * 
    **/
    where: GroupWhereUniqueInput
  }


  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupInclude | null
    /**
     * Throw an Error if a Group can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Group to fetch.
     * 
    **/
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     * 
    **/
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     * 
    **/
    distinct?: Enumerable<GroupScalarFieldEnum>
  }


  /**
   * Group findMany
   */
  export type GroupFindManyArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupInclude | null
    /**
     * Filter, which Groups to fetch.
     * 
    **/
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     * 
    **/
    orderBy?: Enumerable<GroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     * 
    **/
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GroupScalarFieldEnum>
  }


  /**
   * Group create
   */
  export type GroupCreateArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupInclude | null
    /**
     * The data needed to create a Group.
     * 
    **/
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }


  /**
   * Group createMany
   */
  export type GroupCreateManyArgs = {
    /**
     * The data used to create many Groups.
     * 
    **/
    data: Enumerable<GroupCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Group update
   */
  export type GroupUpdateArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupInclude | null
    /**
     * The data needed to update a Group.
     * 
    **/
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     * 
    **/
    where: GroupWhereUniqueInput
  }


  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs = {
    /**
     * The data used to update Groups.
     * 
    **/
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     * 
    **/
    where?: GroupWhereInput
  }


  /**
   * Group upsert
   */
  export type GroupUpsertArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupInclude | null
    /**
     * The filter to search for the Group to update in case it exists.
     * 
    **/
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     * 
    **/
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }


  /**
   * Group delete
   */
  export type GroupDeleteArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupInclude | null
    /**
     * Filter which Group to delete.
     * 
    **/
    where: GroupWhereUniqueInput
  }


  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs = {
    /**
     * Filter which Groups to delete
     * 
    **/
    where?: GroupWhereInput
  }


  /**
   * Group without action
   */
  export type GroupArgs = {
    /**
     * Select specific fields to fetch from the Group
     * 
    **/
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GroupInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    password: string | null
    is_verified: boolean | null
    person_id: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    password: string | null
    is_verified: boolean | null
    person_id: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    password: number
    is_verified: number
    person_id: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    password?: true
    is_verified?: true
    person_id?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    password?: true
    is_verified?: true
    person_id?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    password?: true
    is_verified?: true
    person_id?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    password: string
    is_verified: boolean
    person_id: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    password?: boolean
    is_verified?: boolean
    person_id?: boolean
    person?: boolean | PersonArgs
    prices?: boolean | PriceFindManyArgs
    orders?: boolean | OrderFindManyArgs
    reviews?: boolean | ReviewFindManyArgs
    usersGroups?: boolean | UserGroupFindManyArgs
    refreshesTokens?: boolean | RefresheTokenFindManyArgs
    productsInfo?: boolean | ProductInfoFindManyArgs
    OrderProduct?: boolean | OrderProductFindManyArgs
    ForgotToken?: boolean | ForgotTokenFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    person?: boolean | PersonArgs
    prices?: boolean | PriceFindManyArgs
    orders?: boolean | OrderFindManyArgs
    reviews?: boolean | ReviewFindManyArgs
    usersGroups?: boolean | UserGroupFindManyArgs
    refreshesTokens?: boolean | RefresheTokenFindManyArgs
    productsInfo?: boolean | ProductInfoFindManyArgs
    OrderProduct?: boolean | OrderProductFindManyArgs
    ForgotToken?: boolean | ForgotTokenFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'person' ? PersonGetPayload<S['include'][P]> :
        P extends 'prices' ? Array < PriceGetPayload<S['include'][P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<S['include'][P]>>  :
        P extends 'reviews' ? Array < ReviewGetPayload<S['include'][P]>>  :
        P extends 'usersGroups' ? Array < UserGroupGetPayload<S['include'][P]>>  :
        P extends 'refreshesTokens' ? Array < RefresheTokenGetPayload<S['include'][P]>>  :
        P extends 'productsInfo' ? Array < ProductInfoGetPayload<S['include'][P]>>  :
        P extends 'OrderProduct' ? Array < OrderProductGetPayload<S['include'][P]>>  :
        P extends 'ForgotToken' ? Array < ForgotTokenGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'person' ? PersonGetPayload<S['select'][P]> :
        P extends 'prices' ? Array < PriceGetPayload<S['select'][P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<S['select'][P]>>  :
        P extends 'reviews' ? Array < ReviewGetPayload<S['select'][P]>>  :
        P extends 'usersGroups' ? Array < UserGroupGetPayload<S['select'][P]>>  :
        P extends 'refreshesTokens' ? Array < RefresheTokenGetPayload<S['select'][P]>>  :
        P extends 'productsInfo' ? Array < ProductInfoGetPayload<S['select'][P]>>  :
        P extends 'OrderProduct' ? Array < OrderProductGetPayload<S['select'][P]>>  :
        P extends 'ForgotToken' ? Array < ForgotTokenGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    person<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>;

    prices<T extends PriceFindManyArgs = {}>(args?: Subset<T, PriceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Price>>, PrismaPromise<Array<PriceGetPayload<T>>>>;

    orders<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>;

    reviews<T extends ReviewFindManyArgs = {}>(args?: Subset<T, ReviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Review>>, PrismaPromise<Array<ReviewGetPayload<T>>>>;

    usersGroups<T extends UserGroupFindManyArgs = {}>(args?: Subset<T, UserGroupFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserGroup>>, PrismaPromise<Array<UserGroupGetPayload<T>>>>;

    refreshesTokens<T extends RefresheTokenFindManyArgs = {}>(args?: Subset<T, RefresheTokenFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RefresheToken>>, PrismaPromise<Array<RefresheTokenGetPayload<T>>>>;

    productsInfo<T extends ProductInfoFindManyArgs = {}>(args?: Subset<T, ProductInfoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductInfo>>, PrismaPromise<Array<ProductInfoGetPayload<T>>>>;

    OrderProduct<T extends OrderProductFindManyArgs = {}>(args?: Subset<T, OrderProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderProduct>>, PrismaPromise<Array<OrderProductGetPayload<T>>>>;

    ForgotToken<T extends ForgotTokenFindManyArgs = {}>(args?: Subset<T, ForgotTokenFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ForgotToken>>, PrismaPromise<Array<ForgotTokenGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model UserGroup
   */


  export type AggregateUserGroup = {
    _count: UserGroupCountAggregateOutputType | null
    _min: UserGroupMinAggregateOutputType | null
    _max: UserGroupMaxAggregateOutputType | null
  }

  export type UserGroupMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
    group_id: string | null
  }

  export type UserGroupMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
    group_id: string | null
  }

  export type UserGroupCountAggregateOutputType = {
    created_at: number
    updated_at: number
    user_id: number
    group_id: number
    _all: number
  }


  export type UserGroupMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    user_id?: true
    group_id?: true
  }

  export type UserGroupMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    user_id?: true
    group_id?: true
  }

  export type UserGroupCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    user_id?: true
    group_id?: true
    _all?: true
  }

  export type UserGroupAggregateArgs = {
    /**
     * Filter which UserGroup to aggregate.
     * 
    **/
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<UserGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserGroups
    **/
    _count?: true | UserGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserGroupMaxAggregateInputType
  }

  export type GetUserGroupAggregateType<T extends UserGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateUserGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGroup[P]>
      : GetScalarType<T[P], AggregateUserGroup[P]>
  }




  export type UserGroupGroupByArgs = {
    where?: UserGroupWhereInput
    orderBy?: Enumerable<UserGroupOrderByWithAggregationInput>
    by: Array<UserGroupScalarFieldEnum>
    having?: UserGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserGroupCountAggregateInputType | true
    _min?: UserGroupMinAggregateInputType
    _max?: UserGroupMaxAggregateInputType
  }


  export type UserGroupGroupByOutputType = {
    created_at: Date
    updated_at: Date
    user_id: string
    group_id: string
    _count: UserGroupCountAggregateOutputType | null
    _min: UserGroupMinAggregateOutputType | null
    _max: UserGroupMaxAggregateOutputType | null
  }

  type GetUserGroupGroupByPayload<T extends UserGroupGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupGroupByOutputType[P]>
        }
      >
    >


  export type UserGroupSelect = {
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    user?: boolean | UserArgs
    group_id?: boolean
    group?: boolean | GroupArgs
  }

  export type UserGroupInclude = {
    user?: boolean | UserArgs
    group?: boolean | GroupArgs
  }

  export type UserGroupGetPayload<
    S extends boolean | null | undefined | UserGroupArgs,
    U = keyof S
      > = S extends true
        ? UserGroup
    : S extends undefined
    ? never
    : S extends UserGroupArgs | UserGroupFindManyArgs
    ?'include' extends U
    ? UserGroup  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'group' ? GroupGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'group' ? GroupGetPayload<S['select'][P]> :  P extends keyof UserGroup ? UserGroup[P] : never
  } 
    : UserGroup
  : UserGroup


  type UserGroupCountArgs = Merge<
    Omit<UserGroupFindManyArgs, 'select' | 'include'> & {
      select?: UserGroupCountAggregateInputType | true
    }
  >

  export interface UserGroupDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserGroup that matches the filter.
     * @param {UserGroupFindUniqueArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserGroupFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserGroupFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserGroup'> extends True ? CheckSelect<T, Prisma__UserGroupClient<UserGroup>, Prisma__UserGroupClient<UserGroupGetPayload<T>>> : CheckSelect<T, Prisma__UserGroupClient<UserGroup | null >, Prisma__UserGroupClient<UserGroupGetPayload<T> | null >>

    /**
     * Find the first UserGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupFindFirstArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserGroupFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserGroupFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserGroup'> extends True ? CheckSelect<T, Prisma__UserGroupClient<UserGroup>, Prisma__UserGroupClient<UserGroupGetPayload<T>>> : CheckSelect<T, Prisma__UserGroupClient<UserGroup | null >, Prisma__UserGroupClient<UserGroupGetPayload<T> | null >>

    /**
     * Find zero or more UserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGroups
     * const userGroups = await prisma.userGroup.findMany()
     * 
     * // Get first 10 UserGroups
     * const userGroups = await prisma.userGroup.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const userGroupWithCreated_atOnly = await prisma.userGroup.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends UserGroupFindManyArgs>(
      args?: SelectSubset<T, UserGroupFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserGroup>>, PrismaPromise<Array<UserGroupGetPayload<T>>>>

    /**
     * Create a UserGroup.
     * @param {UserGroupCreateArgs} args - Arguments to create a UserGroup.
     * @example
     * // Create one UserGroup
     * const UserGroup = await prisma.userGroup.create({
     *   data: {
     *     // ... data to create a UserGroup
     *   }
     * })
     * 
    **/
    create<T extends UserGroupCreateArgs>(
      args: SelectSubset<T, UserGroupCreateArgs>
    ): CheckSelect<T, Prisma__UserGroupClient<UserGroup>, Prisma__UserGroupClient<UserGroupGetPayload<T>>>

    /**
     * Create many UserGroups.
     *     @param {UserGroupCreateManyArgs} args - Arguments to create many UserGroups.
     *     @example
     *     // Create many UserGroups
     *     const userGroup = await prisma.userGroup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserGroupCreateManyArgs>(
      args?: SelectSubset<T, UserGroupCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserGroup.
     * @param {UserGroupDeleteArgs} args - Arguments to delete one UserGroup.
     * @example
     * // Delete one UserGroup
     * const UserGroup = await prisma.userGroup.delete({
     *   where: {
     *     // ... filter to delete one UserGroup
     *   }
     * })
     * 
    **/
    delete<T extends UserGroupDeleteArgs>(
      args: SelectSubset<T, UserGroupDeleteArgs>
    ): CheckSelect<T, Prisma__UserGroupClient<UserGroup>, Prisma__UserGroupClient<UserGroupGetPayload<T>>>

    /**
     * Update one UserGroup.
     * @param {UserGroupUpdateArgs} args - Arguments to update one UserGroup.
     * @example
     * // Update one UserGroup
     * const userGroup = await prisma.userGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserGroupUpdateArgs>(
      args: SelectSubset<T, UserGroupUpdateArgs>
    ): CheckSelect<T, Prisma__UserGroupClient<UserGroup>, Prisma__UserGroupClient<UserGroupGetPayload<T>>>

    /**
     * Delete zero or more UserGroups.
     * @param {UserGroupDeleteManyArgs} args - Arguments to filter UserGroups to delete.
     * @example
     * // Delete a few UserGroups
     * const { count } = await prisma.userGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserGroupDeleteManyArgs>(
      args?: SelectSubset<T, UserGroupDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGroups
     * const userGroup = await prisma.userGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserGroupUpdateManyArgs>(
      args: SelectSubset<T, UserGroupUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserGroup.
     * @param {UserGroupUpsertArgs} args - Arguments to update or create a UserGroup.
     * @example
     * // Update or create a UserGroup
     * const userGroup = await prisma.userGroup.upsert({
     *   create: {
     *     // ... data to create a UserGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGroup we want to update
     *   }
     * })
    **/
    upsert<T extends UserGroupUpsertArgs>(
      args: SelectSubset<T, UserGroupUpsertArgs>
    ): CheckSelect<T, Prisma__UserGroupClient<UserGroup>, Prisma__UserGroupClient<UserGroupGetPayload<T>>>

    /**
     * Count the number of UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupCountArgs} args - Arguments to filter UserGroups to count.
     * @example
     * // Count the number of UserGroups
     * const count = await prisma.userGroup.count({
     *   where: {
     *     // ... the filter for the UserGroups we want to count
     *   }
     * })
    **/
    count<T extends UserGroupCountArgs>(
      args?: Subset<T, UserGroupCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGroupAggregateArgs>(args: Subset<T, UserGroupAggregateArgs>): PrismaPromise<GetUserGroupAggregateType<T>>

    /**
     * Group by UserGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserGroupClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    group<T extends GroupArgs = {}>(args?: Subset<T, GroupArgs>): CheckSelect<T, Prisma__GroupClient<Group | null >, Prisma__GroupClient<GroupGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserGroup findUnique
   */
  export type UserGroupFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserGroup
     * 
    **/
    select?: UserGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserGroupInclude | null
    /**
     * Throw an Error if a UserGroup can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserGroup to fetch.
     * 
    **/
    where: UserGroupWhereUniqueInput
  }


  /**
   * UserGroup findFirst
   */
  export type UserGroupFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserGroup
     * 
    **/
    select?: UserGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserGroupInclude | null
    /**
     * Throw an Error if a UserGroup can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserGroup to fetch.
     * 
    **/
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<UserGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroups.
     * 
    **/
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroups.
     * 
    **/
    distinct?: Enumerable<UserGroupScalarFieldEnum>
  }


  /**
   * UserGroup findMany
   */
  export type UserGroupFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserGroup
     * 
    **/
    select?: UserGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserGroupInclude | null
    /**
     * Filter, which UserGroups to fetch.
     * 
    **/
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     * 
    **/
    orderBy?: Enumerable<UserGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserGroups.
     * 
    **/
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserGroupScalarFieldEnum>
  }


  /**
   * UserGroup create
   */
  export type UserGroupCreateArgs = {
    /**
     * Select specific fields to fetch from the UserGroup
     * 
    **/
    select?: UserGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserGroupInclude | null
    /**
     * The data needed to create a UserGroup.
     * 
    **/
    data: XOR<UserGroupCreateInput, UserGroupUncheckedCreateInput>
  }


  /**
   * UserGroup createMany
   */
  export type UserGroupCreateManyArgs = {
    /**
     * The data used to create many UserGroups.
     * 
    **/
    data: Enumerable<UserGroupCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserGroup update
   */
  export type UserGroupUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserGroup
     * 
    **/
    select?: UserGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserGroupInclude | null
    /**
     * The data needed to update a UserGroup.
     * 
    **/
    data: XOR<UserGroupUpdateInput, UserGroupUncheckedUpdateInput>
    /**
     * Choose, which UserGroup to update.
     * 
    **/
    where: UserGroupWhereUniqueInput
  }


  /**
   * UserGroup updateMany
   */
  export type UserGroupUpdateManyArgs = {
    /**
     * The data used to update UserGroups.
     * 
    **/
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyInput>
    /**
     * Filter which UserGroups to update
     * 
    **/
    where?: UserGroupWhereInput
  }


  /**
   * UserGroup upsert
   */
  export type UserGroupUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserGroup
     * 
    **/
    select?: UserGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserGroupInclude | null
    /**
     * The filter to search for the UserGroup to update in case it exists.
     * 
    **/
    where: UserGroupWhereUniqueInput
    /**
     * In case the UserGroup found by the `where` argument doesn't exist, create a new UserGroup with this data.
     * 
    **/
    create: XOR<UserGroupCreateInput, UserGroupUncheckedCreateInput>
    /**
     * In case the UserGroup was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserGroupUpdateInput, UserGroupUncheckedUpdateInput>
  }


  /**
   * UserGroup delete
   */
  export type UserGroupDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserGroup
     * 
    **/
    select?: UserGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserGroupInclude | null
    /**
     * Filter which UserGroup to delete.
     * 
    **/
    where: UserGroupWhereUniqueInput
  }


  /**
   * UserGroup deleteMany
   */
  export type UserGroupDeleteManyArgs = {
    /**
     * Filter which UserGroups to delete
     * 
    **/
    where?: UserGroupWhereInput
  }


  /**
   * UserGroup without action
   */
  export type UserGroupArgs = {
    /**
     * Select specific fields to fetch from the UserGroup
     * 
    **/
    select?: UserGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserGroupInclude | null
  }



  /**
   * Model RefresheToken
   */


  export type AggregateRefresheToken = {
    _count: RefresheTokenCountAggregateOutputType | null
    _min: RefresheTokenMinAggregateOutputType | null
    _max: RefresheTokenMaxAggregateOutputType | null
  }

  export type RefresheTokenMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    refresh_token: string | null
    device: string | null
    expires_date: Date | null
    user_id: string | null
  }

  export type RefresheTokenMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    refresh_token: string | null
    device: string | null
    expires_date: Date | null
    user_id: string | null
  }

  export type RefresheTokenCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    refresh_token: number
    device: number
    expires_date: number
    user_id: number
    _all: number
  }


  export type RefresheTokenMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    refresh_token?: true
    device?: true
    expires_date?: true
    user_id?: true
  }

  export type RefresheTokenMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    refresh_token?: true
    device?: true
    expires_date?: true
    user_id?: true
  }

  export type RefresheTokenCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    refresh_token?: true
    device?: true
    expires_date?: true
    user_id?: true
    _all?: true
  }

  export type RefresheTokenAggregateArgs = {
    /**
     * Filter which RefresheToken to aggregate.
     * 
    **/
    where?: RefresheTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefresheTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<RefresheTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RefresheTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefresheTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefresheTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefresheTokens
    **/
    _count?: true | RefresheTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefresheTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefresheTokenMaxAggregateInputType
  }

  export type GetRefresheTokenAggregateType<T extends RefresheTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefresheToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefresheToken[P]>
      : GetScalarType<T[P], AggregateRefresheToken[P]>
  }




  export type RefresheTokenGroupByArgs = {
    where?: RefresheTokenWhereInput
    orderBy?: Enumerable<RefresheTokenOrderByWithAggregationInput>
    by: Array<RefresheTokenScalarFieldEnum>
    having?: RefresheTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefresheTokenCountAggregateInputType | true
    _min?: RefresheTokenMinAggregateInputType
    _max?: RefresheTokenMaxAggregateInputType
  }


  export type RefresheTokenGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    refresh_token: string
    device: string
    expires_date: Date
    user_id: string
    _count: RefresheTokenCountAggregateOutputType | null
    _min: RefresheTokenMinAggregateOutputType | null
    _max: RefresheTokenMaxAggregateOutputType | null
  }

  type GetRefresheTokenGroupByPayload<T extends RefresheTokenGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RefresheTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefresheTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefresheTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefresheTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefresheTokenSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    refresh_token?: boolean
    device?: boolean
    expires_date?: boolean
    user_id?: boolean
    user?: boolean | UserArgs
  }

  export type RefresheTokenInclude = {
    user?: boolean | UserArgs
  }

  export type RefresheTokenGetPayload<
    S extends boolean | null | undefined | RefresheTokenArgs,
    U = keyof S
      > = S extends true
        ? RefresheToken
    : S extends undefined
    ? never
    : S extends RefresheTokenArgs | RefresheTokenFindManyArgs
    ?'include' extends U
    ? RefresheToken  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof RefresheToken ? RefresheToken[P] : never
  } 
    : RefresheToken
  : RefresheToken


  type RefresheTokenCountArgs = Merge<
    Omit<RefresheTokenFindManyArgs, 'select' | 'include'> & {
      select?: RefresheTokenCountAggregateInputType | true
    }
  >

  export interface RefresheTokenDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RefresheToken that matches the filter.
     * @param {RefresheTokenFindUniqueArgs} args - Arguments to find a RefresheToken
     * @example
     * // Get one RefresheToken
     * const refresheToken = await prisma.refresheToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RefresheTokenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RefresheTokenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RefresheToken'> extends True ? CheckSelect<T, Prisma__RefresheTokenClient<RefresheToken>, Prisma__RefresheTokenClient<RefresheTokenGetPayload<T>>> : CheckSelect<T, Prisma__RefresheTokenClient<RefresheToken | null >, Prisma__RefresheTokenClient<RefresheTokenGetPayload<T> | null >>

    /**
     * Find the first RefresheToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefresheTokenFindFirstArgs} args - Arguments to find a RefresheToken
     * @example
     * // Get one RefresheToken
     * const refresheToken = await prisma.refresheToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RefresheTokenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RefresheTokenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RefresheToken'> extends True ? CheckSelect<T, Prisma__RefresheTokenClient<RefresheToken>, Prisma__RefresheTokenClient<RefresheTokenGetPayload<T>>> : CheckSelect<T, Prisma__RefresheTokenClient<RefresheToken | null >, Prisma__RefresheTokenClient<RefresheTokenGetPayload<T> | null >>

    /**
     * Find zero or more RefresheTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefresheTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefresheTokens
     * const refresheTokens = await prisma.refresheToken.findMany()
     * 
     * // Get first 10 RefresheTokens
     * const refresheTokens = await prisma.refresheToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refresheTokenWithIdOnly = await prisma.refresheToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RefresheTokenFindManyArgs>(
      args?: SelectSubset<T, RefresheTokenFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RefresheToken>>, PrismaPromise<Array<RefresheTokenGetPayload<T>>>>

    /**
     * Create a RefresheToken.
     * @param {RefresheTokenCreateArgs} args - Arguments to create a RefresheToken.
     * @example
     * // Create one RefresheToken
     * const RefresheToken = await prisma.refresheToken.create({
     *   data: {
     *     // ... data to create a RefresheToken
     *   }
     * })
     * 
    **/
    create<T extends RefresheTokenCreateArgs>(
      args: SelectSubset<T, RefresheTokenCreateArgs>
    ): CheckSelect<T, Prisma__RefresheTokenClient<RefresheToken>, Prisma__RefresheTokenClient<RefresheTokenGetPayload<T>>>

    /**
     * Create many RefresheTokens.
     *     @param {RefresheTokenCreateManyArgs} args - Arguments to create many RefresheTokens.
     *     @example
     *     // Create many RefresheTokens
     *     const refresheToken = await prisma.refresheToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RefresheTokenCreateManyArgs>(
      args?: SelectSubset<T, RefresheTokenCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RefresheToken.
     * @param {RefresheTokenDeleteArgs} args - Arguments to delete one RefresheToken.
     * @example
     * // Delete one RefresheToken
     * const RefresheToken = await prisma.refresheToken.delete({
     *   where: {
     *     // ... filter to delete one RefresheToken
     *   }
     * })
     * 
    **/
    delete<T extends RefresheTokenDeleteArgs>(
      args: SelectSubset<T, RefresheTokenDeleteArgs>
    ): CheckSelect<T, Prisma__RefresheTokenClient<RefresheToken>, Prisma__RefresheTokenClient<RefresheTokenGetPayload<T>>>

    /**
     * Update one RefresheToken.
     * @param {RefresheTokenUpdateArgs} args - Arguments to update one RefresheToken.
     * @example
     * // Update one RefresheToken
     * const refresheToken = await prisma.refresheToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RefresheTokenUpdateArgs>(
      args: SelectSubset<T, RefresheTokenUpdateArgs>
    ): CheckSelect<T, Prisma__RefresheTokenClient<RefresheToken>, Prisma__RefresheTokenClient<RefresheTokenGetPayload<T>>>

    /**
     * Delete zero or more RefresheTokens.
     * @param {RefresheTokenDeleteManyArgs} args - Arguments to filter RefresheTokens to delete.
     * @example
     * // Delete a few RefresheTokens
     * const { count } = await prisma.refresheToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RefresheTokenDeleteManyArgs>(
      args?: SelectSubset<T, RefresheTokenDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefresheTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefresheTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefresheTokens
     * const refresheToken = await prisma.refresheToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RefresheTokenUpdateManyArgs>(
      args: SelectSubset<T, RefresheTokenUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RefresheToken.
     * @param {RefresheTokenUpsertArgs} args - Arguments to update or create a RefresheToken.
     * @example
     * // Update or create a RefresheToken
     * const refresheToken = await prisma.refresheToken.upsert({
     *   create: {
     *     // ... data to create a RefresheToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefresheToken we want to update
     *   }
     * })
    **/
    upsert<T extends RefresheTokenUpsertArgs>(
      args: SelectSubset<T, RefresheTokenUpsertArgs>
    ): CheckSelect<T, Prisma__RefresheTokenClient<RefresheToken>, Prisma__RefresheTokenClient<RefresheTokenGetPayload<T>>>

    /**
     * Count the number of RefresheTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefresheTokenCountArgs} args - Arguments to filter RefresheTokens to count.
     * @example
     * // Count the number of RefresheTokens
     * const count = await prisma.refresheToken.count({
     *   where: {
     *     // ... the filter for the RefresheTokens we want to count
     *   }
     * })
    **/
    count<T extends RefresheTokenCountArgs>(
      args?: Subset<T, RefresheTokenCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefresheTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefresheToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefresheTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefresheTokenAggregateArgs>(args: Subset<T, RefresheTokenAggregateArgs>): PrismaPromise<GetRefresheTokenAggregateType<T>>

    /**
     * Group by RefresheToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefresheTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefresheTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefresheTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefresheTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefresheTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefresheTokenGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefresheToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RefresheTokenClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RefresheToken findUnique
   */
  export type RefresheTokenFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RefresheToken
     * 
    **/
    select?: RefresheTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RefresheTokenInclude | null
    /**
     * Throw an Error if a RefresheToken can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RefresheToken to fetch.
     * 
    **/
    where: RefresheTokenWhereUniqueInput
  }


  /**
   * RefresheToken findFirst
   */
  export type RefresheTokenFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RefresheToken
     * 
    **/
    select?: RefresheTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RefresheTokenInclude | null
    /**
     * Throw an Error if a RefresheToken can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RefresheToken to fetch.
     * 
    **/
    where?: RefresheTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefresheTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<RefresheTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefresheTokens.
     * 
    **/
    cursor?: RefresheTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefresheTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefresheTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefresheTokens.
     * 
    **/
    distinct?: Enumerable<RefresheTokenScalarFieldEnum>
  }


  /**
   * RefresheToken findMany
   */
  export type RefresheTokenFindManyArgs = {
    /**
     * Select specific fields to fetch from the RefresheToken
     * 
    **/
    select?: RefresheTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RefresheTokenInclude | null
    /**
     * Filter, which RefresheTokens to fetch.
     * 
    **/
    where?: RefresheTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefresheTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<RefresheTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefresheTokens.
     * 
    **/
    cursor?: RefresheTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefresheTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefresheTokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RefresheTokenScalarFieldEnum>
  }


  /**
   * RefresheToken create
   */
  export type RefresheTokenCreateArgs = {
    /**
     * Select specific fields to fetch from the RefresheToken
     * 
    **/
    select?: RefresheTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RefresheTokenInclude | null
    /**
     * The data needed to create a RefresheToken.
     * 
    **/
    data: XOR<RefresheTokenCreateInput, RefresheTokenUncheckedCreateInput>
  }


  /**
   * RefresheToken createMany
   */
  export type RefresheTokenCreateManyArgs = {
    /**
     * The data used to create many RefresheTokens.
     * 
    **/
    data: Enumerable<RefresheTokenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RefresheToken update
   */
  export type RefresheTokenUpdateArgs = {
    /**
     * Select specific fields to fetch from the RefresheToken
     * 
    **/
    select?: RefresheTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RefresheTokenInclude | null
    /**
     * The data needed to update a RefresheToken.
     * 
    **/
    data: XOR<RefresheTokenUpdateInput, RefresheTokenUncheckedUpdateInput>
    /**
     * Choose, which RefresheToken to update.
     * 
    **/
    where: RefresheTokenWhereUniqueInput
  }


  /**
   * RefresheToken updateMany
   */
  export type RefresheTokenUpdateManyArgs = {
    /**
     * The data used to update RefresheTokens.
     * 
    **/
    data: XOR<RefresheTokenUpdateManyMutationInput, RefresheTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefresheTokens to update
     * 
    **/
    where?: RefresheTokenWhereInput
  }


  /**
   * RefresheToken upsert
   */
  export type RefresheTokenUpsertArgs = {
    /**
     * Select specific fields to fetch from the RefresheToken
     * 
    **/
    select?: RefresheTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RefresheTokenInclude | null
    /**
     * The filter to search for the RefresheToken to update in case it exists.
     * 
    **/
    where: RefresheTokenWhereUniqueInput
    /**
     * In case the RefresheToken found by the `where` argument doesn't exist, create a new RefresheToken with this data.
     * 
    **/
    create: XOR<RefresheTokenCreateInput, RefresheTokenUncheckedCreateInput>
    /**
     * In case the RefresheToken was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RefresheTokenUpdateInput, RefresheTokenUncheckedUpdateInput>
  }


  /**
   * RefresheToken delete
   */
  export type RefresheTokenDeleteArgs = {
    /**
     * Select specific fields to fetch from the RefresheToken
     * 
    **/
    select?: RefresheTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RefresheTokenInclude | null
    /**
     * Filter which RefresheToken to delete.
     * 
    **/
    where: RefresheTokenWhereUniqueInput
  }


  /**
   * RefresheToken deleteMany
   */
  export type RefresheTokenDeleteManyArgs = {
    /**
     * Filter which RefresheTokens to delete
     * 
    **/
    where?: RefresheTokenWhereInput
  }


  /**
   * RefresheToken without action
   */
  export type RefresheTokenArgs = {
    /**
     * Select specific fields to fetch from the RefresheToken
     * 
    **/
    select?: RefresheTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RefresheTokenInclude | null
  }



  /**
   * Model Category
   */


  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    type: TypeCategoryEnum | null
    slug: string | null
    description: string | null
    photo: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    type: TypeCategoryEnum | null
    slug: string | null
    description: string | null
    photo: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    type: number
    slug: number
    description: number
    photo: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    type?: true
    slug?: true
    description?: true
    photo?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    type?: true
    slug?: true
    description?: true
    photo?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    type?: true
    slug?: true
    description?: true
    photo?: true
    _all?: true
  }

  export type CategoryAggregateArgs = {
    /**
     * Filter which Category to aggregate.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs = {
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithAggregationInput>
    by: Array<CategoryScalarFieldEnum>
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    name: string
    type: TypeCategoryEnum
    slug: string | null
    description: string
    photo: string | null
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    type?: boolean
    slug?: boolean
    description?: boolean
    photo?: boolean
    products?: boolean | CategoryProductFindManyArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }

  export type CategoryInclude = {
    products?: boolean | CategoryProductFindManyArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }

  export type CategoryGetPayload<
    S extends boolean | null | undefined | CategoryArgs,
    U = keyof S
      > = S extends true
        ? Category
    : S extends undefined
    ? never
    : S extends CategoryArgs | CategoryFindManyArgs
    ?'include' extends U
    ? Category  & {
    [P in TrueKeys<S['include']>]:
        P extends 'products' ? Array < CategoryProductGetPayload<S['include'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'products' ? Array < CategoryProductGetPayload<S['select'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Category ? Category[P] : never
  } 
    : Category
  : Category


  type CategoryCountArgs = Merge<
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }
  >

  export interface CategoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Category'> extends True ? CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>> : CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Category'> extends True ? CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>> : CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Category>>, PrismaPromise<Array<CategoryGetPayload<T>>>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends CategoryProductFindManyArgs = {}>(args?: Subset<T, CategoryProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CategoryProduct>>, PrismaPromise<Array<CategoryProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Throw an Error if a Category can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Category to fetch.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Throw an Error if a Category can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Category to fetch.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     * 
    **/
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter, which Categories to fetch.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * The data needed to create a Category.
     * 
    **/
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs = {
    /**
     * The data used to create many Categories.
     * 
    **/
    data: Enumerable<CategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * The data needed to update a Category.
     * 
    **/
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs = {
    /**
     * The data used to update Categories.
     * 
    **/
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     * 
    **/
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * The filter to search for the Category to update in case it exists.
     * 
    **/
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     * 
    **/
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter which Category to delete.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs = {
    /**
     * Filter which Categories to delete
     * 
    **/
    where?: CategoryWhereInput
  }


  /**
   * Category without action
   */
  export type CategoryArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
  }



  /**
   * Model Politic
   */


  export type AggregatePolitic = {
    _count: PoliticCountAggregateOutputType | null
    _avg: PoliticAvgAggregateOutputType | null
    _sum: PoliticSumAggregateOutputType | null
    _min: PoliticMinAggregateOutputType | null
    _max: PoliticMaxAggregateOutputType | null
  }

  export type PoliticAvgAggregateOutputType = {
    reading_time: number | null
  }

  export type PoliticSumAggregateOutputType = {
    reading_time: number | null
  }

  export type PoliticMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    reading_time: number | null
    slug: string | null
    description: string | null
  }

  export type PoliticMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    reading_time: number | null
    slug: string | null
    description: string | null
  }

  export type PoliticCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    reading_time: number
    slug: number
    description: number
    _all: number
  }


  export type PoliticAvgAggregateInputType = {
    reading_time?: true
  }

  export type PoliticSumAggregateInputType = {
    reading_time?: true
  }

  export type PoliticMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    reading_time?: true
    slug?: true
    description?: true
  }

  export type PoliticMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    reading_time?: true
    slug?: true
    description?: true
  }

  export type PoliticCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    reading_time?: true
    slug?: true
    description?: true
    _all?: true
  }

  export type PoliticAggregateArgs = {
    /**
     * Filter which Politic to aggregate.
     * 
    **/
    where?: PoliticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Politics to fetch.
     * 
    **/
    orderBy?: Enumerable<PoliticOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PoliticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Politics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Politics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Politics
    **/
    _count?: true | PoliticCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PoliticAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PoliticSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PoliticMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PoliticMaxAggregateInputType
  }

  export type GetPoliticAggregateType<T extends PoliticAggregateArgs> = {
        [P in keyof T & keyof AggregatePolitic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolitic[P]>
      : GetScalarType<T[P], AggregatePolitic[P]>
  }




  export type PoliticGroupByArgs = {
    where?: PoliticWhereInput
    orderBy?: Enumerable<PoliticOrderByWithAggregationInput>
    by: Array<PoliticScalarFieldEnum>
    having?: PoliticScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PoliticCountAggregateInputType | true
    _avg?: PoliticAvgAggregateInputType
    _sum?: PoliticSumAggregateInputType
    _min?: PoliticMinAggregateInputType
    _max?: PoliticMaxAggregateInputType
  }


  export type PoliticGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    name: string
    reading_time: number
    slug: string
    description: string
    _count: PoliticCountAggregateOutputType | null
    _avg: PoliticAvgAggregateOutputType | null
    _sum: PoliticSumAggregateOutputType | null
    _min: PoliticMinAggregateOutputType | null
    _max: PoliticMaxAggregateOutputType | null
  }

  type GetPoliticGroupByPayload<T extends PoliticGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PoliticGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PoliticGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PoliticGroupByOutputType[P]>
            : GetScalarType<T[P], PoliticGroupByOutputType[P]>
        }
      >
    >


  export type PoliticSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    reading_time?: boolean
    slug?: boolean
    description?: boolean
  }

  export type PoliticGetPayload<
    S extends boolean | null | undefined | PoliticArgs,
    U = keyof S
      > = S extends true
        ? Politic
    : S extends undefined
    ? never
    : S extends PoliticArgs | PoliticFindManyArgs
    ?'include' extends U
    ? Politic 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Politic ? Politic[P] : never
  } 
    : Politic
  : Politic


  type PoliticCountArgs = Merge<
    Omit<PoliticFindManyArgs, 'select' | 'include'> & {
      select?: PoliticCountAggregateInputType | true
    }
  >

  export interface PoliticDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Politic that matches the filter.
     * @param {PoliticFindUniqueArgs} args - Arguments to find a Politic
     * @example
     * // Get one Politic
     * const politic = await prisma.politic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PoliticFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PoliticFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Politic'> extends True ? CheckSelect<T, Prisma__PoliticClient<Politic>, Prisma__PoliticClient<PoliticGetPayload<T>>> : CheckSelect<T, Prisma__PoliticClient<Politic | null >, Prisma__PoliticClient<PoliticGetPayload<T> | null >>

    /**
     * Find the first Politic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoliticFindFirstArgs} args - Arguments to find a Politic
     * @example
     * // Get one Politic
     * const politic = await prisma.politic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PoliticFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PoliticFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Politic'> extends True ? CheckSelect<T, Prisma__PoliticClient<Politic>, Prisma__PoliticClient<PoliticGetPayload<T>>> : CheckSelect<T, Prisma__PoliticClient<Politic | null >, Prisma__PoliticClient<PoliticGetPayload<T> | null >>

    /**
     * Find zero or more Politics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoliticFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Politics
     * const politics = await prisma.politic.findMany()
     * 
     * // Get first 10 Politics
     * const politics = await prisma.politic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const politicWithIdOnly = await prisma.politic.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PoliticFindManyArgs>(
      args?: SelectSubset<T, PoliticFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Politic>>, PrismaPromise<Array<PoliticGetPayload<T>>>>

    /**
     * Create a Politic.
     * @param {PoliticCreateArgs} args - Arguments to create a Politic.
     * @example
     * // Create one Politic
     * const Politic = await prisma.politic.create({
     *   data: {
     *     // ... data to create a Politic
     *   }
     * })
     * 
    **/
    create<T extends PoliticCreateArgs>(
      args: SelectSubset<T, PoliticCreateArgs>
    ): CheckSelect<T, Prisma__PoliticClient<Politic>, Prisma__PoliticClient<PoliticGetPayload<T>>>

    /**
     * Create many Politics.
     *     @param {PoliticCreateManyArgs} args - Arguments to create many Politics.
     *     @example
     *     // Create many Politics
     *     const politic = await prisma.politic.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PoliticCreateManyArgs>(
      args?: SelectSubset<T, PoliticCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Politic.
     * @param {PoliticDeleteArgs} args - Arguments to delete one Politic.
     * @example
     * // Delete one Politic
     * const Politic = await prisma.politic.delete({
     *   where: {
     *     // ... filter to delete one Politic
     *   }
     * })
     * 
    **/
    delete<T extends PoliticDeleteArgs>(
      args: SelectSubset<T, PoliticDeleteArgs>
    ): CheckSelect<T, Prisma__PoliticClient<Politic>, Prisma__PoliticClient<PoliticGetPayload<T>>>

    /**
     * Update one Politic.
     * @param {PoliticUpdateArgs} args - Arguments to update one Politic.
     * @example
     * // Update one Politic
     * const politic = await prisma.politic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PoliticUpdateArgs>(
      args: SelectSubset<T, PoliticUpdateArgs>
    ): CheckSelect<T, Prisma__PoliticClient<Politic>, Prisma__PoliticClient<PoliticGetPayload<T>>>

    /**
     * Delete zero or more Politics.
     * @param {PoliticDeleteManyArgs} args - Arguments to filter Politics to delete.
     * @example
     * // Delete a few Politics
     * const { count } = await prisma.politic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PoliticDeleteManyArgs>(
      args?: SelectSubset<T, PoliticDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Politics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoliticUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Politics
     * const politic = await prisma.politic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PoliticUpdateManyArgs>(
      args: SelectSubset<T, PoliticUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Politic.
     * @param {PoliticUpsertArgs} args - Arguments to update or create a Politic.
     * @example
     * // Update or create a Politic
     * const politic = await prisma.politic.upsert({
     *   create: {
     *     // ... data to create a Politic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Politic we want to update
     *   }
     * })
    **/
    upsert<T extends PoliticUpsertArgs>(
      args: SelectSubset<T, PoliticUpsertArgs>
    ): CheckSelect<T, Prisma__PoliticClient<Politic>, Prisma__PoliticClient<PoliticGetPayload<T>>>

    /**
     * Count the number of Politics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoliticCountArgs} args - Arguments to filter Politics to count.
     * @example
     * // Count the number of Politics
     * const count = await prisma.politic.count({
     *   where: {
     *     // ... the filter for the Politics we want to count
     *   }
     * })
    **/
    count<T extends PoliticCountArgs>(
      args?: Subset<T, PoliticCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PoliticCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Politic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoliticAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PoliticAggregateArgs>(args: Subset<T, PoliticAggregateArgs>): PrismaPromise<GetPoliticAggregateType<T>>

    /**
     * Group by Politic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoliticGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PoliticGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PoliticGroupByArgs['orderBy'] }
        : { orderBy?: PoliticGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PoliticGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPoliticGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Politic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PoliticClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Politic findUnique
   */
  export type PoliticFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Politic
     * 
    **/
    select?: PoliticSelect | null
    /**
     * Throw an Error if a Politic can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Politic to fetch.
     * 
    **/
    where: PoliticWhereUniqueInput
  }


  /**
   * Politic findFirst
   */
  export type PoliticFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Politic
     * 
    **/
    select?: PoliticSelect | null
    /**
     * Throw an Error if a Politic can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Politic to fetch.
     * 
    **/
    where?: PoliticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Politics to fetch.
     * 
    **/
    orderBy?: Enumerable<PoliticOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Politics.
     * 
    **/
    cursor?: PoliticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Politics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Politics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Politics.
     * 
    **/
    distinct?: Enumerable<PoliticScalarFieldEnum>
  }


  /**
   * Politic findMany
   */
  export type PoliticFindManyArgs = {
    /**
     * Select specific fields to fetch from the Politic
     * 
    **/
    select?: PoliticSelect | null
    /**
     * Filter, which Politics to fetch.
     * 
    **/
    where?: PoliticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Politics to fetch.
     * 
    **/
    orderBy?: Enumerable<PoliticOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Politics.
     * 
    **/
    cursor?: PoliticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Politics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Politics.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PoliticScalarFieldEnum>
  }


  /**
   * Politic create
   */
  export type PoliticCreateArgs = {
    /**
     * Select specific fields to fetch from the Politic
     * 
    **/
    select?: PoliticSelect | null
    /**
     * The data needed to create a Politic.
     * 
    **/
    data: XOR<PoliticCreateInput, PoliticUncheckedCreateInput>
  }


  /**
   * Politic createMany
   */
  export type PoliticCreateManyArgs = {
    /**
     * The data used to create many Politics.
     * 
    **/
    data: Enumerable<PoliticCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Politic update
   */
  export type PoliticUpdateArgs = {
    /**
     * Select specific fields to fetch from the Politic
     * 
    **/
    select?: PoliticSelect | null
    /**
     * The data needed to update a Politic.
     * 
    **/
    data: XOR<PoliticUpdateInput, PoliticUncheckedUpdateInput>
    /**
     * Choose, which Politic to update.
     * 
    **/
    where: PoliticWhereUniqueInput
  }


  /**
   * Politic updateMany
   */
  export type PoliticUpdateManyArgs = {
    /**
     * The data used to update Politics.
     * 
    **/
    data: XOR<PoliticUpdateManyMutationInput, PoliticUncheckedUpdateManyInput>
    /**
     * Filter which Politics to update
     * 
    **/
    where?: PoliticWhereInput
  }


  /**
   * Politic upsert
   */
  export type PoliticUpsertArgs = {
    /**
     * Select specific fields to fetch from the Politic
     * 
    **/
    select?: PoliticSelect | null
    /**
     * The filter to search for the Politic to update in case it exists.
     * 
    **/
    where: PoliticWhereUniqueInput
    /**
     * In case the Politic found by the `where` argument doesn't exist, create a new Politic with this data.
     * 
    **/
    create: XOR<PoliticCreateInput, PoliticUncheckedCreateInput>
    /**
     * In case the Politic was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PoliticUpdateInput, PoliticUncheckedUpdateInput>
  }


  /**
   * Politic delete
   */
  export type PoliticDeleteArgs = {
    /**
     * Select specific fields to fetch from the Politic
     * 
    **/
    select?: PoliticSelect | null
    /**
     * Filter which Politic to delete.
     * 
    **/
    where: PoliticWhereUniqueInput
  }


  /**
   * Politic deleteMany
   */
  export type PoliticDeleteManyArgs = {
    /**
     * Filter which Politics to delete
     * 
    **/
    where?: PoliticWhereInput
  }


  /**
   * Politic without action
   */
  export type PoliticArgs = {
    /**
     * Select specific fields to fetch from the Politic
     * 
    **/
    select?: PoliticSelect | null
  }



  /**
   * Model SubCategory
   */


  export type AggregateSubCategory = {
    _count: SubCategoryCountAggregateOutputType | null
    _min: SubCategoryMinAggregateOutputType | null
    _max: SubCategoryMaxAggregateOutputType | null
  }

  export type SubCategoryMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
  }

  export type SubCategoryMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
  }

  export type SubCategoryCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    _all: number
  }


  export type SubCategoryMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
  }

  export type SubCategoryMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
  }

  export type SubCategoryCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    _all?: true
  }

  export type SubCategoryAggregateArgs = {
    /**
     * Filter which SubCategory to aggregate.
     * 
    **/
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<SubCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubCategories
    **/
    _count?: true | SubCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubCategoryMaxAggregateInputType
  }

  export type GetSubCategoryAggregateType<T extends SubCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubCategory[P]>
      : GetScalarType<T[P], AggregateSubCategory[P]>
  }




  export type SubCategoryGroupByArgs = {
    where?: SubCategoryWhereInput
    orderBy?: Enumerable<SubCategoryOrderByWithAggregationInput>
    by: Array<SubCategoryScalarFieldEnum>
    having?: SubCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubCategoryCountAggregateInputType | true
    _min?: SubCategoryMinAggregateInputType
    _max?: SubCategoryMaxAggregateInputType
  }


  export type SubCategoryGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    name: string
    _count: SubCategoryCountAggregateOutputType | null
    _min: SubCategoryMinAggregateOutputType | null
    _max: SubCategoryMaxAggregateOutputType | null
  }

  type GetSubCategoryGroupByPayload<T extends SubCategoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SubCategoryGroupByOutputType[P]>
        }
      >
    >


  export type SubCategorySelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    products?: boolean | ProductFindManyArgs
    _count?: boolean | SubCategoryCountOutputTypeArgs
  }

  export type SubCategoryInclude = {
    products?: boolean | ProductFindManyArgs
    _count?: boolean | SubCategoryCountOutputTypeArgs
  }

  export type SubCategoryGetPayload<
    S extends boolean | null | undefined | SubCategoryArgs,
    U = keyof S
      > = S extends true
        ? SubCategory
    : S extends undefined
    ? never
    : S extends SubCategoryArgs | SubCategoryFindManyArgs
    ?'include' extends U
    ? SubCategory  & {
    [P in TrueKeys<S['include']>]:
        P extends 'products' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends '_count' ? SubCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'products' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends '_count' ? SubCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof SubCategory ? SubCategory[P] : never
  } 
    : SubCategory
  : SubCategory


  type SubCategoryCountArgs = Merge<
    Omit<SubCategoryFindManyArgs, 'select' | 'include'> & {
      select?: SubCategoryCountAggregateInputType | true
    }
  >

  export interface SubCategoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SubCategory that matches the filter.
     * @param {SubCategoryFindUniqueArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubCategory'> extends True ? CheckSelect<T, Prisma__SubCategoryClient<SubCategory>, Prisma__SubCategoryClient<SubCategoryGetPayload<T>>> : CheckSelect<T, Prisma__SubCategoryClient<SubCategory | null >, Prisma__SubCategoryClient<SubCategoryGetPayload<T> | null >>

    /**
     * Find the first SubCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindFirstArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubCategory'> extends True ? CheckSelect<T, Prisma__SubCategoryClient<SubCategory>, Prisma__SubCategoryClient<SubCategoryGetPayload<T>>> : CheckSelect<T, Prisma__SubCategoryClient<SubCategory | null >, Prisma__SubCategoryClient<SubCategoryGetPayload<T> | null >>

    /**
     * Find zero or more SubCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubCategories
     * const subCategories = await prisma.subCategory.findMany()
     * 
     * // Get first 10 SubCategories
     * const subCategories = await prisma.subCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subCategoryWithIdOnly = await prisma.subCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubCategoryFindManyArgs>(
      args?: SelectSubset<T, SubCategoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SubCategory>>, PrismaPromise<Array<SubCategoryGetPayload<T>>>>

    /**
     * Create a SubCategory.
     * @param {SubCategoryCreateArgs} args - Arguments to create a SubCategory.
     * @example
     * // Create one SubCategory
     * const SubCategory = await prisma.subCategory.create({
     *   data: {
     *     // ... data to create a SubCategory
     *   }
     * })
     * 
    **/
    create<T extends SubCategoryCreateArgs>(
      args: SelectSubset<T, SubCategoryCreateArgs>
    ): CheckSelect<T, Prisma__SubCategoryClient<SubCategory>, Prisma__SubCategoryClient<SubCategoryGetPayload<T>>>

    /**
     * Create many SubCategories.
     *     @param {SubCategoryCreateManyArgs} args - Arguments to create many SubCategories.
     *     @example
     *     // Create many SubCategories
     *     const subCategory = await prisma.subCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubCategoryCreateManyArgs>(
      args?: SelectSubset<T, SubCategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SubCategory.
     * @param {SubCategoryDeleteArgs} args - Arguments to delete one SubCategory.
     * @example
     * // Delete one SubCategory
     * const SubCategory = await prisma.subCategory.delete({
     *   where: {
     *     // ... filter to delete one SubCategory
     *   }
     * })
     * 
    **/
    delete<T extends SubCategoryDeleteArgs>(
      args: SelectSubset<T, SubCategoryDeleteArgs>
    ): CheckSelect<T, Prisma__SubCategoryClient<SubCategory>, Prisma__SubCategoryClient<SubCategoryGetPayload<T>>>

    /**
     * Update one SubCategory.
     * @param {SubCategoryUpdateArgs} args - Arguments to update one SubCategory.
     * @example
     * // Update one SubCategory
     * const subCategory = await prisma.subCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubCategoryUpdateArgs>(
      args: SelectSubset<T, SubCategoryUpdateArgs>
    ): CheckSelect<T, Prisma__SubCategoryClient<SubCategory>, Prisma__SubCategoryClient<SubCategoryGetPayload<T>>>

    /**
     * Delete zero or more SubCategories.
     * @param {SubCategoryDeleteManyArgs} args - Arguments to filter SubCategories to delete.
     * @example
     * // Delete a few SubCategories
     * const { count } = await prisma.subCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubCategoryDeleteManyArgs>(
      args?: SelectSubset<T, SubCategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubCategories
     * const subCategory = await prisma.subCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubCategoryUpdateManyArgs>(
      args: SelectSubset<T, SubCategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SubCategory.
     * @param {SubCategoryUpsertArgs} args - Arguments to update or create a SubCategory.
     * @example
     * // Update or create a SubCategory
     * const subCategory = await prisma.subCategory.upsert({
     *   create: {
     *     // ... data to create a SubCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubCategory we want to update
     *   }
     * })
    **/
    upsert<T extends SubCategoryUpsertArgs>(
      args: SelectSubset<T, SubCategoryUpsertArgs>
    ): CheckSelect<T, Prisma__SubCategoryClient<SubCategory>, Prisma__SubCategoryClient<SubCategoryGetPayload<T>>>

    /**
     * Count the number of SubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryCountArgs} args - Arguments to filter SubCategories to count.
     * @example
     * // Count the number of SubCategories
     * const count = await prisma.subCategory.count({
     *   where: {
     *     // ... the filter for the SubCategories we want to count
     *   }
     * })
    **/
    count<T extends SubCategoryCountArgs>(
      args?: Subset<T, SubCategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubCategoryAggregateArgs>(args: Subset<T, SubCategoryAggregateArgs>): PrismaPromise<GetSubCategoryAggregateType<T>>

    /**
     * Group by SubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubCategoryGroupByArgs['orderBy'] }
        : { orderBy?: SubCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubCategoryGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubCategoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SubCategory findUnique
   */
  export type SubCategoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     * 
    **/
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubCategoryInclude | null
    /**
     * Throw an Error if a SubCategory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SubCategory to fetch.
     * 
    **/
    where: SubCategoryWhereUniqueInput
  }


  /**
   * SubCategory findFirst
   */
  export type SubCategoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     * 
    **/
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubCategoryInclude | null
    /**
     * Throw an Error if a SubCategory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SubCategory to fetch.
     * 
    **/
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<SubCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategories.
     * 
    **/
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategories.
     * 
    **/
    distinct?: Enumerable<SubCategoryScalarFieldEnum>
  }


  /**
   * SubCategory findMany
   */
  export type SubCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     * 
    **/
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubCategoryInclude | null
    /**
     * Filter, which SubCategories to fetch.
     * 
    **/
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<SubCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubCategories.
     * 
    **/
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubCategoryScalarFieldEnum>
  }


  /**
   * SubCategory create
   */
  export type SubCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     * 
    **/
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubCategoryInclude | null
    /**
     * The data needed to create a SubCategory.
     * 
    **/
    data: XOR<SubCategoryCreateInput, SubCategoryUncheckedCreateInput>
  }


  /**
   * SubCategory createMany
   */
  export type SubCategoryCreateManyArgs = {
    /**
     * The data used to create many SubCategories.
     * 
    **/
    data: Enumerable<SubCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SubCategory update
   */
  export type SubCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     * 
    **/
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubCategoryInclude | null
    /**
     * The data needed to update a SubCategory.
     * 
    **/
    data: XOR<SubCategoryUpdateInput, SubCategoryUncheckedUpdateInput>
    /**
     * Choose, which SubCategory to update.
     * 
    **/
    where: SubCategoryWhereUniqueInput
  }


  /**
   * SubCategory updateMany
   */
  export type SubCategoryUpdateManyArgs = {
    /**
     * The data used to update SubCategories.
     * 
    **/
    data: XOR<SubCategoryUpdateManyMutationInput, SubCategoryUncheckedUpdateManyInput>
    /**
     * Filter which SubCategories to update
     * 
    **/
    where?: SubCategoryWhereInput
  }


  /**
   * SubCategory upsert
   */
  export type SubCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     * 
    **/
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubCategoryInclude | null
    /**
     * The filter to search for the SubCategory to update in case it exists.
     * 
    **/
    where: SubCategoryWhereUniqueInput
    /**
     * In case the SubCategory found by the `where` argument doesn't exist, create a new SubCategory with this data.
     * 
    **/
    create: XOR<SubCategoryCreateInput, SubCategoryUncheckedCreateInput>
    /**
     * In case the SubCategory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubCategoryUpdateInput, SubCategoryUncheckedUpdateInput>
  }


  /**
   * SubCategory delete
   */
  export type SubCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     * 
    **/
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubCategoryInclude | null
    /**
     * Filter which SubCategory to delete.
     * 
    **/
    where: SubCategoryWhereUniqueInput
  }


  /**
   * SubCategory deleteMany
   */
  export type SubCategoryDeleteManyArgs = {
    /**
     * Filter which SubCategories to delete
     * 
    **/
    where?: SubCategoryWhereInput
  }


  /**
   * SubCategory without action
   */
  export type SubCategoryArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     * 
    **/
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubCategoryInclude | null
  }



  /**
   * Model Order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    total: Decimal | null
    freight: Decimal | null
  }

  export type OrderSumAggregateOutputType = {
    total: Decimal | null
    freight: Decimal | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    total: Decimal | null
    freight: Decimal | null
    canceled_at: Date | null
    status: StatusOrderEnum | null
    user_id: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    total: Decimal | null
    freight: Decimal | null
    canceled_at: Date | null
    status: StatusOrderEnum | null
    user_id: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    total: number
    freight: number
    canceled_at: number
    status: number
    user_id: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    total?: true
    freight?: true
  }

  export type OrderSumAggregateInputType = {
    total?: true
    freight?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    total?: true
    freight?: true
    canceled_at?: true
    status?: true
    user_id?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    total?: true
    freight?: true
    canceled_at?: true
    status?: true
    user_id?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    total?: true
    freight?: true
    canceled_at?: true
    status?: true
    user_id?: true
    _all?: true
  }

  export type OrderAggregateArgs = {
    /**
     * Filter which Order to aggregate.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs = {
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithAggregationInput>
    by: Array<OrderScalarFieldEnum>
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    total: Decimal
    freight: Decimal
    canceled_at: Date | null
    status: StatusOrderEnum
    user_id: string
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    total?: boolean
    freight?: boolean
    canceled_at?: boolean
    status?: boolean
    user_id?: boolean
    user?: boolean | UserArgs
    ordersProducts?: boolean | OrderProductFindManyArgs
    transactions?: boolean | TransactionFindManyArgs
    _count?: boolean | OrderCountOutputTypeArgs
  }

  export type OrderInclude = {
    user?: boolean | UserArgs
    ordersProducts?: boolean | OrderProductFindManyArgs
    transactions?: boolean | TransactionFindManyArgs
    _count?: boolean | OrderCountOutputTypeArgs
  }

  export type OrderGetPayload<
    S extends boolean | null | undefined | OrderArgs,
    U = keyof S
      > = S extends true
        ? Order
    : S extends undefined
    ? never
    : S extends OrderArgs | OrderFindManyArgs
    ?'include' extends U
    ? Order  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'ordersProducts' ? Array < OrderProductGetPayload<S['include'][P]>>  :
        P extends 'transactions' ? Array < TransactionGetPayload<S['include'][P]>>  :
        P extends '_count' ? OrderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'ordersProducts' ? Array < OrderProductGetPayload<S['select'][P]>>  :
        P extends 'transactions' ? Array < TransactionGetPayload<S['select'][P]>>  :
        P extends '_count' ? OrderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Order ? Order[P] : never
  } 
    : Order
  : Order


  type OrderCountArgs = Merge<
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }
  >

  export interface OrderDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Order'> extends True ? CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>> : CheckSelect<T, Prisma__OrderClient<Order | null >, Prisma__OrderClient<OrderGetPayload<T> | null >>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Order'> extends True ? CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>> : CheckSelect<T, Prisma__OrderClient<Order | null >, Prisma__OrderClient<OrderGetPayload<T> | null >>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    ordersProducts<T extends OrderProductFindManyArgs = {}>(args?: Subset<T, OrderProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderProduct>>, PrismaPromise<Array<OrderProductGetPayload<T>>>>;

    transactions<T extends TransactionFindManyArgs = {}>(args?: Subset<T, TransactionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Transaction>>, PrismaPromise<Array<TransactionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Throw an Error if a Order can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Throw an Error if a Order can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     * 
    **/
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order findMany
   */
  export type OrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Orders to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order create
   */
  export type OrderCreateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to create a Order.
     * 
    **/
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs = {
    /**
     * The data used to create many Orders.
     * 
    **/
    data: Enumerable<OrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to update a Order.
     * 
    **/
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs = {
    /**
     * The data used to update Orders.
     * 
    **/
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     * 
    **/
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The filter to search for the Order to update in case it exists.
     * 
    **/
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     * 
    **/
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter which Order to delete.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs = {
    /**
     * Filter which Orders to delete
     * 
    **/
    where?: OrderWhereInput
  }


  /**
   * Order without action
   */
  export type OrderArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    sku: string | null
    bar_code: string | null
    canceled_at: Date | null
    status: boolean | null
    status_freight: boolean | null
    status_product: boolean | null
    price_id: string | null
    description_id: string | null
    subcategory_id: string | null
    product_info_id: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    sku: string | null
    bar_code: string | null
    canceled_at: Date | null
    status: boolean | null
    status_freight: boolean | null
    status_product: boolean | null
    price_id: string | null
    description_id: string | null
    subcategory_id: string | null
    product_info_id: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    sku: number
    bar_code: number
    other: number
    canceled_at: number
    status: number
    status_freight: number
    status_product: number
    price_id: number
    description_id: number
    subcategory_id: number
    product_info_id: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    sku?: true
    bar_code?: true
    canceled_at?: true
    status?: true
    status_freight?: true
    status_product?: true
    price_id?: true
    description_id?: true
    subcategory_id?: true
    product_info_id?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    sku?: true
    bar_code?: true
    canceled_at?: true
    status?: true
    status_freight?: true
    status_product?: true
    price_id?: true
    description_id?: true
    subcategory_id?: true
    product_info_id?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    sku?: true
    bar_code?: true
    other?: true
    canceled_at?: true
    status?: true
    status_freight?: true
    status_product?: true
    price_id?: true
    description_id?: true
    subcategory_id?: true
    product_info_id?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: Array<ProductScalarFieldEnum>
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    sku: string | null
    bar_code: string | null
    other: JsonValue | null
    canceled_at: Date | null
    status: boolean
    status_freight: boolean
    status_product: boolean
    price_id: string | null
    description_id: string
    subcategory_id: string
    product_info_id: string
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    sku?: boolean
    bar_code?: boolean
    other?: boolean
    canceled_at?: boolean
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price_id?: boolean
    price?: boolean | PriceArgs
    description_id?: boolean
    description?: boolean | DescriptionArgs
    subcategory_id?: boolean
    subcategory?: boolean | SubCategoryArgs
    product_info_id?: boolean
    product_info?: boolean | ProductInfoArgs
    categories?: boolean | CategoryProductFindManyArgs
    photos?: boolean | PhotoFindManyArgs
    reviews?: boolean | ReviewFindManyArgs
    videos?: boolean | VideoFindManyArgs
    stocks?: boolean | StockFindManyArgs
    ordersProducts?: boolean | OrderProductFindManyArgs
    prices?: boolean | PriceFindManyArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductInclude = {
    price?: boolean | PriceArgs
    description?: boolean | DescriptionArgs
    subcategory?: boolean | SubCategoryArgs
    product_info?: boolean | ProductInfoArgs
    categories?: boolean | CategoryProductFindManyArgs
    photos?: boolean | PhotoFindManyArgs
    reviews?: boolean | ReviewFindManyArgs
    videos?: boolean | VideoFindManyArgs
    stocks?: boolean | StockFindManyArgs
    ordersProducts?: boolean | OrderProductFindManyArgs
    prices?: boolean | PriceFindManyArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductGetPayload<
    S extends boolean | null | undefined | ProductArgs,
    U = keyof S
      > = S extends true
        ? Product
    : S extends undefined
    ? never
    : S extends ProductArgs | ProductFindManyArgs
    ?'include' extends U
    ? Product  & {
    [P in TrueKeys<S['include']>]:
        P extends 'price' ? PriceGetPayload<S['include'][P]> | null :
        P extends 'description' ? DescriptionGetPayload<S['include'][P]> :
        P extends 'subcategory' ? SubCategoryGetPayload<S['include'][P]> :
        P extends 'product_info' ? ProductInfoGetPayload<S['include'][P]> :
        P extends 'categories' ? Array < CategoryProductGetPayload<S['include'][P]>>  :
        P extends 'photos' ? Array < PhotoGetPayload<S['include'][P]>>  :
        P extends 'reviews' ? Array < ReviewGetPayload<S['include'][P]>>  :
        P extends 'videos' ? Array < VideoGetPayload<S['include'][P]>>  :
        P extends 'stocks' ? Array < StockGetPayload<S['include'][P]>>  :
        P extends 'ordersProducts' ? Array < OrderProductGetPayload<S['include'][P]>>  :
        P extends 'prices' ? Array < PriceGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'price' ? PriceGetPayload<S['select'][P]> | null :
        P extends 'description' ? DescriptionGetPayload<S['select'][P]> :
        P extends 'subcategory' ? SubCategoryGetPayload<S['select'][P]> :
        P extends 'product_info' ? ProductInfoGetPayload<S['select'][P]> :
        P extends 'categories' ? Array < CategoryProductGetPayload<S['select'][P]>>  :
        P extends 'photos' ? Array < PhotoGetPayload<S['select'][P]>>  :
        P extends 'reviews' ? Array < ReviewGetPayload<S['select'][P]>>  :
        P extends 'videos' ? Array < VideoGetPayload<S['select'][P]>>  :
        P extends 'stocks' ? Array < StockGetPayload<S['select'][P]>>  :
        P extends 'ordersProducts' ? Array < OrderProductGetPayload<S['select'][P]>>  :
        P extends 'prices' ? Array < PriceGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Product ? Product[P] : never
  } 
    : Product
  : Product


  type ProductCountArgs = Merge<
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }
  >

  export interface ProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    price<T extends PriceArgs = {}>(args?: Subset<T, PriceArgs>): CheckSelect<T, Prisma__PriceClient<Price | null >, Prisma__PriceClient<PriceGetPayload<T> | null >>;

    description<T extends DescriptionArgs = {}>(args?: Subset<T, DescriptionArgs>): CheckSelect<T, Prisma__DescriptionClient<Description | null >, Prisma__DescriptionClient<DescriptionGetPayload<T> | null >>;

    subcategory<T extends SubCategoryArgs = {}>(args?: Subset<T, SubCategoryArgs>): CheckSelect<T, Prisma__SubCategoryClient<SubCategory | null >, Prisma__SubCategoryClient<SubCategoryGetPayload<T> | null >>;

    product_info<T extends ProductInfoArgs = {}>(args?: Subset<T, ProductInfoArgs>): CheckSelect<T, Prisma__ProductInfoClient<ProductInfo | null >, Prisma__ProductInfoClient<ProductInfoGetPayload<T> | null >>;

    categories<T extends CategoryProductFindManyArgs = {}>(args?: Subset<T, CategoryProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CategoryProduct>>, PrismaPromise<Array<CategoryProductGetPayload<T>>>>;

    photos<T extends PhotoFindManyArgs = {}>(args?: Subset<T, PhotoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Photo>>, PrismaPromise<Array<PhotoGetPayload<T>>>>;

    reviews<T extends ReviewFindManyArgs = {}>(args?: Subset<T, ReviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Review>>, PrismaPromise<Array<ReviewGetPayload<T>>>>;

    videos<T extends VideoFindManyArgs = {}>(args?: Subset<T, VideoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Video>>, PrismaPromise<Array<VideoGetPayload<T>>>>;

    stocks<T extends StockFindManyArgs = {}>(args?: Subset<T, StockFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Stock>>, PrismaPromise<Array<StockGetPayload<T>>>>;

    ordersProducts<T extends OrderProductFindManyArgs = {}>(args?: Subset<T, OrderProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderProduct>>, PrismaPromise<Array<OrderProductGetPayload<T>>>>;

    prices<T extends PriceFindManyArgs = {}>(args?: Subset<T, PriceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Price>>, PrismaPromise<Array<PriceGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     * 
    **/
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    /**
     * The data used to create many Products.
     * 
    **/
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     * 
    **/
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    /**
     * The data used to update Products.
     * 
    **/
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     * 
    **/
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     * 
    **/
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    /**
     * Filter which Products to delete
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
  }



  /**
   * Model CategoryProduct
   */


  export type AggregateCategoryProduct = {
    _count: CategoryProductCountAggregateOutputType | null
    _min: CategoryProductMinAggregateOutputType | null
    _max: CategoryProductMaxAggregateOutputType | null
  }

  export type CategoryProductMinAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    category_id: string | null
    product_id: string | null
  }

  export type CategoryProductMaxAggregateOutputType = {
    created_at: Date | null
    updated_at: Date | null
    category_id: string | null
    product_id: string | null
  }

  export type CategoryProductCountAggregateOutputType = {
    created_at: number
    updated_at: number
    category_id: number
    product_id: number
    _all: number
  }


  export type CategoryProductMinAggregateInputType = {
    created_at?: true
    updated_at?: true
    category_id?: true
    product_id?: true
  }

  export type CategoryProductMaxAggregateInputType = {
    created_at?: true
    updated_at?: true
    category_id?: true
    product_id?: true
  }

  export type CategoryProductCountAggregateInputType = {
    created_at?: true
    updated_at?: true
    category_id?: true
    product_id?: true
    _all?: true
  }

  export type CategoryProductAggregateArgs = {
    /**
     * Filter which CategoryProduct to aggregate.
     * 
    **/
    where?: CategoryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CategoryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoryProducts
    **/
    _count?: true | CategoryProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryProductMaxAggregateInputType
  }

  export type GetCategoryProductAggregateType<T extends CategoryProductAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoryProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoryProduct[P]>
      : GetScalarType<T[P], AggregateCategoryProduct[P]>
  }




  export type CategoryProductGroupByArgs = {
    where?: CategoryProductWhereInput
    orderBy?: Enumerable<CategoryProductOrderByWithAggregationInput>
    by: Array<CategoryProductScalarFieldEnum>
    having?: CategoryProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryProductCountAggregateInputType | true
    _min?: CategoryProductMinAggregateInputType
    _max?: CategoryProductMaxAggregateInputType
  }


  export type CategoryProductGroupByOutputType = {
    created_at: Date
    updated_at: Date
    category_id: string
    product_id: string
    _count: CategoryProductCountAggregateOutputType | null
    _min: CategoryProductMinAggregateOutputType | null
    _max: CategoryProductMaxAggregateOutputType | null
  }

  type GetCategoryProductGroupByPayload<T extends CategoryProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CategoryProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryProductGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryProductGroupByOutputType[P]>
        }
      >
    >


  export type CategoryProductSelect = {
    created_at?: boolean
    updated_at?: boolean
    category_id?: boolean
    category?: boolean | CategoryArgs
    product_id?: boolean
    product?: boolean | ProductArgs
  }

  export type CategoryProductInclude = {
    category?: boolean | CategoryArgs
    product?: boolean | ProductArgs
  }

  export type CategoryProductGetPayload<
    S extends boolean | null | undefined | CategoryProductArgs,
    U = keyof S
      > = S extends true
        ? CategoryProduct
    : S extends undefined
    ? never
    : S extends CategoryProductArgs | CategoryProductFindManyArgs
    ?'include' extends U
    ? CategoryProduct  & {
    [P in TrueKeys<S['include']>]:
        P extends 'category' ? CategoryGetPayload<S['include'][P]> :
        P extends 'product' ? ProductGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'category' ? CategoryGetPayload<S['select'][P]> :
        P extends 'product' ? ProductGetPayload<S['select'][P]> :  P extends keyof CategoryProduct ? CategoryProduct[P] : never
  } 
    : CategoryProduct
  : CategoryProduct


  type CategoryProductCountArgs = Merge<
    Omit<CategoryProductFindManyArgs, 'select' | 'include'> & {
      select?: CategoryProductCountAggregateInputType | true
    }
  >

  export interface CategoryProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CategoryProduct that matches the filter.
     * @param {CategoryProductFindUniqueArgs} args - Arguments to find a CategoryProduct
     * @example
     * // Get one CategoryProduct
     * const categoryProduct = await prisma.categoryProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CategoryProduct'> extends True ? CheckSelect<T, Prisma__CategoryProductClient<CategoryProduct>, Prisma__CategoryProductClient<CategoryProductGetPayload<T>>> : CheckSelect<T, Prisma__CategoryProductClient<CategoryProduct | null >, Prisma__CategoryProductClient<CategoryProductGetPayload<T> | null >>

    /**
     * Find the first CategoryProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryProductFindFirstArgs} args - Arguments to find a CategoryProduct
     * @example
     * // Get one CategoryProduct
     * const categoryProduct = await prisma.categoryProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CategoryProduct'> extends True ? CheckSelect<T, Prisma__CategoryProductClient<CategoryProduct>, Prisma__CategoryProductClient<CategoryProductGetPayload<T>>> : CheckSelect<T, Prisma__CategoryProductClient<CategoryProduct | null >, Prisma__CategoryProductClient<CategoryProductGetPayload<T> | null >>

    /**
     * Find zero or more CategoryProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoryProducts
     * const categoryProducts = await prisma.categoryProduct.findMany()
     * 
     * // Get first 10 CategoryProducts
     * const categoryProducts = await prisma.categoryProduct.findMany({ take: 10 })
     * 
     * // Only select the `created_at`
     * const categoryProductWithCreated_atOnly = await prisma.categoryProduct.findMany({ select: { created_at: true } })
     * 
    **/
    findMany<T extends CategoryProductFindManyArgs>(
      args?: SelectSubset<T, CategoryProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CategoryProduct>>, PrismaPromise<Array<CategoryProductGetPayload<T>>>>

    /**
     * Create a CategoryProduct.
     * @param {CategoryProductCreateArgs} args - Arguments to create a CategoryProduct.
     * @example
     * // Create one CategoryProduct
     * const CategoryProduct = await prisma.categoryProduct.create({
     *   data: {
     *     // ... data to create a CategoryProduct
     *   }
     * })
     * 
    **/
    create<T extends CategoryProductCreateArgs>(
      args: SelectSubset<T, CategoryProductCreateArgs>
    ): CheckSelect<T, Prisma__CategoryProductClient<CategoryProduct>, Prisma__CategoryProductClient<CategoryProductGetPayload<T>>>

    /**
     * Create many CategoryProducts.
     *     @param {CategoryProductCreateManyArgs} args - Arguments to create many CategoryProducts.
     *     @example
     *     // Create many CategoryProducts
     *     const categoryProduct = await prisma.categoryProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryProductCreateManyArgs>(
      args?: SelectSubset<T, CategoryProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CategoryProduct.
     * @param {CategoryProductDeleteArgs} args - Arguments to delete one CategoryProduct.
     * @example
     * // Delete one CategoryProduct
     * const CategoryProduct = await prisma.categoryProduct.delete({
     *   where: {
     *     // ... filter to delete one CategoryProduct
     *   }
     * })
     * 
    **/
    delete<T extends CategoryProductDeleteArgs>(
      args: SelectSubset<T, CategoryProductDeleteArgs>
    ): CheckSelect<T, Prisma__CategoryProductClient<CategoryProduct>, Prisma__CategoryProductClient<CategoryProductGetPayload<T>>>

    /**
     * Update one CategoryProduct.
     * @param {CategoryProductUpdateArgs} args - Arguments to update one CategoryProduct.
     * @example
     * // Update one CategoryProduct
     * const categoryProduct = await prisma.categoryProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryProductUpdateArgs>(
      args: SelectSubset<T, CategoryProductUpdateArgs>
    ): CheckSelect<T, Prisma__CategoryProductClient<CategoryProduct>, Prisma__CategoryProductClient<CategoryProductGetPayload<T>>>

    /**
     * Delete zero or more CategoryProducts.
     * @param {CategoryProductDeleteManyArgs} args - Arguments to filter CategoryProducts to delete.
     * @example
     * // Delete a few CategoryProducts
     * const { count } = await prisma.categoryProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryProductDeleteManyArgs>(
      args?: SelectSubset<T, CategoryProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoryProducts
     * const categoryProduct = await prisma.categoryProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryProductUpdateManyArgs>(
      args: SelectSubset<T, CategoryProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CategoryProduct.
     * @param {CategoryProductUpsertArgs} args - Arguments to update or create a CategoryProduct.
     * @example
     * // Update or create a CategoryProduct
     * const categoryProduct = await prisma.categoryProduct.upsert({
     *   create: {
     *     // ... data to create a CategoryProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoryProduct we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryProductUpsertArgs>(
      args: SelectSubset<T, CategoryProductUpsertArgs>
    ): CheckSelect<T, Prisma__CategoryProductClient<CategoryProduct>, Prisma__CategoryProductClient<CategoryProductGetPayload<T>>>

    /**
     * Count the number of CategoryProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryProductCountArgs} args - Arguments to filter CategoryProducts to count.
     * @example
     * // Count the number of CategoryProducts
     * const count = await prisma.categoryProduct.count({
     *   where: {
     *     // ... the filter for the CategoryProducts we want to count
     *   }
     * })
    **/
    count<T extends CategoryProductCountArgs>(
      args?: Subset<T, CategoryProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoryProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryProductAggregateArgs>(args: Subset<T, CategoryProductAggregateArgs>): PrismaPromise<GetCategoryProductAggregateType<T>>

    /**
     * Group by CategoryProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryProductGroupByArgs['orderBy'] }
        : { orderBy?: CategoryProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryProductGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoryProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    category<T extends CategoryArgs = {}>(args?: Subset<T, CategoryArgs>): CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>;

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CategoryProduct findUnique
   */
  export type CategoryProductFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     * 
    **/
    select?: CategoryProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryProductInclude | null
    /**
     * Throw an Error if a CategoryProduct can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CategoryProduct to fetch.
     * 
    **/
    where: CategoryProductWhereUniqueInput
  }


  /**
   * CategoryProduct findFirst
   */
  export type CategoryProductFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     * 
    **/
    select?: CategoryProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryProductInclude | null
    /**
     * Throw an Error if a CategoryProduct can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CategoryProduct to fetch.
     * 
    **/
    where?: CategoryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryProducts.
     * 
    **/
    cursor?: CategoryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryProducts.
     * 
    **/
    distinct?: Enumerable<CategoryProductScalarFieldEnum>
  }


  /**
   * CategoryProduct findMany
   */
  export type CategoryProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     * 
    **/
    select?: CategoryProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryProductInclude | null
    /**
     * Filter, which CategoryProducts to fetch.
     * 
    **/
    where?: CategoryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoryProducts.
     * 
    **/
    cursor?: CategoryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryProducts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CategoryProductScalarFieldEnum>
  }


  /**
   * CategoryProduct create
   */
  export type CategoryProductCreateArgs = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     * 
    **/
    select?: CategoryProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryProductInclude | null
    /**
     * The data needed to create a CategoryProduct.
     * 
    **/
    data: XOR<CategoryProductCreateInput, CategoryProductUncheckedCreateInput>
  }


  /**
   * CategoryProduct createMany
   */
  export type CategoryProductCreateManyArgs = {
    /**
     * The data used to create many CategoryProducts.
     * 
    **/
    data: Enumerable<CategoryProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CategoryProduct update
   */
  export type CategoryProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     * 
    **/
    select?: CategoryProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryProductInclude | null
    /**
     * The data needed to update a CategoryProduct.
     * 
    **/
    data: XOR<CategoryProductUpdateInput, CategoryProductUncheckedUpdateInput>
    /**
     * Choose, which CategoryProduct to update.
     * 
    **/
    where: CategoryProductWhereUniqueInput
  }


  /**
   * CategoryProduct updateMany
   */
  export type CategoryProductUpdateManyArgs = {
    /**
     * The data used to update CategoryProducts.
     * 
    **/
    data: XOR<CategoryProductUpdateManyMutationInput, CategoryProductUncheckedUpdateManyInput>
    /**
     * Filter which CategoryProducts to update
     * 
    **/
    where?: CategoryProductWhereInput
  }


  /**
   * CategoryProduct upsert
   */
  export type CategoryProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     * 
    **/
    select?: CategoryProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryProductInclude | null
    /**
     * The filter to search for the CategoryProduct to update in case it exists.
     * 
    **/
    where: CategoryProductWhereUniqueInput
    /**
     * In case the CategoryProduct found by the `where` argument doesn't exist, create a new CategoryProduct with this data.
     * 
    **/
    create: XOR<CategoryProductCreateInput, CategoryProductUncheckedCreateInput>
    /**
     * In case the CategoryProduct was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CategoryProductUpdateInput, CategoryProductUncheckedUpdateInput>
  }


  /**
   * CategoryProduct delete
   */
  export type CategoryProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     * 
    **/
    select?: CategoryProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryProductInclude | null
    /**
     * Filter which CategoryProduct to delete.
     * 
    **/
    where: CategoryProductWhereUniqueInput
  }


  /**
   * CategoryProduct deleteMany
   */
  export type CategoryProductDeleteManyArgs = {
    /**
     * Filter which CategoryProducts to delete
     * 
    **/
    where?: CategoryProductWhereInput
  }


  /**
   * CategoryProduct without action
   */
  export type CategoryProductArgs = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     * 
    **/
    select?: CategoryProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryProductInclude | null
  }



  /**
   * Model Photo
   */


  export type AggregatePhoto = {
    _count: PhotoCountAggregateOutputType | null
    _avg: PhotoAvgAggregateOutputType | null
    _sum: PhotoSumAggregateOutputType | null
    _min: PhotoMinAggregateOutputType | null
    _max: PhotoMaxAggregateOutputType | null
  }

  export type PhotoAvgAggregateOutputType = {
    priority: number | null
  }

  export type PhotoSumAggregateOutputType = {
    priority: number | null
  }

  export type PhotoMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    priority: number | null
    product_id: string | null
  }

  export type PhotoMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    priority: number | null
    product_id: string | null
  }

  export type PhotoCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    priority: number
    product_id: number
    _all: number
  }


  export type PhotoAvgAggregateInputType = {
    priority?: true
  }

  export type PhotoSumAggregateInputType = {
    priority?: true
  }

  export type PhotoMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    priority?: true
    product_id?: true
  }

  export type PhotoMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    priority?: true
    product_id?: true
  }

  export type PhotoCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    priority?: true
    product_id?: true
    _all?: true
  }

  export type PhotoAggregateArgs = {
    /**
     * Filter which Photo to aggregate.
     * 
    **/
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     * 
    **/
    orderBy?: Enumerable<PhotoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Photos
    **/
    _count?: true | PhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotoMaxAggregateInputType
  }

  export type GetPhotoAggregateType<T extends PhotoAggregateArgs> = {
        [P in keyof T & keyof AggregatePhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhoto[P]>
      : GetScalarType<T[P], AggregatePhoto[P]>
  }




  export type PhotoGroupByArgs = {
    where?: PhotoWhereInput
    orderBy?: Enumerable<PhotoOrderByWithAggregationInput>
    by: Array<PhotoScalarFieldEnum>
    having?: PhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotoCountAggregateInputType | true
    _avg?: PhotoAvgAggregateInputType
    _sum?: PhotoSumAggregateInputType
    _min?: PhotoMinAggregateInputType
    _max?: PhotoMaxAggregateInputType
  }


  export type PhotoGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    name: string
    priority: number
    product_id: string
    _count: PhotoCountAggregateOutputType | null
    _avg: PhotoAvgAggregateOutputType | null
    _sum: PhotoSumAggregateOutputType | null
    _min: PhotoMinAggregateOutputType | null
    _max: PhotoMaxAggregateOutputType | null
  }

  type GetPhotoGroupByPayload<T extends PhotoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotoGroupByOutputType[P]>
            : GetScalarType<T[P], PhotoGroupByOutputType[P]>
        }
      >
    >


  export type PhotoSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    priority?: boolean
    product_id?: boolean
    product?: boolean | ProductArgs
  }

  export type PhotoInclude = {
    product?: boolean | ProductArgs
  }

  export type PhotoGetPayload<
    S extends boolean | null | undefined | PhotoArgs,
    U = keyof S
      > = S extends true
        ? Photo
    : S extends undefined
    ? never
    : S extends PhotoArgs | PhotoFindManyArgs
    ?'include' extends U
    ? Photo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'product' ? ProductGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'product' ? ProductGetPayload<S['select'][P]> :  P extends keyof Photo ? Photo[P] : never
  } 
    : Photo
  : Photo


  type PhotoCountArgs = Merge<
    Omit<PhotoFindManyArgs, 'select' | 'include'> & {
      select?: PhotoCountAggregateInputType | true
    }
  >

  export interface PhotoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Photo that matches the filter.
     * @param {PhotoFindUniqueArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PhotoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PhotoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Photo'> extends True ? CheckSelect<T, Prisma__PhotoClient<Photo>, Prisma__PhotoClient<PhotoGetPayload<T>>> : CheckSelect<T, Prisma__PhotoClient<Photo | null >, Prisma__PhotoClient<PhotoGetPayload<T> | null >>

    /**
     * Find the first Photo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindFirstArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PhotoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PhotoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Photo'> extends True ? CheckSelect<T, Prisma__PhotoClient<Photo>, Prisma__PhotoClient<PhotoGetPayload<T>>> : CheckSelect<T, Prisma__PhotoClient<Photo | null >, Prisma__PhotoClient<PhotoGetPayload<T> | null >>

    /**
     * Find zero or more Photos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos
     * const photos = await prisma.photo.findMany()
     * 
     * // Get first 10 Photos
     * const photos = await prisma.photo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const photoWithIdOnly = await prisma.photo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PhotoFindManyArgs>(
      args?: SelectSubset<T, PhotoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Photo>>, PrismaPromise<Array<PhotoGetPayload<T>>>>

    /**
     * Create a Photo.
     * @param {PhotoCreateArgs} args - Arguments to create a Photo.
     * @example
     * // Create one Photo
     * const Photo = await prisma.photo.create({
     *   data: {
     *     // ... data to create a Photo
     *   }
     * })
     * 
    **/
    create<T extends PhotoCreateArgs>(
      args: SelectSubset<T, PhotoCreateArgs>
    ): CheckSelect<T, Prisma__PhotoClient<Photo>, Prisma__PhotoClient<PhotoGetPayload<T>>>

    /**
     * Create many Photos.
     *     @param {PhotoCreateManyArgs} args - Arguments to create many Photos.
     *     @example
     *     // Create many Photos
     *     const photo = await prisma.photo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PhotoCreateManyArgs>(
      args?: SelectSubset<T, PhotoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Photo.
     * @param {PhotoDeleteArgs} args - Arguments to delete one Photo.
     * @example
     * // Delete one Photo
     * const Photo = await prisma.photo.delete({
     *   where: {
     *     // ... filter to delete one Photo
     *   }
     * })
     * 
    **/
    delete<T extends PhotoDeleteArgs>(
      args: SelectSubset<T, PhotoDeleteArgs>
    ): CheckSelect<T, Prisma__PhotoClient<Photo>, Prisma__PhotoClient<PhotoGetPayload<T>>>

    /**
     * Update one Photo.
     * @param {PhotoUpdateArgs} args - Arguments to update one Photo.
     * @example
     * // Update one Photo
     * const photo = await prisma.photo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PhotoUpdateArgs>(
      args: SelectSubset<T, PhotoUpdateArgs>
    ): CheckSelect<T, Prisma__PhotoClient<Photo>, Prisma__PhotoClient<PhotoGetPayload<T>>>

    /**
     * Delete zero or more Photos.
     * @param {PhotoDeleteManyArgs} args - Arguments to filter Photos to delete.
     * @example
     * // Delete a few Photos
     * const { count } = await prisma.photo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PhotoDeleteManyArgs>(
      args?: SelectSubset<T, PhotoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos
     * const photo = await prisma.photo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PhotoUpdateManyArgs>(
      args: SelectSubset<T, PhotoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Photo.
     * @param {PhotoUpsertArgs} args - Arguments to update or create a Photo.
     * @example
     * // Update or create a Photo
     * const photo = await prisma.photo.upsert({
     *   create: {
     *     // ... data to create a Photo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photo we want to update
     *   }
     * })
    **/
    upsert<T extends PhotoUpsertArgs>(
      args: SelectSubset<T, PhotoUpsertArgs>
    ): CheckSelect<T, Prisma__PhotoClient<Photo>, Prisma__PhotoClient<PhotoGetPayload<T>>>

    /**
     * Count the number of Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoCountArgs} args - Arguments to filter Photos to count.
     * @example
     * // Count the number of Photos
     * const count = await prisma.photo.count({
     *   where: {
     *     // ... the filter for the Photos we want to count
     *   }
     * })
    **/
    count<T extends PhotoCountArgs>(
      args?: Subset<T, PhotoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotoAggregateArgs>(args: Subset<T, PhotoAggregateArgs>): PrismaPromise<GetPhotoAggregateType<T>>

    /**
     * Group by Photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhotoGroupByArgs['orderBy'] }
        : { orderBy?: PhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotoGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Photo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PhotoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Photo findUnique
   */
  export type PhotoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Photo
     * 
    **/
    select?: PhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhotoInclude | null
    /**
     * Throw an Error if a Photo can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Photo to fetch.
     * 
    **/
    where: PhotoWhereUniqueInput
  }


  /**
   * Photo findFirst
   */
  export type PhotoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Photo
     * 
    **/
    select?: PhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhotoInclude | null
    /**
     * Throw an Error if a Photo can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Photo to fetch.
     * 
    **/
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     * 
    **/
    orderBy?: Enumerable<PhotoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Photos.
     * 
    **/
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Photos.
     * 
    **/
    distinct?: Enumerable<PhotoScalarFieldEnum>
  }


  /**
   * Photo findMany
   */
  export type PhotoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Photo
     * 
    **/
    select?: PhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhotoInclude | null
    /**
     * Filter, which Photos to fetch.
     * 
    **/
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     * 
    **/
    orderBy?: Enumerable<PhotoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Photos.
     * 
    **/
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PhotoScalarFieldEnum>
  }


  /**
   * Photo create
   */
  export type PhotoCreateArgs = {
    /**
     * Select specific fields to fetch from the Photo
     * 
    **/
    select?: PhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhotoInclude | null
    /**
     * The data needed to create a Photo.
     * 
    **/
    data: XOR<PhotoCreateInput, PhotoUncheckedCreateInput>
  }


  /**
   * Photo createMany
   */
  export type PhotoCreateManyArgs = {
    /**
     * The data used to create many Photos.
     * 
    **/
    data: Enumerable<PhotoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Photo update
   */
  export type PhotoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Photo
     * 
    **/
    select?: PhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhotoInclude | null
    /**
     * The data needed to update a Photo.
     * 
    **/
    data: XOR<PhotoUpdateInput, PhotoUncheckedUpdateInput>
    /**
     * Choose, which Photo to update.
     * 
    **/
    where: PhotoWhereUniqueInput
  }


  /**
   * Photo updateMany
   */
  export type PhotoUpdateManyArgs = {
    /**
     * The data used to update Photos.
     * 
    **/
    data: XOR<PhotoUpdateManyMutationInput, PhotoUncheckedUpdateManyInput>
    /**
     * Filter which Photos to update
     * 
    **/
    where?: PhotoWhereInput
  }


  /**
   * Photo upsert
   */
  export type PhotoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Photo
     * 
    **/
    select?: PhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhotoInclude | null
    /**
     * The filter to search for the Photo to update in case it exists.
     * 
    **/
    where: PhotoWhereUniqueInput
    /**
     * In case the Photo found by the `where` argument doesn't exist, create a new Photo with this data.
     * 
    **/
    create: XOR<PhotoCreateInput, PhotoUncheckedCreateInput>
    /**
     * In case the Photo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PhotoUpdateInput, PhotoUncheckedUpdateInput>
  }


  /**
   * Photo delete
   */
  export type PhotoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Photo
     * 
    **/
    select?: PhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhotoInclude | null
    /**
     * Filter which Photo to delete.
     * 
    **/
    where: PhotoWhereUniqueInput
  }


  /**
   * Photo deleteMany
   */
  export type PhotoDeleteManyArgs = {
    /**
     * Filter which Photos to delete
     * 
    **/
    where?: PhotoWhereInput
  }


  /**
   * Photo without action
   */
  export type PhotoArgs = {
    /**
     * Select specific fields to fetch from the Photo
     * 
    **/
    select?: PhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhotoInclude | null
  }



  /**
   * Model Price
   */


  export type AggregatePrice = {
    _count: PriceCountAggregateOutputType | null
    _avg: PriceAvgAggregateOutputType | null
    _sum: PriceSumAggregateOutputType | null
    _min: PriceMinAggregateOutputType | null
    _max: PriceMaxAggregateOutputType | null
  }

  export type PriceAvgAggregateOutputType = {
    price: Decimal | null
    price_promotion: Decimal | null
  }

  export type PriceSumAggregateOutputType = {
    price: Decimal | null
    price_promotion: Decimal | null
  }

  export type PriceMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    price: Decimal | null
    price_promotion: Decimal | null
    product_id: string | null
    user_id: string | null
  }

  export type PriceMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    price: Decimal | null
    price_promotion: Decimal | null
    product_id: string | null
    user_id: string | null
  }

  export type PriceCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    price: number
    price_promotion: number
    product_id: number
    user_id: number
    _all: number
  }


  export type PriceAvgAggregateInputType = {
    price?: true
    price_promotion?: true
  }

  export type PriceSumAggregateInputType = {
    price?: true
    price_promotion?: true
  }

  export type PriceMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    price?: true
    price_promotion?: true
    product_id?: true
    user_id?: true
  }

  export type PriceMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    price?: true
    price_promotion?: true
    product_id?: true
    user_id?: true
  }

  export type PriceCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    price?: true
    price_promotion?: true
    product_id?: true
    user_id?: true
    _all?: true
  }

  export type PriceAggregateArgs = {
    /**
     * Filter which Price to aggregate.
     * 
    **/
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     * 
    **/
    orderBy?: Enumerable<PriceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prices
    **/
    _count?: true | PriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceMaxAggregateInputType
  }

  export type GetPriceAggregateType<T extends PriceAggregateArgs> = {
        [P in keyof T & keyof AggregatePrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrice[P]>
      : GetScalarType<T[P], AggregatePrice[P]>
  }




  export type PriceGroupByArgs = {
    where?: PriceWhereInput
    orderBy?: Enumerable<PriceOrderByWithAggregationInput>
    by: Array<PriceScalarFieldEnum>
    having?: PriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceCountAggregateInputType | true
    _avg?: PriceAvgAggregateInputType
    _sum?: PriceSumAggregateInputType
    _min?: PriceMinAggregateInputType
    _max?: PriceMaxAggregateInputType
  }


  export type PriceGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    price: Decimal
    price_promotion: Decimal
    product_id: string
    user_id: string
    _count: PriceCountAggregateOutputType | null
    _avg: PriceAvgAggregateOutputType | null
    _sum: PriceSumAggregateOutputType | null
    _min: PriceMinAggregateOutputType | null
    _max: PriceMaxAggregateOutputType | null
  }

  type GetPriceGroupByPayload<T extends PriceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceGroupByOutputType[P]>
            : GetScalarType<T[P], PriceGroupByOutputType[P]>
        }
      >
    >


  export type PriceSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    price?: boolean
    price_promotion?: boolean
    product_id?: boolean
    product?: boolean | ProductArgs
    actualProduct?: boolean | ProductFindManyArgs
    user_id?: boolean
    user?: boolean | UserArgs
    OrderProduct?: boolean | OrderProductFindManyArgs
    _count?: boolean | PriceCountOutputTypeArgs
  }

  export type PriceInclude = {
    product?: boolean | ProductArgs
    actualProduct?: boolean | ProductFindManyArgs
    user?: boolean | UserArgs
    OrderProduct?: boolean | OrderProductFindManyArgs
    _count?: boolean | PriceCountOutputTypeArgs
  }

  export type PriceGetPayload<
    S extends boolean | null | undefined | PriceArgs,
    U = keyof S
      > = S extends true
        ? Price
    : S extends undefined
    ? never
    : S extends PriceArgs | PriceFindManyArgs
    ?'include' extends U
    ? Price  & {
    [P in TrueKeys<S['include']>]:
        P extends 'product' ? ProductGetPayload<S['include'][P]> :
        P extends 'actualProduct' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'OrderProduct' ? Array < OrderProductGetPayload<S['include'][P]>>  :
        P extends '_count' ? PriceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'product' ? ProductGetPayload<S['select'][P]> :
        P extends 'actualProduct' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'OrderProduct' ? Array < OrderProductGetPayload<S['select'][P]>>  :
        P extends '_count' ? PriceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Price ? Price[P] : never
  } 
    : Price
  : Price


  type PriceCountArgs = Merge<
    Omit<PriceFindManyArgs, 'select' | 'include'> & {
      select?: PriceCountAggregateInputType | true
    }
  >

  export interface PriceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Price that matches the filter.
     * @param {PriceFindUniqueArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PriceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PriceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Price'> extends True ? CheckSelect<T, Prisma__PriceClient<Price>, Prisma__PriceClient<PriceGetPayload<T>>> : CheckSelect<T, Prisma__PriceClient<Price | null >, Prisma__PriceClient<PriceGetPayload<T> | null >>

    /**
     * Find the first Price that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindFirstArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PriceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PriceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Price'> extends True ? CheckSelect<T, Prisma__PriceClient<Price>, Prisma__PriceClient<PriceGetPayload<T>>> : CheckSelect<T, Prisma__PriceClient<Price | null >, Prisma__PriceClient<PriceGetPayload<T> | null >>

    /**
     * Find zero or more Prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prices
     * const prices = await prisma.price.findMany()
     * 
     * // Get first 10 Prices
     * const prices = await prisma.price.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceWithIdOnly = await prisma.price.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PriceFindManyArgs>(
      args?: SelectSubset<T, PriceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Price>>, PrismaPromise<Array<PriceGetPayload<T>>>>

    /**
     * Create a Price.
     * @param {PriceCreateArgs} args - Arguments to create a Price.
     * @example
     * // Create one Price
     * const Price = await prisma.price.create({
     *   data: {
     *     // ... data to create a Price
     *   }
     * })
     * 
    **/
    create<T extends PriceCreateArgs>(
      args: SelectSubset<T, PriceCreateArgs>
    ): CheckSelect<T, Prisma__PriceClient<Price>, Prisma__PriceClient<PriceGetPayload<T>>>

    /**
     * Create many Prices.
     *     @param {PriceCreateManyArgs} args - Arguments to create many Prices.
     *     @example
     *     // Create many Prices
     *     const price = await prisma.price.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PriceCreateManyArgs>(
      args?: SelectSubset<T, PriceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Price.
     * @param {PriceDeleteArgs} args - Arguments to delete one Price.
     * @example
     * // Delete one Price
     * const Price = await prisma.price.delete({
     *   where: {
     *     // ... filter to delete one Price
     *   }
     * })
     * 
    **/
    delete<T extends PriceDeleteArgs>(
      args: SelectSubset<T, PriceDeleteArgs>
    ): CheckSelect<T, Prisma__PriceClient<Price>, Prisma__PriceClient<PriceGetPayload<T>>>

    /**
     * Update one Price.
     * @param {PriceUpdateArgs} args - Arguments to update one Price.
     * @example
     * // Update one Price
     * const price = await prisma.price.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PriceUpdateArgs>(
      args: SelectSubset<T, PriceUpdateArgs>
    ): CheckSelect<T, Prisma__PriceClient<Price>, Prisma__PriceClient<PriceGetPayload<T>>>

    /**
     * Delete zero or more Prices.
     * @param {PriceDeleteManyArgs} args - Arguments to filter Prices to delete.
     * @example
     * // Delete a few Prices
     * const { count } = await prisma.price.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PriceDeleteManyArgs>(
      args?: SelectSubset<T, PriceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prices
     * const price = await prisma.price.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PriceUpdateManyArgs>(
      args: SelectSubset<T, PriceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Price.
     * @param {PriceUpsertArgs} args - Arguments to update or create a Price.
     * @example
     * // Update or create a Price
     * const price = await prisma.price.upsert({
     *   create: {
     *     // ... data to create a Price
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Price we want to update
     *   }
     * })
    **/
    upsert<T extends PriceUpsertArgs>(
      args: SelectSubset<T, PriceUpsertArgs>
    ): CheckSelect<T, Prisma__PriceClient<Price>, Prisma__PriceClient<PriceGetPayload<T>>>

    /**
     * Count the number of Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceCountArgs} args - Arguments to filter Prices to count.
     * @example
     * // Count the number of Prices
     * const count = await prisma.price.count({
     *   where: {
     *     // ... the filter for the Prices we want to count
     *   }
     * })
    **/
    count<T extends PriceCountArgs>(
      args?: Subset<T, PriceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceAggregateArgs>(args: Subset<T, PriceAggregateArgs>): PrismaPromise<GetPriceAggregateType<T>>

    /**
     * Group by Price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceGroupByArgs['orderBy'] }
        : { orderBy?: PriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Price.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PriceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    actualProduct<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    OrderProduct<T extends OrderProductFindManyArgs = {}>(args?: Subset<T, OrderProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderProduct>>, PrismaPromise<Array<OrderProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Price findUnique
   */
  export type PriceFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
    /**
     * Throw an Error if a Price can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Price to fetch.
     * 
    **/
    where: PriceWhereUniqueInput
  }


  /**
   * Price findFirst
   */
  export type PriceFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
    /**
     * Throw an Error if a Price can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Price to fetch.
     * 
    **/
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     * 
    **/
    orderBy?: Enumerable<PriceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     * 
    **/
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     * 
    **/
    distinct?: Enumerable<PriceScalarFieldEnum>
  }


  /**
   * Price findMany
   */
  export type PriceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
    /**
     * Filter, which Prices to fetch.
     * 
    **/
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     * 
    **/
    orderBy?: Enumerable<PriceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prices.
     * 
    **/
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PriceScalarFieldEnum>
  }


  /**
   * Price create
   */
  export type PriceCreateArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
    /**
     * The data needed to create a Price.
     * 
    **/
    data: XOR<PriceCreateInput, PriceUncheckedCreateInput>
  }


  /**
   * Price createMany
   */
  export type PriceCreateManyArgs = {
    /**
     * The data used to create many Prices.
     * 
    **/
    data: Enumerable<PriceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Price update
   */
  export type PriceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
    /**
     * The data needed to update a Price.
     * 
    **/
    data: XOR<PriceUpdateInput, PriceUncheckedUpdateInput>
    /**
     * Choose, which Price to update.
     * 
    **/
    where: PriceWhereUniqueInput
  }


  /**
   * Price updateMany
   */
  export type PriceUpdateManyArgs = {
    /**
     * The data used to update Prices.
     * 
    **/
    data: XOR<PriceUpdateManyMutationInput, PriceUncheckedUpdateManyInput>
    /**
     * Filter which Prices to update
     * 
    **/
    where?: PriceWhereInput
  }


  /**
   * Price upsert
   */
  export type PriceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
    /**
     * The filter to search for the Price to update in case it exists.
     * 
    **/
    where: PriceWhereUniqueInput
    /**
     * In case the Price found by the `where` argument doesn't exist, create a new Price with this data.
     * 
    **/
    create: XOR<PriceCreateInput, PriceUncheckedCreateInput>
    /**
     * In case the Price was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PriceUpdateInput, PriceUncheckedUpdateInput>
  }


  /**
   * Price delete
   */
  export type PriceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
    /**
     * Filter which Price to delete.
     * 
    **/
    where: PriceWhereUniqueInput
  }


  /**
   * Price deleteMany
   */
  export type PriceDeleteManyArgs = {
    /**
     * Filter which Prices to delete
     * 
    **/
    where?: PriceWhereInput
  }


  /**
   * Price without action
   */
  export type PriceArgs = {
    /**
     * Select specific fields to fetch from the Price
     * 
    **/
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceInclude | null
  }



  /**
   * Model Video
   */


  export type AggregateVideo = {
    _count: VideoCountAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  export type VideoMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    slug: string | null
    product_id: string | null
  }

  export type VideoMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    slug: string | null
    product_id: string | null
  }

  export type VideoCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    slug: number
    product_id: number
    _all: number
  }


  export type VideoMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    slug?: true
    product_id?: true
  }

  export type VideoMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    slug?: true
    product_id?: true
  }

  export type VideoCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    slug?: true
    product_id?: true
    _all?: true
  }

  export type VideoAggregateArgs = {
    /**
     * Filter which Video to aggregate.
     * 
    **/
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     * 
    **/
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    _count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }




  export type VideoGroupByArgs = {
    where?: VideoWhereInput
    orderBy?: Enumerable<VideoOrderByWithAggregationInput>
    by: Array<VideoScalarFieldEnum>
    having?: VideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCountAggregateInputType | true
    _min?: VideoMinAggregateInputType
    _max?: VideoMaxAggregateInputType
  }


  export type VideoGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    name: string
    slug: string
    product_id: string
    _count: VideoCountAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends VideoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGroupByOutputType[P]>
        }
      >
    >


  export type VideoSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    slug?: boolean
    product_id?: boolean
    product?: boolean | ProductArgs
  }

  export type VideoInclude = {
    product?: boolean | ProductArgs
  }

  export type VideoGetPayload<
    S extends boolean | null | undefined | VideoArgs,
    U = keyof S
      > = S extends true
        ? Video
    : S extends undefined
    ? never
    : S extends VideoArgs | VideoFindManyArgs
    ?'include' extends U
    ? Video  & {
    [P in TrueKeys<S['include']>]:
        P extends 'product' ? ProductGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'product' ? ProductGetPayload<S['select'][P]> :  P extends keyof Video ? Video[P] : never
  } 
    : Video
  : Video


  type VideoCountArgs = Merge<
    Omit<VideoFindManyArgs, 'select' | 'include'> & {
      select?: VideoCountAggregateInputType | true
    }
  >

  export interface VideoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Video that matches the filter.
     * @param {VideoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VideoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VideoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Video'> extends True ? CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>> : CheckSelect<T, Prisma__VideoClient<Video | null >, Prisma__VideoClient<VideoGetPayload<T> | null >>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VideoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VideoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Video'> extends True ? CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>> : CheckSelect<T, Prisma__VideoClient<Video | null >, Prisma__VideoClient<VideoGetPayload<T> | null >>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoWithIdOnly = await prisma.video.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VideoFindManyArgs>(
      args?: SelectSubset<T, VideoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Video>>, PrismaPromise<Array<VideoGetPayload<T>>>>

    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
    **/
    create<T extends VideoCreateArgs>(
      args: SelectSubset<T, VideoCreateArgs>
    ): CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>>

    /**
     * Create many Videos.
     *     @param {VideoCreateManyArgs} args - Arguments to create many Videos.
     *     @example
     *     // Create many Videos
     *     const video = await prisma.video.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VideoCreateManyArgs>(
      args?: SelectSubset<T, VideoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
    **/
    delete<T extends VideoDeleteArgs>(
      args: SelectSubset<T, VideoDeleteArgs>
    ): CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>>

    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VideoUpdateArgs>(
      args: SelectSubset<T, VideoUpdateArgs>
    ): CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>>

    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VideoDeleteManyArgs>(
      args?: SelectSubset<T, VideoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VideoUpdateManyArgs>(
      args: SelectSubset<T, VideoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
    **/
    upsert<T extends VideoUpsertArgs>(
      args: SelectSubset<T, VideoUpsertArgs>
    ): CheckSelect<T, Prisma__VideoClient<Video>, Prisma__VideoClient<VideoGetPayload<T>>>

    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideoCountArgs>(
      args?: Subset<T, VideoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGroupByArgs['orderBy'] }
        : { orderBy?: VideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VideoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Video findUnique
   */
  export type VideoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Video
     * 
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VideoInclude | null
    /**
     * Throw an Error if a Video can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Video to fetch.
     * 
    **/
    where: VideoWhereUniqueInput
  }


  /**
   * Video findFirst
   */
  export type VideoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Video
     * 
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VideoInclude | null
    /**
     * Throw an Error if a Video can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Video to fetch.
     * 
    **/
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     * 
    **/
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     * 
    **/
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     * 
    **/
    distinct?: Enumerable<VideoScalarFieldEnum>
  }


  /**
   * Video findMany
   */
  export type VideoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Video
     * 
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VideoInclude | null
    /**
     * Filter, which Videos to fetch.
     * 
    **/
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     * 
    **/
    orderBy?: Enumerable<VideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
     * 
    **/
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VideoScalarFieldEnum>
  }


  /**
   * Video create
   */
  export type VideoCreateArgs = {
    /**
     * Select specific fields to fetch from the Video
     * 
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VideoInclude | null
    /**
     * The data needed to create a Video.
     * 
    **/
    data: XOR<VideoCreateInput, VideoUncheckedCreateInput>
  }


  /**
   * Video createMany
   */
  export type VideoCreateManyArgs = {
    /**
     * The data used to create many Videos.
     * 
    **/
    data: Enumerable<VideoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Video update
   */
  export type VideoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Video
     * 
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VideoInclude | null
    /**
     * The data needed to update a Video.
     * 
    **/
    data: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
    /**
     * Choose, which Video to update.
     * 
    **/
    where: VideoWhereUniqueInput
  }


  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs = {
    /**
     * The data used to update Videos.
     * 
    **/
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     * 
    **/
    where?: VideoWhereInput
  }


  /**
   * Video upsert
   */
  export type VideoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Video
     * 
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VideoInclude | null
    /**
     * The filter to search for the Video to update in case it exists.
     * 
    **/
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
     * 
    **/
    create: XOR<VideoCreateInput, VideoUncheckedCreateInput>
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
  }


  /**
   * Video delete
   */
  export type VideoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Video
     * 
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VideoInclude | null
    /**
     * Filter which Video to delete.
     * 
    **/
    where: VideoWhereUniqueInput
  }


  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs = {
    /**
     * Filter which Videos to delete
     * 
    **/
    where?: VideoWhereInput
  }


  /**
   * Video without action
   */
  export type VideoArgs = {
    /**
     * Select specific fields to fetch from the Video
     * 
    **/
    select?: VideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VideoInclude | null
  }



  /**
   * Model Review
   */


  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    comment: string | null
    status: ReviewsStatusEnum | null
    product_id: string | null
    author_id: string | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    comment: string | null
    status: ReviewsStatusEnum | null
    product_id: string | null
    author_id: string | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    comment: number
    status: number
    product_id: number
    author_id: number
    _all: number
  }


  export type ReviewMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    comment?: true
    status?: true
    product_id?: true
    author_id?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    comment?: true
    status?: true
    product_id?: true
    author_id?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    comment?: true
    status?: true
    product_id?: true
    author_id?: true
    _all?: true
  }

  export type ReviewAggregateArgs = {
    /**
     * Filter which Review to aggregate.
     * 
    **/
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<ReviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs = {
    where?: ReviewWhereInput
    orderBy?: Enumerable<ReviewOrderByWithAggregationInput>
    by: Array<ReviewScalarFieldEnum>
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }


  export type ReviewGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    comment: string
    status: ReviewsStatusEnum
    product_id: string
    author_id: string | null
    _count: ReviewCountAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    comment?: boolean
    status?: boolean
    product_id?: boolean
    product?: boolean | ProductArgs
    author?: boolean | UserArgs
    author_id?: boolean
  }

  export type ReviewInclude = {
    product?: boolean | ProductArgs
    author?: boolean | UserArgs
  }

  export type ReviewGetPayload<
    S extends boolean | null | undefined | ReviewArgs,
    U = keyof S
      > = S extends true
        ? Review
    : S extends undefined
    ? never
    : S extends ReviewArgs | ReviewFindManyArgs
    ?'include' extends U
    ? Review  & {
    [P in TrueKeys<S['include']>]:
        P extends 'product' ? ProductGetPayload<S['include'][P]> :
        P extends 'author' ? UserGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'product' ? ProductGetPayload<S['select'][P]> :
        P extends 'author' ? UserGetPayload<S['select'][P]> | null :  P extends keyof Review ? Review[P] : never
  } 
    : Review
  : Review


  type ReviewCountArgs = Merge<
    Omit<ReviewFindManyArgs, 'select' | 'include'> & {
      select?: ReviewCountAggregateInputType | true
    }
  >

  export interface ReviewDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Review'> extends True ? CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>> : CheckSelect<T, Prisma__ReviewClient<Review | null >, Prisma__ReviewClient<ReviewGetPayload<T> | null >>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Review'> extends True ? CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>> : CheckSelect<T, Prisma__ReviewClient<Review | null >, Prisma__ReviewClient<ReviewGetPayload<T> | null >>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReviewFindManyArgs>(
      args?: SelectSubset<T, ReviewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Review>>, PrismaPromise<Array<ReviewGetPayload<T>>>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
    **/
    create<T extends ReviewCreateArgs>(
      args: SelectSubset<T, ReviewCreateArgs>
    ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>

    /**
     * Create many Reviews.
     *     @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     *     @example
     *     // Create many Reviews
     *     const review = await prisma.review.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReviewCreateManyArgs>(
      args?: SelectSubset<T, ReviewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
    **/
    delete<T extends ReviewDeleteArgs>(
      args: SelectSubset<T, ReviewDeleteArgs>
    ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReviewUpdateArgs>(
      args: SelectSubset<T, ReviewUpdateArgs>
    ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReviewDeleteManyArgs>(
      args?: SelectSubset<T, ReviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReviewUpdateManyArgs>(
      args: SelectSubset<T, ReviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
    **/
    upsert<T extends ReviewUpsertArgs>(
      args: SelectSubset<T, ReviewUpsertArgs>
    ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReviewClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
    /**
     * Throw an Error if a Review can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Review to fetch.
     * 
    **/
    where: ReviewWhereUniqueInput
  }


  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
    /**
     * Throw an Error if a Review can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Review to fetch.
     * 
    **/
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<ReviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     * 
    **/
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     * 
    **/
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * Review findMany
   */
  export type ReviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
    /**
     * Filter, which Reviews to fetch.
     * 
    **/
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<ReviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     * 
    **/
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * Review create
   */
  export type ReviewCreateArgs = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
    /**
     * The data needed to create a Review.
     * 
    **/
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }


  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs = {
    /**
     * The data used to create many Reviews.
     * 
    **/
    data: Enumerable<ReviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Review update
   */
  export type ReviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
    /**
     * The data needed to update a Review.
     * 
    **/
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     * 
    **/
    where: ReviewWhereUniqueInput
  }


  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs = {
    /**
     * The data used to update Reviews.
     * 
    **/
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     * 
    **/
    where?: ReviewWhereInput
  }


  /**
   * Review upsert
   */
  export type ReviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
    /**
     * The filter to search for the Review to update in case it exists.
     * 
    **/
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     * 
    **/
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }


  /**
   * Review delete
   */
  export type ReviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
    /**
     * Filter which Review to delete.
     * 
    **/
    where: ReviewWhereUniqueInput
  }


  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs = {
    /**
     * Filter which Reviews to delete
     * 
    **/
    where?: ReviewWhereInput
  }


  /**
   * Review without action
   */
  export type ReviewArgs = {
    /**
     * Select specific fields to fetch from the Review
     * 
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReviewInclude | null
  }



  /**
   * Model Comment
   */


  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    text: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    text: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    text: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    text?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    text?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    text?: true
    _all?: true
  }

  export type CommentAggregateArgs = {
    /**
     * Filter which Comment to aggregate.
     * 
    **/
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     * 
    **/
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs = {
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithAggregationInput>
    by: Array<CommentScalarFieldEnum>
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }


  export type CommentGroupByOutputType = {
    id: string
    text: string
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect = {
    id?: boolean
    text?: boolean
  }

  export type CommentGetPayload<
    S extends boolean | null | undefined | CommentArgs,
    U = keyof S
      > = S extends true
        ? Comment
    : S extends undefined
    ? never
    : S extends CommentArgs | CommentFindManyArgs
    ?'include' extends U
    ? Comment 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Comment ? Comment[P] : never
  } 
    : Comment
  : Comment


  type CommentCountArgs = Merge<
    Omit<CommentFindManyArgs, 'select' | 'include'> & {
      select?: CommentCountAggregateInputType | true
    }
  >

  export interface CommentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Comment'> extends True ? CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>> : CheckSelect<T, Prisma__CommentClient<Comment | null >, Prisma__CommentClient<CommentGetPayload<T> | null >>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Comment'> extends True ? CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>> : CheckSelect<T, Prisma__CommentClient<Comment | null >, Prisma__CommentClient<CommentGetPayload<T> | null >>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs>(
      args?: SelectSubset<T, CommentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Comment>>, PrismaPromise<Array<CommentGetPayload<T>>>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs>(
      args: SelectSubset<T, CommentCreateArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs>(
      args?: SelectSubset<T, CommentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs>(
      args: SelectSubset<T, CommentDeleteArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs>(
      args: SelectSubset<T, CommentUpdateArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs>(
      args?: SelectSubset<T, CommentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs>(
      args: SelectSubset<T, CommentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs>(
      args: SelectSubset<T, CommentUpsertArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * Throw an Error if a Comment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Comment to fetch.
     * 
    **/
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * Throw an Error if a Comment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Comment to fetch.
     * 
    **/
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     * 
    **/
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     * 
    **/
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     * 
    **/
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * Filter, which Comments to fetch.
     * 
    **/
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     * 
    **/
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     * 
    **/
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * The data needed to create a Comment.
     * 
    **/
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs = {
    /**
     * The data used to create many Comments.
     * 
    **/
    data: Enumerable<CommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * The data needed to update a Comment.
     * 
    **/
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     * 
    **/
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs = {
    /**
     * The data used to update Comments.
     * 
    **/
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     * 
    **/
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * The filter to search for the Comment to update in case it exists.
     * 
    **/
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     * 
    **/
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * Filter which Comment to delete.
     * 
    **/
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs = {
    /**
     * Filter which Comments to delete
     * 
    **/
    where?: CommentWhereInput
  }


  /**
   * Comment without action
   */
  export type CommentArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
  }



  /**
   * Model Description
   */


  export type AggregateDescription = {
    _count: DescriptionCountAggregateOutputType | null
    _min: DescriptionMinAggregateOutputType | null
    _max: DescriptionMaxAggregateOutputType | null
  }

  export type DescriptionMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    description: string | null
  }

  export type DescriptionMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    description: string | null
  }

  export type DescriptionCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    description: number
    _all: number
  }


  export type DescriptionMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    description?: true
  }

  export type DescriptionMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    description?: true
  }

  export type DescriptionCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    description?: true
    _all?: true
  }

  export type DescriptionAggregateArgs = {
    /**
     * Filter which Description to aggregate.
     * 
    **/
    where?: DescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Descriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<DescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Descriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Descriptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Descriptions
    **/
    _count?: true | DescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DescriptionMaxAggregateInputType
  }

  export type GetDescriptionAggregateType<T extends DescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateDescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDescription[P]>
      : GetScalarType<T[P], AggregateDescription[P]>
  }




  export type DescriptionGroupByArgs = {
    where?: DescriptionWhereInput
    orderBy?: Enumerable<DescriptionOrderByWithAggregationInput>
    by: Array<DescriptionScalarFieldEnum>
    having?: DescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DescriptionCountAggregateInputType | true
    _min?: DescriptionMinAggregateInputType
    _max?: DescriptionMaxAggregateInputType
  }


  export type DescriptionGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    description: string
    _count: DescriptionCountAggregateOutputType | null
    _min: DescriptionMinAggregateOutputType | null
    _max: DescriptionMaxAggregateOutputType | null
  }

  type GetDescriptionGroupByPayload<T extends DescriptionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], DescriptionGroupByOutputType[P]>
        }
      >
    >


  export type DescriptionSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    description?: boolean
    products?: boolean | ProductFindManyArgs
    _count?: boolean | DescriptionCountOutputTypeArgs
  }

  export type DescriptionInclude = {
    products?: boolean | ProductFindManyArgs
    _count?: boolean | DescriptionCountOutputTypeArgs
  }

  export type DescriptionGetPayload<
    S extends boolean | null | undefined | DescriptionArgs,
    U = keyof S
      > = S extends true
        ? Description
    : S extends undefined
    ? never
    : S extends DescriptionArgs | DescriptionFindManyArgs
    ?'include' extends U
    ? Description  & {
    [P in TrueKeys<S['include']>]:
        P extends 'products' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends '_count' ? DescriptionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'products' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends '_count' ? DescriptionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Description ? Description[P] : never
  } 
    : Description
  : Description


  type DescriptionCountArgs = Merge<
    Omit<DescriptionFindManyArgs, 'select' | 'include'> & {
      select?: DescriptionCountAggregateInputType | true
    }
  >

  export interface DescriptionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Description that matches the filter.
     * @param {DescriptionFindUniqueArgs} args - Arguments to find a Description
     * @example
     * // Get one Description
     * const description = await prisma.description.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DescriptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DescriptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Description'> extends True ? CheckSelect<T, Prisma__DescriptionClient<Description>, Prisma__DescriptionClient<DescriptionGetPayload<T>>> : CheckSelect<T, Prisma__DescriptionClient<Description | null >, Prisma__DescriptionClient<DescriptionGetPayload<T> | null >>

    /**
     * Find the first Description that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescriptionFindFirstArgs} args - Arguments to find a Description
     * @example
     * // Get one Description
     * const description = await prisma.description.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DescriptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DescriptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Description'> extends True ? CheckSelect<T, Prisma__DescriptionClient<Description>, Prisma__DescriptionClient<DescriptionGetPayload<T>>> : CheckSelect<T, Prisma__DescriptionClient<Description | null >, Prisma__DescriptionClient<DescriptionGetPayload<T> | null >>

    /**
     * Find zero or more Descriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Descriptions
     * const descriptions = await prisma.description.findMany()
     * 
     * // Get first 10 Descriptions
     * const descriptions = await prisma.description.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const descriptionWithIdOnly = await prisma.description.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DescriptionFindManyArgs>(
      args?: SelectSubset<T, DescriptionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Description>>, PrismaPromise<Array<DescriptionGetPayload<T>>>>

    /**
     * Create a Description.
     * @param {DescriptionCreateArgs} args - Arguments to create a Description.
     * @example
     * // Create one Description
     * const Description = await prisma.description.create({
     *   data: {
     *     // ... data to create a Description
     *   }
     * })
     * 
    **/
    create<T extends DescriptionCreateArgs>(
      args: SelectSubset<T, DescriptionCreateArgs>
    ): CheckSelect<T, Prisma__DescriptionClient<Description>, Prisma__DescriptionClient<DescriptionGetPayload<T>>>

    /**
     * Create many Descriptions.
     *     @param {DescriptionCreateManyArgs} args - Arguments to create many Descriptions.
     *     @example
     *     // Create many Descriptions
     *     const description = await prisma.description.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DescriptionCreateManyArgs>(
      args?: SelectSubset<T, DescriptionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Description.
     * @param {DescriptionDeleteArgs} args - Arguments to delete one Description.
     * @example
     * // Delete one Description
     * const Description = await prisma.description.delete({
     *   where: {
     *     // ... filter to delete one Description
     *   }
     * })
     * 
    **/
    delete<T extends DescriptionDeleteArgs>(
      args: SelectSubset<T, DescriptionDeleteArgs>
    ): CheckSelect<T, Prisma__DescriptionClient<Description>, Prisma__DescriptionClient<DescriptionGetPayload<T>>>

    /**
     * Update one Description.
     * @param {DescriptionUpdateArgs} args - Arguments to update one Description.
     * @example
     * // Update one Description
     * const description = await prisma.description.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DescriptionUpdateArgs>(
      args: SelectSubset<T, DescriptionUpdateArgs>
    ): CheckSelect<T, Prisma__DescriptionClient<Description>, Prisma__DescriptionClient<DescriptionGetPayload<T>>>

    /**
     * Delete zero or more Descriptions.
     * @param {DescriptionDeleteManyArgs} args - Arguments to filter Descriptions to delete.
     * @example
     * // Delete a few Descriptions
     * const { count } = await prisma.description.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DescriptionDeleteManyArgs>(
      args?: SelectSubset<T, DescriptionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Descriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Descriptions
     * const description = await prisma.description.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DescriptionUpdateManyArgs>(
      args: SelectSubset<T, DescriptionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Description.
     * @param {DescriptionUpsertArgs} args - Arguments to update or create a Description.
     * @example
     * // Update or create a Description
     * const description = await prisma.description.upsert({
     *   create: {
     *     // ... data to create a Description
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Description we want to update
     *   }
     * })
    **/
    upsert<T extends DescriptionUpsertArgs>(
      args: SelectSubset<T, DescriptionUpsertArgs>
    ): CheckSelect<T, Prisma__DescriptionClient<Description>, Prisma__DescriptionClient<DescriptionGetPayload<T>>>

    /**
     * Count the number of Descriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescriptionCountArgs} args - Arguments to filter Descriptions to count.
     * @example
     * // Count the number of Descriptions
     * const count = await prisma.description.count({
     *   where: {
     *     // ... the filter for the Descriptions we want to count
     *   }
     * })
    **/
    count<T extends DescriptionCountArgs>(
      args?: Subset<T, DescriptionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Description.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DescriptionAggregateArgs>(args: Subset<T, DescriptionAggregateArgs>): PrismaPromise<GetDescriptionAggregateType<T>>

    /**
     * Group by Description.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DescriptionGroupByArgs['orderBy'] }
        : { orderBy?: DescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDescriptionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Description.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DescriptionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Description findUnique
   */
  export type DescriptionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Description
     * 
    **/
    select?: DescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DescriptionInclude | null
    /**
     * Throw an Error if a Description can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Description to fetch.
     * 
    **/
    where: DescriptionWhereUniqueInput
  }


  /**
   * Description findFirst
   */
  export type DescriptionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Description
     * 
    **/
    select?: DescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DescriptionInclude | null
    /**
     * Throw an Error if a Description can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Description to fetch.
     * 
    **/
    where?: DescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Descriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<DescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Descriptions.
     * 
    **/
    cursor?: DescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Descriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Descriptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Descriptions.
     * 
    **/
    distinct?: Enumerable<DescriptionScalarFieldEnum>
  }


  /**
   * Description findMany
   */
  export type DescriptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Description
     * 
    **/
    select?: DescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DescriptionInclude | null
    /**
     * Filter, which Descriptions to fetch.
     * 
    **/
    where?: DescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Descriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<DescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Descriptions.
     * 
    **/
    cursor?: DescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Descriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Descriptions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DescriptionScalarFieldEnum>
  }


  /**
   * Description create
   */
  export type DescriptionCreateArgs = {
    /**
     * Select specific fields to fetch from the Description
     * 
    **/
    select?: DescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DescriptionInclude | null
    /**
     * The data needed to create a Description.
     * 
    **/
    data: XOR<DescriptionCreateInput, DescriptionUncheckedCreateInput>
  }


  /**
   * Description createMany
   */
  export type DescriptionCreateManyArgs = {
    /**
     * The data used to create many Descriptions.
     * 
    **/
    data: Enumerable<DescriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Description update
   */
  export type DescriptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Description
     * 
    **/
    select?: DescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DescriptionInclude | null
    /**
     * The data needed to update a Description.
     * 
    **/
    data: XOR<DescriptionUpdateInput, DescriptionUncheckedUpdateInput>
    /**
     * Choose, which Description to update.
     * 
    **/
    where: DescriptionWhereUniqueInput
  }


  /**
   * Description updateMany
   */
  export type DescriptionUpdateManyArgs = {
    /**
     * The data used to update Descriptions.
     * 
    **/
    data: XOR<DescriptionUpdateManyMutationInput, DescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Descriptions to update
     * 
    **/
    where?: DescriptionWhereInput
  }


  /**
   * Description upsert
   */
  export type DescriptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Description
     * 
    **/
    select?: DescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DescriptionInclude | null
    /**
     * The filter to search for the Description to update in case it exists.
     * 
    **/
    where: DescriptionWhereUniqueInput
    /**
     * In case the Description found by the `where` argument doesn't exist, create a new Description with this data.
     * 
    **/
    create: XOR<DescriptionCreateInput, DescriptionUncheckedCreateInput>
    /**
     * In case the Description was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DescriptionUpdateInput, DescriptionUncheckedUpdateInput>
  }


  /**
   * Description delete
   */
  export type DescriptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Description
     * 
    **/
    select?: DescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DescriptionInclude | null
    /**
     * Filter which Description to delete.
     * 
    **/
    where: DescriptionWhereUniqueInput
  }


  /**
   * Description deleteMany
   */
  export type DescriptionDeleteManyArgs = {
    /**
     * Filter which Descriptions to delete
     * 
    **/
    where?: DescriptionWhereInput
  }


  /**
   * Description without action
   */
  export type DescriptionArgs = {
    /**
     * Select specific fields to fetch from the Description
     * 
    **/
    select?: DescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DescriptionInclude | null
  }



  /**
   * Model Banner
   */


  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  export type BannerAvgAggregateOutputType = {
    priority: number | null
  }

  export type BannerSumAggregateOutputType = {
    priority: number | null
  }

  export type BannerMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    type: string | null
    status: boolean | null
    priority: number | null
  }

  export type BannerMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    name: string | null
    type: string | null
    status: boolean | null
    priority: number | null
  }

  export type BannerCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    name: number
    type: number
    status: number
    priority: number
    _all: number
  }


  export type BannerAvgAggregateInputType = {
    priority?: true
  }

  export type BannerSumAggregateInputType = {
    priority?: true
  }

  export type BannerMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    type?: true
    status?: true
    priority?: true
  }

  export type BannerMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    type?: true
    status?: true
    priority?: true
  }

  export type BannerCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    name?: true
    type?: true
    status?: true
    priority?: true
    _all?: true
  }

  export type BannerAggregateArgs = {
    /**
     * Filter which Banner to aggregate.
     * 
    **/
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     * 
    **/
    orderBy?: Enumerable<BannerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banners
    **/
    _count?: true | BannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMaxAggregateInputType
  }

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>
  }




  export type BannerGroupByArgs = {
    where?: BannerWhereInput
    orderBy?: Enumerable<BannerOrderByWithAggregationInput>
    by: Array<BannerScalarFieldEnum>
    having?: BannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerCountAggregateInputType | true
    _avg?: BannerAvgAggregateInputType
    _sum?: BannerSumAggregateInputType
    _min?: BannerMinAggregateInputType
    _max?: BannerMaxAggregateInputType
  }


  export type BannerGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    name: string
    type: string
    status: boolean
    priority: number
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  type GetBannerGroupByPayload<T extends BannerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>
        }
      >
    >


  export type BannerSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
  }

  export type BannerGetPayload<
    S extends boolean | null | undefined | BannerArgs,
    U = keyof S
      > = S extends true
        ? Banner
    : S extends undefined
    ? never
    : S extends BannerArgs | BannerFindManyArgs
    ?'include' extends U
    ? Banner 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Banner ? Banner[P] : never
  } 
    : Banner
  : Banner


  type BannerCountArgs = Merge<
    Omit<BannerFindManyArgs, 'select' | 'include'> & {
      select?: BannerCountAggregateInputType | true
    }
  >

  export interface BannerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Banner that matches the filter.
     * @param {BannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BannerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BannerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Banner'> extends True ? CheckSelect<T, Prisma__BannerClient<Banner>, Prisma__BannerClient<BannerGetPayload<T>>> : CheckSelect<T, Prisma__BannerClient<Banner | null >, Prisma__BannerClient<BannerGetPayload<T> | null >>

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BannerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BannerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Banner'> extends True ? CheckSelect<T, Prisma__BannerClient<Banner>, Prisma__BannerClient<BannerGetPayload<T>>> : CheckSelect<T, Prisma__BannerClient<Banner | null >, Prisma__BannerClient<BannerGetPayload<T> | null >>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BannerFindManyArgs>(
      args?: SelectSubset<T, BannerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Banner>>, PrismaPromise<Array<BannerGetPayload<T>>>>

    /**
     * Create a Banner.
     * @param {BannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     * 
    **/
    create<T extends BannerCreateArgs>(
      args: SelectSubset<T, BannerCreateArgs>
    ): CheckSelect<T, Prisma__BannerClient<Banner>, Prisma__BannerClient<BannerGetPayload<T>>>

    /**
     * Create many Banners.
     *     @param {BannerCreateManyArgs} args - Arguments to create many Banners.
     *     @example
     *     // Create many Banners
     *     const banner = await prisma.banner.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BannerCreateManyArgs>(
      args?: SelectSubset<T, BannerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Banner.
     * @param {BannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     * 
    **/
    delete<T extends BannerDeleteArgs>(
      args: SelectSubset<T, BannerDeleteArgs>
    ): CheckSelect<T, Prisma__BannerClient<Banner>, Prisma__BannerClient<BannerGetPayload<T>>>

    /**
     * Update one Banner.
     * @param {BannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BannerUpdateArgs>(
      args: SelectSubset<T, BannerUpdateArgs>
    ): CheckSelect<T, Prisma__BannerClient<Banner>, Prisma__BannerClient<BannerGetPayload<T>>>

    /**
     * Delete zero or more Banners.
     * @param {BannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BannerDeleteManyArgs>(
      args?: SelectSubset<T, BannerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BannerUpdateManyArgs>(
      args: SelectSubset<T, BannerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Banner.
     * @param {BannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
    **/
    upsert<T extends BannerUpsertArgs>(
      args: SelectSubset<T, BannerUpsertArgs>
    ): CheckSelect<T, Prisma__BannerClient<Banner>, Prisma__BannerClient<BannerGetPayload<T>>>

    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends BannerCountArgs>(
      args?: Subset<T, BannerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerAggregateArgs>(args: Subset<T, BannerAggregateArgs>): PrismaPromise<GetBannerAggregateType<T>>

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerGroupByArgs['orderBy'] }
        : { orderBy?: BannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BannerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Banner findUnique
   */
  export type BannerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Banner
     * 
    **/
    select?: BannerSelect | null
    /**
     * Throw an Error if a Banner can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Banner to fetch.
     * 
    **/
    where: BannerWhereUniqueInput
  }


  /**
   * Banner findFirst
   */
  export type BannerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Banner
     * 
    **/
    select?: BannerSelect | null
    /**
     * Throw an Error if a Banner can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Banner to fetch.
     * 
    **/
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     * 
    **/
    orderBy?: Enumerable<BannerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     * 
    **/
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     * 
    **/
    distinct?: Enumerable<BannerScalarFieldEnum>
  }


  /**
   * Banner findMany
   */
  export type BannerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Banner
     * 
    **/
    select?: BannerSelect | null
    /**
     * Filter, which Banners to fetch.
     * 
    **/
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     * 
    **/
    orderBy?: Enumerable<BannerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banners.
     * 
    **/
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BannerScalarFieldEnum>
  }


  /**
   * Banner create
   */
  export type BannerCreateArgs = {
    /**
     * Select specific fields to fetch from the Banner
     * 
    **/
    select?: BannerSelect | null
    /**
     * The data needed to create a Banner.
     * 
    **/
    data: XOR<BannerCreateInput, BannerUncheckedCreateInput>
  }


  /**
   * Banner createMany
   */
  export type BannerCreateManyArgs = {
    /**
     * The data used to create many Banners.
     * 
    **/
    data: Enumerable<BannerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Banner update
   */
  export type BannerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Banner
     * 
    **/
    select?: BannerSelect | null
    /**
     * The data needed to update a Banner.
     * 
    **/
    data: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
    /**
     * Choose, which Banner to update.
     * 
    **/
    where: BannerWhereUniqueInput
  }


  /**
   * Banner updateMany
   */
  export type BannerUpdateManyArgs = {
    /**
     * The data used to update Banners.
     * 
    **/
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     * 
    **/
    where?: BannerWhereInput
  }


  /**
   * Banner upsert
   */
  export type BannerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Banner
     * 
    **/
    select?: BannerSelect | null
    /**
     * The filter to search for the Banner to update in case it exists.
     * 
    **/
    where: BannerWhereUniqueInput
    /**
     * In case the Banner found by the `where` argument doesn't exist, create a new Banner with this data.
     * 
    **/
    create: XOR<BannerCreateInput, BannerUncheckedCreateInput>
    /**
     * In case the Banner was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
  }


  /**
   * Banner delete
   */
  export type BannerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Banner
     * 
    **/
    select?: BannerSelect | null
    /**
     * Filter which Banner to delete.
     * 
    **/
    where: BannerWhereUniqueInput
  }


  /**
   * Banner deleteMany
   */
  export type BannerDeleteManyArgs = {
    /**
     * Filter which Banners to delete
     * 
    **/
    where?: BannerWhereInput
  }


  /**
   * Banner without action
   */
  export type BannerArgs = {
    /**
     * Select specific fields to fetch from the Banner
     * 
    **/
    select?: BannerSelect | null
  }



  /**
   * Model Stock
   */


  export type AggregateStock = {
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  export type StockAvgAggregateOutputType = {
    stock: number | null
  }

  export type StockSumAggregateOutputType = {
    stock: number | null
  }

  export type StockMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    stock: number | null
    status: StocksStatusEnum | null
    action: StockActionEnum | null
    product_id: string | null
  }

  export type StockMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    stock: number | null
    status: StocksStatusEnum | null
    action: StockActionEnum | null
    product_id: string | null
  }

  export type StockCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    stock: number
    status: number
    action: number
    product_id: number
    _all: number
  }


  export type StockAvgAggregateInputType = {
    stock?: true
  }

  export type StockSumAggregateInputType = {
    stock?: true
  }

  export type StockMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    stock?: true
    status?: true
    action?: true
    product_id?: true
  }

  export type StockMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    stock?: true
    status?: true
    action?: true
    product_id?: true
  }

  export type StockCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    stock?: true
    status?: true
    action?: true
    product_id?: true
    _all?: true
  }

  export type StockAggregateArgs = {
    /**
     * Filter which Stock to aggregate.
     * 
    **/
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     * 
    **/
    orderBy?: Enumerable<StockOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stocks
    **/
    _count?: true | StockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMaxAggregateInputType
  }

  export type GetStockAggregateType<T extends StockAggregateArgs> = {
        [P in keyof T & keyof AggregateStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock[P]>
      : GetScalarType<T[P], AggregateStock[P]>
  }




  export type StockGroupByArgs = {
    where?: StockWhereInput
    orderBy?: Enumerable<StockOrderByWithAggregationInput>
    by: Array<StockScalarFieldEnum>
    having?: StockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockCountAggregateInputType | true
    _avg?: StockAvgAggregateInputType
    _sum?: StockSumAggregateInputType
    _min?: StockMinAggregateInputType
    _max?: StockMaxAggregateInputType
  }


  export type StockGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    stock: number
    status: StocksStatusEnum
    action: StockActionEnum
    product_id: string
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  type GetStockGroupByPayload<T extends StockGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockGroupByOutputType[P]>
            : GetScalarType<T[P], StockGroupByOutputType[P]>
        }
      >
    >


  export type StockSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    stock?: boolean
    status?: boolean
    action?: boolean
    product_id?: boolean
    product?: boolean | ProductArgs
  }

  export type StockInclude = {
    product?: boolean | ProductArgs
  }

  export type StockGetPayload<
    S extends boolean | null | undefined | StockArgs,
    U = keyof S
      > = S extends true
        ? Stock
    : S extends undefined
    ? never
    : S extends StockArgs | StockFindManyArgs
    ?'include' extends U
    ? Stock  & {
    [P in TrueKeys<S['include']>]:
        P extends 'product' ? ProductGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'product' ? ProductGetPayload<S['select'][P]> :  P extends keyof Stock ? Stock[P] : never
  } 
    : Stock
  : Stock


  type StockCountArgs = Merge<
    Omit<StockFindManyArgs, 'select' | 'include'> & {
      select?: StockCountAggregateInputType | true
    }
  >

  export interface StockDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Stock that matches the filter.
     * @param {StockFindUniqueArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StockFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Stock'> extends True ? CheckSelect<T, Prisma__StockClient<Stock>, Prisma__StockClient<StockGetPayload<T>>> : CheckSelect<T, Prisma__StockClient<Stock | null >, Prisma__StockClient<StockGetPayload<T> | null >>

    /**
     * Find the first Stock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StockFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Stock'> extends True ? CheckSelect<T, Prisma__StockClient<Stock>, Prisma__StockClient<StockGetPayload<T>>> : CheckSelect<T, Prisma__StockClient<Stock | null >, Prisma__StockClient<StockGetPayload<T> | null >>

    /**
     * Find zero or more Stocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stocks
     * const stocks = await prisma.stock.findMany()
     * 
     * // Get first 10 Stocks
     * const stocks = await prisma.stock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockWithIdOnly = await prisma.stock.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockFindManyArgs>(
      args?: SelectSubset<T, StockFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Stock>>, PrismaPromise<Array<StockGetPayload<T>>>>

    /**
     * Create a Stock.
     * @param {StockCreateArgs} args - Arguments to create a Stock.
     * @example
     * // Create one Stock
     * const Stock = await prisma.stock.create({
     *   data: {
     *     // ... data to create a Stock
     *   }
     * })
     * 
    **/
    create<T extends StockCreateArgs>(
      args: SelectSubset<T, StockCreateArgs>
    ): CheckSelect<T, Prisma__StockClient<Stock>, Prisma__StockClient<StockGetPayload<T>>>

    /**
     * Create many Stocks.
     *     @param {StockCreateManyArgs} args - Arguments to create many Stocks.
     *     @example
     *     // Create many Stocks
     *     const stock = await prisma.stock.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockCreateManyArgs>(
      args?: SelectSubset<T, StockCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Stock.
     * @param {StockDeleteArgs} args - Arguments to delete one Stock.
     * @example
     * // Delete one Stock
     * const Stock = await prisma.stock.delete({
     *   where: {
     *     // ... filter to delete one Stock
     *   }
     * })
     * 
    **/
    delete<T extends StockDeleteArgs>(
      args: SelectSubset<T, StockDeleteArgs>
    ): CheckSelect<T, Prisma__StockClient<Stock>, Prisma__StockClient<StockGetPayload<T>>>

    /**
     * Update one Stock.
     * @param {StockUpdateArgs} args - Arguments to update one Stock.
     * @example
     * // Update one Stock
     * const stock = await prisma.stock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockUpdateArgs>(
      args: SelectSubset<T, StockUpdateArgs>
    ): CheckSelect<T, Prisma__StockClient<Stock>, Prisma__StockClient<StockGetPayload<T>>>

    /**
     * Delete zero or more Stocks.
     * @param {StockDeleteManyArgs} args - Arguments to filter Stocks to delete.
     * @example
     * // Delete a few Stocks
     * const { count } = await prisma.stock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockDeleteManyArgs>(
      args?: SelectSubset<T, StockDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockUpdateManyArgs>(
      args: SelectSubset<T, StockUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Stock.
     * @param {StockUpsertArgs} args - Arguments to update or create a Stock.
     * @example
     * // Update or create a Stock
     * const stock = await prisma.stock.upsert({
     *   create: {
     *     // ... data to create a Stock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock we want to update
     *   }
     * })
    **/
    upsert<T extends StockUpsertArgs>(
      args: SelectSubset<T, StockUpsertArgs>
    ): CheckSelect<T, Prisma__StockClient<Stock>, Prisma__StockClient<StockGetPayload<T>>>

    /**
     * Count the number of Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCountArgs} args - Arguments to filter Stocks to count.
     * @example
     * // Count the number of Stocks
     * const count = await prisma.stock.count({
     *   where: {
     *     // ... the filter for the Stocks we want to count
     *   }
     * })
    **/
    count<T extends StockCountArgs>(
      args?: Subset<T, StockCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockAggregateArgs>(args: Subset<T, StockAggregateArgs>): PrismaPromise<GetStockAggregateType<T>>

    /**
     * Group by Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockGroupByArgs['orderBy'] }
        : { orderBy?: StockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StockClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Stock findUnique
   */
  export type StockFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Stock
     * 
    **/
    select?: StockSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockInclude | null
    /**
     * Throw an Error if a Stock can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Stock to fetch.
     * 
    **/
    where: StockWhereUniqueInput
  }


  /**
   * Stock findFirst
   */
  export type StockFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Stock
     * 
    **/
    select?: StockSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockInclude | null
    /**
     * Throw an Error if a Stock can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Stock to fetch.
     * 
    **/
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     * 
    **/
    orderBy?: Enumerable<StockOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     * 
    **/
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     * 
    **/
    distinct?: Enumerable<StockScalarFieldEnum>
  }


  /**
   * Stock findMany
   */
  export type StockFindManyArgs = {
    /**
     * Select specific fields to fetch from the Stock
     * 
    **/
    select?: StockSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockInclude | null
    /**
     * Filter, which Stocks to fetch.
     * 
    **/
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     * 
    **/
    orderBy?: Enumerable<StockOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stocks.
     * 
    **/
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StockScalarFieldEnum>
  }


  /**
   * Stock create
   */
  export type StockCreateArgs = {
    /**
     * Select specific fields to fetch from the Stock
     * 
    **/
    select?: StockSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockInclude | null
    /**
     * The data needed to create a Stock.
     * 
    **/
    data: XOR<StockCreateInput, StockUncheckedCreateInput>
  }


  /**
   * Stock createMany
   */
  export type StockCreateManyArgs = {
    /**
     * The data used to create many Stocks.
     * 
    **/
    data: Enumerable<StockCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Stock update
   */
  export type StockUpdateArgs = {
    /**
     * Select specific fields to fetch from the Stock
     * 
    **/
    select?: StockSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockInclude | null
    /**
     * The data needed to update a Stock.
     * 
    **/
    data: XOR<StockUpdateInput, StockUncheckedUpdateInput>
    /**
     * Choose, which Stock to update.
     * 
    **/
    where: StockWhereUniqueInput
  }


  /**
   * Stock updateMany
   */
  export type StockUpdateManyArgs = {
    /**
     * The data used to update Stocks.
     * 
    **/
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     * 
    **/
    where?: StockWhereInput
  }


  /**
   * Stock upsert
   */
  export type StockUpsertArgs = {
    /**
     * Select specific fields to fetch from the Stock
     * 
    **/
    select?: StockSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockInclude | null
    /**
     * The filter to search for the Stock to update in case it exists.
     * 
    **/
    where: StockWhereUniqueInput
    /**
     * In case the Stock found by the `where` argument doesn't exist, create a new Stock with this data.
     * 
    **/
    create: XOR<StockCreateInput, StockUncheckedCreateInput>
    /**
     * In case the Stock was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StockUpdateInput, StockUncheckedUpdateInput>
  }


  /**
   * Stock delete
   */
  export type StockDeleteArgs = {
    /**
     * Select specific fields to fetch from the Stock
     * 
    **/
    select?: StockSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockInclude | null
    /**
     * Filter which Stock to delete.
     * 
    **/
    where: StockWhereUniqueInput
  }


  /**
   * Stock deleteMany
   */
  export type StockDeleteManyArgs = {
    /**
     * Filter which Stocks to delete
     * 
    **/
    where?: StockWhereInput
  }


  /**
   * Stock without action
   */
  export type StockArgs = {
    /**
     * Select specific fields to fetch from the Stock
     * 
    **/
    select?: StockSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StockInclude | null
  }



  /**
   * Model OrderProduct
   */


  export type AggregateOrderProduct = {
    _count: OrderProductCountAggregateOutputType | null
    _avg: OrderProductAvgAggregateOutputType | null
    _sum: OrderProductSumAggregateOutputType | null
    _min: OrderProductMinAggregateOutputType | null
    _max: OrderProductMaxAggregateOutputType | null
  }

  export type OrderProductAvgAggregateOutputType = {
    subtotal: Decimal | null
    quantity: number | null
  }

  export type OrderProductSumAggregateOutputType = {
    subtotal: Decimal | null
    quantity: number | null
  }

  export type OrderProductMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    subtotal: Decimal | null
    quantity: number | null
    status: StatusOrderEnum | null
    order_id: string | null
    product_id: string | null
    user_id: string | null
    price_id: string | null
  }

  export type OrderProductMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    subtotal: Decimal | null
    quantity: number | null
    status: StatusOrderEnum | null
    order_id: string | null
    product_id: string | null
    user_id: string | null
    price_id: string | null
  }

  export type OrderProductCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    subtotal: number
    quantity: number
    status: number
    order_id: number
    product_id: number
    user_id: number
    price_id: number
    _all: number
  }


  export type OrderProductAvgAggregateInputType = {
    subtotal?: true
    quantity?: true
  }

  export type OrderProductSumAggregateInputType = {
    subtotal?: true
    quantity?: true
  }

  export type OrderProductMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    subtotal?: true
    quantity?: true
    status?: true
    order_id?: true
    product_id?: true
    user_id?: true
    price_id?: true
  }

  export type OrderProductMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    subtotal?: true
    quantity?: true
    status?: true
    order_id?: true
    product_id?: true
    user_id?: true
    price_id?: true
  }

  export type OrderProductCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    subtotal?: true
    quantity?: true
    status?: true
    order_id?: true
    product_id?: true
    user_id?: true
    price_id?: true
    _all?: true
  }

  export type OrderProductAggregateArgs = {
    /**
     * Filter which OrderProduct to aggregate.
     * 
    **/
    where?: OrderProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderProducts
    **/
    _count?: true | OrderProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderProductMaxAggregateInputType
  }

  export type GetOrderProductAggregateType<T extends OrderProductAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderProduct[P]>
      : GetScalarType<T[P], AggregateOrderProduct[P]>
  }




  export type OrderProductGroupByArgs = {
    where?: OrderProductWhereInput
    orderBy?: Enumerable<OrderProductOrderByWithAggregationInput>
    by: Array<OrderProductScalarFieldEnum>
    having?: OrderProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderProductCountAggregateInputType | true
    _avg?: OrderProductAvgAggregateInputType
    _sum?: OrderProductSumAggregateInputType
    _min?: OrderProductMinAggregateInputType
    _max?: OrderProductMaxAggregateInputType
  }


  export type OrderProductGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    subtotal: Decimal
    quantity: number
    status: StatusOrderEnum
    order_id: string
    product_id: string
    user_id: string
    price_id: string
    _count: OrderProductCountAggregateOutputType | null
    _avg: OrderProductAvgAggregateOutputType | null
    _sum: OrderProductSumAggregateOutputType | null
    _min: OrderProductMinAggregateOutputType | null
    _max: OrderProductMaxAggregateOutputType | null
  }

  type GetOrderProductGroupByPayload<T extends OrderProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderProductGroupByOutputType[P]>
            : GetScalarType<T[P], OrderProductGroupByOutputType[P]>
        }
      >
    >


  export type OrderProductSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    subtotal?: boolean
    quantity?: boolean
    status?: boolean
    order_id?: boolean
    product_id?: boolean
    user_id?: boolean
    price_id?: boolean
    order?: boolean | OrderArgs
    product?: boolean | ProductArgs
    user?: boolean | UserArgs
    price?: boolean | PriceArgs
  }

  export type OrderProductInclude = {
    order?: boolean | OrderArgs
    product?: boolean | ProductArgs
    user?: boolean | UserArgs
    price?: boolean | PriceArgs
  }

  export type OrderProductGetPayload<
    S extends boolean | null | undefined | OrderProductArgs,
    U = keyof S
      > = S extends true
        ? OrderProduct
    : S extends undefined
    ? never
    : S extends OrderProductArgs | OrderProductFindManyArgs
    ?'include' extends U
    ? OrderProduct  & {
    [P in TrueKeys<S['include']>]:
        P extends 'order' ? OrderGetPayload<S['include'][P]> :
        P extends 'product' ? ProductGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'price' ? PriceGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'order' ? OrderGetPayload<S['select'][P]> :
        P extends 'product' ? ProductGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'price' ? PriceGetPayload<S['select'][P]> :  P extends keyof OrderProduct ? OrderProduct[P] : never
  } 
    : OrderProduct
  : OrderProduct


  type OrderProductCountArgs = Merge<
    Omit<OrderProductFindManyArgs, 'select' | 'include'> & {
      select?: OrderProductCountAggregateInputType | true
    }
  >

  export interface OrderProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one OrderProduct that matches the filter.
     * @param {OrderProductFindUniqueArgs} args - Arguments to find a OrderProduct
     * @example
     * // Get one OrderProduct
     * const orderProduct = await prisma.orderProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OrderProduct'> extends True ? CheckSelect<T, Prisma__OrderProductClient<OrderProduct>, Prisma__OrderProductClient<OrderProductGetPayload<T>>> : CheckSelect<T, Prisma__OrderProductClient<OrderProduct | null >, Prisma__OrderProductClient<OrderProductGetPayload<T> | null >>

    /**
     * Find the first OrderProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductFindFirstArgs} args - Arguments to find a OrderProduct
     * @example
     * // Get one OrderProduct
     * const orderProduct = await prisma.orderProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OrderProduct'> extends True ? CheckSelect<T, Prisma__OrderProductClient<OrderProduct>, Prisma__OrderProductClient<OrderProductGetPayload<T>>> : CheckSelect<T, Prisma__OrderProductClient<OrderProduct | null >, Prisma__OrderProductClient<OrderProductGetPayload<T> | null >>

    /**
     * Find zero or more OrderProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderProducts
     * const orderProducts = await prisma.orderProduct.findMany()
     * 
     * // Get first 10 OrderProducts
     * const orderProducts = await prisma.orderProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderProductWithIdOnly = await prisma.orderProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderProductFindManyArgs>(
      args?: SelectSubset<T, OrderProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OrderProduct>>, PrismaPromise<Array<OrderProductGetPayload<T>>>>

    /**
     * Create a OrderProduct.
     * @param {OrderProductCreateArgs} args - Arguments to create a OrderProduct.
     * @example
     * // Create one OrderProduct
     * const OrderProduct = await prisma.orderProduct.create({
     *   data: {
     *     // ... data to create a OrderProduct
     *   }
     * })
     * 
    **/
    create<T extends OrderProductCreateArgs>(
      args: SelectSubset<T, OrderProductCreateArgs>
    ): CheckSelect<T, Prisma__OrderProductClient<OrderProduct>, Prisma__OrderProductClient<OrderProductGetPayload<T>>>

    /**
     * Create many OrderProducts.
     *     @param {OrderProductCreateManyArgs} args - Arguments to create many OrderProducts.
     *     @example
     *     // Create many OrderProducts
     *     const orderProduct = await prisma.orderProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderProductCreateManyArgs>(
      args?: SelectSubset<T, OrderProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OrderProduct.
     * @param {OrderProductDeleteArgs} args - Arguments to delete one OrderProduct.
     * @example
     * // Delete one OrderProduct
     * const OrderProduct = await prisma.orderProduct.delete({
     *   where: {
     *     // ... filter to delete one OrderProduct
     *   }
     * })
     * 
    **/
    delete<T extends OrderProductDeleteArgs>(
      args: SelectSubset<T, OrderProductDeleteArgs>
    ): CheckSelect<T, Prisma__OrderProductClient<OrderProduct>, Prisma__OrderProductClient<OrderProductGetPayload<T>>>

    /**
     * Update one OrderProduct.
     * @param {OrderProductUpdateArgs} args - Arguments to update one OrderProduct.
     * @example
     * // Update one OrderProduct
     * const orderProduct = await prisma.orderProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderProductUpdateArgs>(
      args: SelectSubset<T, OrderProductUpdateArgs>
    ): CheckSelect<T, Prisma__OrderProductClient<OrderProduct>, Prisma__OrderProductClient<OrderProductGetPayload<T>>>

    /**
     * Delete zero or more OrderProducts.
     * @param {OrderProductDeleteManyArgs} args - Arguments to filter OrderProducts to delete.
     * @example
     * // Delete a few OrderProducts
     * const { count } = await prisma.orderProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderProductDeleteManyArgs>(
      args?: SelectSubset<T, OrderProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderProducts
     * const orderProduct = await prisma.orderProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderProductUpdateManyArgs>(
      args: SelectSubset<T, OrderProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderProduct.
     * @param {OrderProductUpsertArgs} args - Arguments to update or create a OrderProduct.
     * @example
     * // Update or create a OrderProduct
     * const orderProduct = await prisma.orderProduct.upsert({
     *   create: {
     *     // ... data to create a OrderProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderProduct we want to update
     *   }
     * })
    **/
    upsert<T extends OrderProductUpsertArgs>(
      args: SelectSubset<T, OrderProductUpsertArgs>
    ): CheckSelect<T, Prisma__OrderProductClient<OrderProduct>, Prisma__OrderProductClient<OrderProductGetPayload<T>>>

    /**
     * Count the number of OrderProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductCountArgs} args - Arguments to filter OrderProducts to count.
     * @example
     * // Count the number of OrderProducts
     * const count = await prisma.orderProduct.count({
     *   where: {
     *     // ... the filter for the OrderProducts we want to count
     *   }
     * })
    **/
    count<T extends OrderProductCountArgs>(
      args?: Subset<T, OrderProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderProductAggregateArgs>(args: Subset<T, OrderProductAggregateArgs>): PrismaPromise<GetOrderProductAggregateType<T>>

    /**
     * Group by OrderProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderProductGroupByArgs['orderBy'] }
        : { orderBy?: OrderProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderProductGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    order<T extends OrderArgs = {}>(args?: Subset<T, OrderArgs>): CheckSelect<T, Prisma__OrderClient<Order | null >, Prisma__OrderClient<OrderGetPayload<T> | null >>;

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    price<T extends PriceArgs = {}>(args?: Subset<T, PriceArgs>): CheckSelect<T, Prisma__PriceClient<Price | null >, Prisma__PriceClient<PriceGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * OrderProduct findUnique
   */
  export type OrderProductFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the OrderProduct
     * 
    **/
    select?: OrderProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderProductInclude | null
    /**
     * Throw an Error if a OrderProduct can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OrderProduct to fetch.
     * 
    **/
    where: OrderProductWhereUniqueInput
  }


  /**
   * OrderProduct findFirst
   */
  export type OrderProductFindFirstArgs = {
    /**
     * Select specific fields to fetch from the OrderProduct
     * 
    **/
    select?: OrderProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderProductInclude | null
    /**
     * Throw an Error if a OrderProduct can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OrderProduct to fetch.
     * 
    **/
    where?: OrderProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderProducts.
     * 
    **/
    cursor?: OrderProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderProducts.
     * 
    **/
    distinct?: Enumerable<OrderProductScalarFieldEnum>
  }


  /**
   * OrderProduct findMany
   */
  export type OrderProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the OrderProduct
     * 
    **/
    select?: OrderProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderProductInclude | null
    /**
     * Filter, which OrderProducts to fetch.
     * 
    **/
    where?: OrderProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderProducts.
     * 
    **/
    cursor?: OrderProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProducts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderProductScalarFieldEnum>
  }


  /**
   * OrderProduct create
   */
  export type OrderProductCreateArgs = {
    /**
     * Select specific fields to fetch from the OrderProduct
     * 
    **/
    select?: OrderProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderProductInclude | null
    /**
     * The data needed to create a OrderProduct.
     * 
    **/
    data: XOR<OrderProductCreateInput, OrderProductUncheckedCreateInput>
  }


  /**
   * OrderProduct createMany
   */
  export type OrderProductCreateManyArgs = {
    /**
     * The data used to create many OrderProducts.
     * 
    **/
    data: Enumerable<OrderProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OrderProduct update
   */
  export type OrderProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the OrderProduct
     * 
    **/
    select?: OrderProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderProductInclude | null
    /**
     * The data needed to update a OrderProduct.
     * 
    **/
    data: XOR<OrderProductUpdateInput, OrderProductUncheckedUpdateInput>
    /**
     * Choose, which OrderProduct to update.
     * 
    **/
    where: OrderProductWhereUniqueInput
  }


  /**
   * OrderProduct updateMany
   */
  export type OrderProductUpdateManyArgs = {
    /**
     * The data used to update OrderProducts.
     * 
    **/
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyInput>
    /**
     * Filter which OrderProducts to update
     * 
    **/
    where?: OrderProductWhereInput
  }


  /**
   * OrderProduct upsert
   */
  export type OrderProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the OrderProduct
     * 
    **/
    select?: OrderProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderProductInclude | null
    /**
     * The filter to search for the OrderProduct to update in case it exists.
     * 
    **/
    where: OrderProductWhereUniqueInput
    /**
     * In case the OrderProduct found by the `where` argument doesn't exist, create a new OrderProduct with this data.
     * 
    **/
    create: XOR<OrderProductCreateInput, OrderProductUncheckedCreateInput>
    /**
     * In case the OrderProduct was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderProductUpdateInput, OrderProductUncheckedUpdateInput>
  }


  /**
   * OrderProduct delete
   */
  export type OrderProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the OrderProduct
     * 
    **/
    select?: OrderProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderProductInclude | null
    /**
     * Filter which OrderProduct to delete.
     * 
    **/
    where: OrderProductWhereUniqueInput
  }


  /**
   * OrderProduct deleteMany
   */
  export type OrderProductDeleteManyArgs = {
    /**
     * Filter which OrderProducts to delete
     * 
    **/
    where?: OrderProductWhereInput
  }


  /**
   * OrderProduct without action
   */
  export type OrderProductArgs = {
    /**
     * Select specific fields to fetch from the OrderProduct
     * 
    **/
    select?: OrderProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderProductInclude | null
  }



  /**
   * Model Transaction
   */


  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    authorized_amount: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    authorized_amount: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    transaction_id: string | null
    status: string | null
    brand: string | null
    authorization_code: string | null
    authorized_amount: Decimal | null
    tid: string | null
    installments: string | null
    order_id: string | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    transaction_id: string | null
    status: string | null
    brand: string | null
    authorization_code: string | null
    authorized_amount: Decimal | null
    tid: string | null
    installments: string | null
    order_id: string | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    transaction_id: number
    status: number
    brand: number
    authorization_code: number
    authorized_amount: number
    tid: number
    installments: number
    order_id: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    authorized_amount?: true
  }

  export type TransactionSumAggregateInputType = {
    authorized_amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    transaction_id?: true
    status?: true
    brand?: true
    authorization_code?: true
    authorized_amount?: true
    tid?: true
    installments?: true
    order_id?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    transaction_id?: true
    status?: true
    brand?: true
    authorization_code?: true
    authorized_amount?: true
    tid?: true
    installments?: true
    order_id?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    transaction_id?: true
    status?: true
    brand?: true
    authorization_code?: true
    authorized_amount?: true
    tid?: true
    installments?: true
    order_id?: true
    _all?: true
  }

  export type TransactionAggregateArgs = {
    /**
     * Filter which Transaction to aggregate.
     * 
    **/
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs = {
    where?: TransactionWhereInput
    orderBy?: Enumerable<TransactionOrderByWithAggregationInput>
    by: Array<TransactionScalarFieldEnum>
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }


  export type TransactionGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    transaction_id: string
    status: string
    brand: string
    authorization_code: string
    authorized_amount: Decimal
    tid: string
    installments: string
    order_id: string
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    transaction_id?: boolean
    status?: boolean
    brand?: boolean
    authorization_code?: boolean
    authorized_amount?: boolean
    tid?: boolean
    installments?: boolean
    order_id?: boolean
    order?: boolean | OrderArgs
  }

  export type TransactionInclude = {
    order?: boolean | OrderArgs
  }

  export type TransactionGetPayload<
    S extends boolean | null | undefined | TransactionArgs,
    U = keyof S
      > = S extends true
        ? Transaction
    : S extends undefined
    ? never
    : S extends TransactionArgs | TransactionFindManyArgs
    ?'include' extends U
    ? Transaction  & {
    [P in TrueKeys<S['include']>]:
        P extends 'order' ? OrderGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'order' ? OrderGetPayload<S['select'][P]> :  P extends keyof Transaction ? Transaction[P] : never
  } 
    : Transaction
  : Transaction


  type TransactionCountArgs = Merge<
    Omit<TransactionFindManyArgs, 'select' | 'include'> & {
      select?: TransactionCountAggregateInputType | true
    }
  >

  export interface TransactionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TransactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TransactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Transaction'> extends True ? CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>> : CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TransactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TransactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Transaction'> extends True ? CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>> : CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TransactionFindManyArgs>(
      args?: SelectSubset<T, TransactionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Transaction>>, PrismaPromise<Array<TransactionGetPayload<T>>>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
    **/
    create<T extends TransactionCreateArgs>(
      args: SelectSubset<T, TransactionCreateArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Create many Transactions.
     *     @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     *     @example
     *     // Create many Transactions
     *     const transaction = await prisma.transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TransactionCreateManyArgs>(
      args?: SelectSubset<T, TransactionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
    **/
    delete<T extends TransactionDeleteArgs>(
      args: SelectSubset<T, TransactionDeleteArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TransactionUpdateArgs>(
      args: SelectSubset<T, TransactionUpdateArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TransactionDeleteManyArgs>(
      args?: SelectSubset<T, TransactionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TransactionUpdateManyArgs>(
      args: SelectSubset<T, TransactionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
    **/
    upsert<T extends TransactionUpsertArgs>(
      args: SelectSubset<T, TransactionUpsertArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TransactionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    order<T extends OrderArgs = {}>(args?: Subset<T, OrderArgs>): CheckSelect<T, Prisma__OrderClient<Order | null >, Prisma__OrderClient<OrderGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Throw an Error if a Transaction can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Transaction to fetch.
     * 
    **/
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Throw an Error if a Transaction can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Transaction to fetch.
     * 
    **/
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     * 
    **/
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     * 
    **/
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Filter, which Transactions to fetch.
     * 
    **/
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     * 
    **/
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Transaction create
   */
  export type TransactionCreateArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * The data needed to create a Transaction.
     * 
    **/
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }


  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs = {
    /**
     * The data used to create many Transactions.
     * 
    **/
    data: Enumerable<TransactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Transaction update
   */
  export type TransactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * The data needed to update a Transaction.
     * 
    **/
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     * 
    **/
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs = {
    /**
     * The data used to update Transactions.
     * 
    **/
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     * 
    **/
    where?: TransactionWhereInput
  }


  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     * 
    **/
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     * 
    **/
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }


  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Filter which Transaction to delete.
     * 
    **/
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs = {
    /**
     * Filter which Transactions to delete
     * 
    **/
    where?: TransactionWhereInput
  }


  /**
   * Transaction without action
   */
  export type TransactionArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
  }



  /**
   * Model ProductInfo
   */


  export type AggregateProductInfo = {
    _count: ProductInfoCountAggregateOutputType | null
    _avg: ProductInfoAvgAggregateOutputType | null
    _sum: ProductInfoSumAggregateOutputType | null
    _min: ProductInfoMinAggregateOutputType | null
    _max: ProductInfoMaxAggregateOutputType | null
  }

  export type ProductInfoAvgAggregateOutputType = {
    price: Decimal | null
    price_promotion: Decimal | null
    freight: Decimal | null
    stock: number | null
  }

  export type ProductInfoSumAggregateOutputType = {
    price: Decimal | null
    price_promotion: Decimal | null
    freight: Decimal | null
    stock: number | null
  }

  export type ProductInfoMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    price: Decimal | null
    price_promotion: Decimal | null
    freight: Decimal | null
    link: string | null
    stock: number | null
    company: string | null
    currency: string | null
    user_id: string | null
  }

  export type ProductInfoMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    price: Decimal | null
    price_promotion: Decimal | null
    freight: Decimal | null
    link: string | null
    stock: number | null
    company: string | null
    currency: string | null
    user_id: string | null
  }

  export type ProductInfoCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    price: number
    price_promotion: number
    freight: number
    link: number
    stock: number
    company: number
    currency: number
    user_id: number
    _all: number
  }


  export type ProductInfoAvgAggregateInputType = {
    price?: true
    price_promotion?: true
    freight?: true
    stock?: true
  }

  export type ProductInfoSumAggregateInputType = {
    price?: true
    price_promotion?: true
    freight?: true
    stock?: true
  }

  export type ProductInfoMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    price?: true
    price_promotion?: true
    freight?: true
    link?: true
    stock?: true
    company?: true
    currency?: true
    user_id?: true
  }

  export type ProductInfoMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    price?: true
    price_promotion?: true
    freight?: true
    link?: true
    stock?: true
    company?: true
    currency?: true
    user_id?: true
  }

  export type ProductInfoCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    price?: true
    price_promotion?: true
    freight?: true
    link?: true
    stock?: true
    company?: true
    currency?: true
    user_id?: true
    _all?: true
  }

  export type ProductInfoAggregateArgs = {
    /**
     * Filter which ProductInfo to aggregate.
     * 
    **/
    where?: ProductInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInfos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductInfos
    **/
    _count?: true | ProductInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductInfoMaxAggregateInputType
  }

  export type GetProductInfoAggregateType<T extends ProductInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateProductInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductInfo[P]>
      : GetScalarType<T[P], AggregateProductInfo[P]>
  }




  export type ProductInfoGroupByArgs = {
    where?: ProductInfoWhereInput
    orderBy?: Enumerable<ProductInfoOrderByWithAggregationInput>
    by: Array<ProductInfoScalarFieldEnum>
    having?: ProductInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductInfoCountAggregateInputType | true
    _avg?: ProductInfoAvgAggregateInputType
    _sum?: ProductInfoSumAggregateInputType
    _min?: ProductInfoMinAggregateInputType
    _max?: ProductInfoMaxAggregateInputType
  }


  export type ProductInfoGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    price: Decimal
    price_promotion: Decimal
    freight: Decimal
    link: string
    stock: number
    company: string
    currency: string
    user_id: string
    _count: ProductInfoCountAggregateOutputType | null
    _avg: ProductInfoAvgAggregateOutputType | null
    _sum: ProductInfoSumAggregateOutputType | null
    _min: ProductInfoMinAggregateOutputType | null
    _max: ProductInfoMaxAggregateOutputType | null
  }

  type GetProductInfoGroupByPayload<T extends ProductInfoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductInfoGroupByOutputType[P]>
            : GetScalarType<T[P], ProductInfoGroupByOutputType[P]>
        }
      >
    >


  export type ProductInfoSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    price?: boolean
    price_promotion?: boolean
    freight?: boolean
    link?: boolean
    stock?: boolean
    company?: boolean
    currency?: boolean
    user_id?: boolean
    user?: boolean | UserArgs
    product?: boolean | ProductArgs
  }

  export type ProductInfoInclude = {
    user?: boolean | UserArgs
    product?: boolean | ProductArgs
  }

  export type ProductInfoGetPayload<
    S extends boolean | null | undefined | ProductInfoArgs,
    U = keyof S
      > = S extends true
        ? ProductInfo
    : S extends undefined
    ? never
    : S extends ProductInfoArgs | ProductInfoFindManyArgs
    ?'include' extends U
    ? ProductInfo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'product' ? ProductGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'product' ? ProductGetPayload<S['select'][P]> | null :  P extends keyof ProductInfo ? ProductInfo[P] : never
  } 
    : ProductInfo
  : ProductInfo


  type ProductInfoCountArgs = Merge<
    Omit<ProductInfoFindManyArgs, 'select' | 'include'> & {
      select?: ProductInfoCountAggregateInputType | true
    }
  >

  export interface ProductInfoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductInfo that matches the filter.
     * @param {ProductInfoFindUniqueArgs} args - Arguments to find a ProductInfo
     * @example
     * // Get one ProductInfo
     * const productInfo = await prisma.productInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductInfoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductInfoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductInfo'> extends True ? CheckSelect<T, Prisma__ProductInfoClient<ProductInfo>, Prisma__ProductInfoClient<ProductInfoGetPayload<T>>> : CheckSelect<T, Prisma__ProductInfoClient<ProductInfo | null >, Prisma__ProductInfoClient<ProductInfoGetPayload<T> | null >>

    /**
     * Find the first ProductInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInfoFindFirstArgs} args - Arguments to find a ProductInfo
     * @example
     * // Get one ProductInfo
     * const productInfo = await prisma.productInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductInfoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductInfoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductInfo'> extends True ? CheckSelect<T, Prisma__ProductInfoClient<ProductInfo>, Prisma__ProductInfoClient<ProductInfoGetPayload<T>>> : CheckSelect<T, Prisma__ProductInfoClient<ProductInfo | null >, Prisma__ProductInfoClient<ProductInfoGetPayload<T> | null >>

    /**
     * Find zero or more ProductInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductInfos
     * const productInfos = await prisma.productInfo.findMany()
     * 
     * // Get first 10 ProductInfos
     * const productInfos = await prisma.productInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productInfoWithIdOnly = await prisma.productInfo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductInfoFindManyArgs>(
      args?: SelectSubset<T, ProductInfoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductInfo>>, PrismaPromise<Array<ProductInfoGetPayload<T>>>>

    /**
     * Create a ProductInfo.
     * @param {ProductInfoCreateArgs} args - Arguments to create a ProductInfo.
     * @example
     * // Create one ProductInfo
     * const ProductInfo = await prisma.productInfo.create({
     *   data: {
     *     // ... data to create a ProductInfo
     *   }
     * })
     * 
    **/
    create<T extends ProductInfoCreateArgs>(
      args: SelectSubset<T, ProductInfoCreateArgs>
    ): CheckSelect<T, Prisma__ProductInfoClient<ProductInfo>, Prisma__ProductInfoClient<ProductInfoGetPayload<T>>>

    /**
     * Create many ProductInfos.
     *     @param {ProductInfoCreateManyArgs} args - Arguments to create many ProductInfos.
     *     @example
     *     // Create many ProductInfos
     *     const productInfo = await prisma.productInfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductInfoCreateManyArgs>(
      args?: SelectSubset<T, ProductInfoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductInfo.
     * @param {ProductInfoDeleteArgs} args - Arguments to delete one ProductInfo.
     * @example
     * // Delete one ProductInfo
     * const ProductInfo = await prisma.productInfo.delete({
     *   where: {
     *     // ... filter to delete one ProductInfo
     *   }
     * })
     * 
    **/
    delete<T extends ProductInfoDeleteArgs>(
      args: SelectSubset<T, ProductInfoDeleteArgs>
    ): CheckSelect<T, Prisma__ProductInfoClient<ProductInfo>, Prisma__ProductInfoClient<ProductInfoGetPayload<T>>>

    /**
     * Update one ProductInfo.
     * @param {ProductInfoUpdateArgs} args - Arguments to update one ProductInfo.
     * @example
     * // Update one ProductInfo
     * const productInfo = await prisma.productInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductInfoUpdateArgs>(
      args: SelectSubset<T, ProductInfoUpdateArgs>
    ): CheckSelect<T, Prisma__ProductInfoClient<ProductInfo>, Prisma__ProductInfoClient<ProductInfoGetPayload<T>>>

    /**
     * Delete zero or more ProductInfos.
     * @param {ProductInfoDeleteManyArgs} args - Arguments to filter ProductInfos to delete.
     * @example
     * // Delete a few ProductInfos
     * const { count } = await prisma.productInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductInfoDeleteManyArgs>(
      args?: SelectSubset<T, ProductInfoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductInfos
     * const productInfo = await prisma.productInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductInfoUpdateManyArgs>(
      args: SelectSubset<T, ProductInfoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductInfo.
     * @param {ProductInfoUpsertArgs} args - Arguments to update or create a ProductInfo.
     * @example
     * // Update or create a ProductInfo
     * const productInfo = await prisma.productInfo.upsert({
     *   create: {
     *     // ... data to create a ProductInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductInfo we want to update
     *   }
     * })
    **/
    upsert<T extends ProductInfoUpsertArgs>(
      args: SelectSubset<T, ProductInfoUpsertArgs>
    ): CheckSelect<T, Prisma__ProductInfoClient<ProductInfo>, Prisma__ProductInfoClient<ProductInfoGetPayload<T>>>

    /**
     * Count the number of ProductInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInfoCountArgs} args - Arguments to filter ProductInfos to count.
     * @example
     * // Count the number of ProductInfos
     * const count = await prisma.productInfo.count({
     *   where: {
     *     // ... the filter for the ProductInfos we want to count
     *   }
     * })
    **/
    count<T extends ProductInfoCountArgs>(
      args?: Subset<T, ProductInfoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductInfoAggregateArgs>(args: Subset<T, ProductInfoAggregateArgs>): PrismaPromise<GetProductInfoAggregateType<T>>

    /**
     * Group by ProductInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductInfoGroupByArgs['orderBy'] }
        : { orderBy?: ProductInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductInfoGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductInfoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductInfo findUnique
   */
  export type ProductInfoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductInfo
     * 
    **/
    select?: ProductInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInfoInclude | null
    /**
     * Throw an Error if a ProductInfo can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductInfo to fetch.
     * 
    **/
    where: ProductInfoWhereUniqueInput
  }


  /**
   * ProductInfo findFirst
   */
  export type ProductInfoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductInfo
     * 
    **/
    select?: ProductInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInfoInclude | null
    /**
     * Throw an Error if a ProductInfo can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductInfo to fetch.
     * 
    **/
    where?: ProductInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductInfos.
     * 
    **/
    cursor?: ProductInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInfos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductInfos.
     * 
    **/
    distinct?: Enumerable<ProductInfoScalarFieldEnum>
  }


  /**
   * ProductInfo findMany
   */
  export type ProductInfoFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductInfo
     * 
    **/
    select?: ProductInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInfoInclude | null
    /**
     * Filter, which ProductInfos to fetch.
     * 
    **/
    where?: ProductInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInfos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductInfos.
     * 
    **/
    cursor?: ProductInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInfos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInfos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductInfoScalarFieldEnum>
  }


  /**
   * ProductInfo create
   */
  export type ProductInfoCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductInfo
     * 
    **/
    select?: ProductInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInfoInclude | null
    /**
     * The data needed to create a ProductInfo.
     * 
    **/
    data: XOR<ProductInfoCreateInput, ProductInfoUncheckedCreateInput>
  }


  /**
   * ProductInfo createMany
   */
  export type ProductInfoCreateManyArgs = {
    /**
     * The data used to create many ProductInfos.
     * 
    **/
    data: Enumerable<ProductInfoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductInfo update
   */
  export type ProductInfoUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductInfo
     * 
    **/
    select?: ProductInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInfoInclude | null
    /**
     * The data needed to update a ProductInfo.
     * 
    **/
    data: XOR<ProductInfoUpdateInput, ProductInfoUncheckedUpdateInput>
    /**
     * Choose, which ProductInfo to update.
     * 
    **/
    where: ProductInfoWhereUniqueInput
  }


  /**
   * ProductInfo updateMany
   */
  export type ProductInfoUpdateManyArgs = {
    /**
     * The data used to update ProductInfos.
     * 
    **/
    data: XOR<ProductInfoUpdateManyMutationInput, ProductInfoUncheckedUpdateManyInput>
    /**
     * Filter which ProductInfos to update
     * 
    **/
    where?: ProductInfoWhereInput
  }


  /**
   * ProductInfo upsert
   */
  export type ProductInfoUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductInfo
     * 
    **/
    select?: ProductInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInfoInclude | null
    /**
     * The filter to search for the ProductInfo to update in case it exists.
     * 
    **/
    where: ProductInfoWhereUniqueInput
    /**
     * In case the ProductInfo found by the `where` argument doesn't exist, create a new ProductInfo with this data.
     * 
    **/
    create: XOR<ProductInfoCreateInput, ProductInfoUncheckedCreateInput>
    /**
     * In case the ProductInfo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductInfoUpdateInput, ProductInfoUncheckedUpdateInput>
  }


  /**
   * ProductInfo delete
   */
  export type ProductInfoDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductInfo
     * 
    **/
    select?: ProductInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInfoInclude | null
    /**
     * Filter which ProductInfo to delete.
     * 
    **/
    where: ProductInfoWhereUniqueInput
  }


  /**
   * ProductInfo deleteMany
   */
  export type ProductInfoDeleteManyArgs = {
    /**
     * Filter which ProductInfos to delete
     * 
    **/
    where?: ProductInfoWhereInput
  }


  /**
   * ProductInfo without action
   */
  export type ProductInfoArgs = {
    /**
     * Select specific fields to fetch from the ProductInfo
     * 
    **/
    select?: ProductInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInfoInclude | null
  }



  /**
   * Model ForgotToken
   */


  export type AggregateForgotToken = {
    _count: ForgotTokenCountAggregateOutputType | null
    _min: ForgotTokenMinAggregateOutputType | null
    _max: ForgotTokenMaxAggregateOutputType | null
  }

  export type ForgotTokenMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    token: string | null
    code: string | null
    expires_date: Date | null
    user_id: string | null
  }

  export type ForgotTokenMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    token: string | null
    code: string | null
    expires_date: Date | null
    user_id: string | null
  }

  export type ForgotTokenCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    token: number
    code: number
    expires_date: number
    user_id: number
    _all: number
  }


  export type ForgotTokenMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    token?: true
    code?: true
    expires_date?: true
    user_id?: true
  }

  export type ForgotTokenMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    token?: true
    code?: true
    expires_date?: true
    user_id?: true
  }

  export type ForgotTokenCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    token?: true
    code?: true
    expires_date?: true
    user_id?: true
    _all?: true
  }

  export type ForgotTokenAggregateArgs = {
    /**
     * Filter which ForgotToken to aggregate.
     * 
    **/
    where?: ForgotTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForgotTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<ForgotTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ForgotTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForgotTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForgotTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForgotTokens
    **/
    _count?: true | ForgotTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForgotTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForgotTokenMaxAggregateInputType
  }

  export type GetForgotTokenAggregateType<T extends ForgotTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateForgotToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForgotToken[P]>
      : GetScalarType<T[P], AggregateForgotToken[P]>
  }




  export type ForgotTokenGroupByArgs = {
    where?: ForgotTokenWhereInput
    orderBy?: Enumerable<ForgotTokenOrderByWithAggregationInput>
    by: Array<ForgotTokenScalarFieldEnum>
    having?: ForgotTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForgotTokenCountAggregateInputType | true
    _min?: ForgotTokenMinAggregateInputType
    _max?: ForgotTokenMaxAggregateInputType
  }


  export type ForgotTokenGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    token: string
    code: string
    expires_date: Date
    user_id: string
    _count: ForgotTokenCountAggregateOutputType | null
    _min: ForgotTokenMinAggregateOutputType | null
    _max: ForgotTokenMaxAggregateOutputType | null
  }

  type GetForgotTokenGroupByPayload<T extends ForgotTokenGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ForgotTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForgotTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForgotTokenGroupByOutputType[P]>
            : GetScalarType<T[P], ForgotTokenGroupByOutputType[P]>
        }
      >
    >


  export type ForgotTokenSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    token?: boolean
    code?: boolean
    expires_date?: boolean
    user_id?: boolean
    user?: boolean | UserArgs
  }

  export type ForgotTokenInclude = {
    user?: boolean | UserArgs
  }

  export type ForgotTokenGetPayload<
    S extends boolean | null | undefined | ForgotTokenArgs,
    U = keyof S
      > = S extends true
        ? ForgotToken
    : S extends undefined
    ? never
    : S extends ForgotTokenArgs | ForgotTokenFindManyArgs
    ?'include' extends U
    ? ForgotToken  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof ForgotToken ? ForgotToken[P] : never
  } 
    : ForgotToken
  : ForgotToken


  type ForgotTokenCountArgs = Merge<
    Omit<ForgotTokenFindManyArgs, 'select' | 'include'> & {
      select?: ForgotTokenCountAggregateInputType | true
    }
  >

  export interface ForgotTokenDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ForgotToken that matches the filter.
     * @param {ForgotTokenFindUniqueArgs} args - Arguments to find a ForgotToken
     * @example
     * // Get one ForgotToken
     * const forgotToken = await prisma.forgotToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ForgotTokenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ForgotTokenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ForgotToken'> extends True ? CheckSelect<T, Prisma__ForgotTokenClient<ForgotToken>, Prisma__ForgotTokenClient<ForgotTokenGetPayload<T>>> : CheckSelect<T, Prisma__ForgotTokenClient<ForgotToken | null >, Prisma__ForgotTokenClient<ForgotTokenGetPayload<T> | null >>

    /**
     * Find the first ForgotToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForgotTokenFindFirstArgs} args - Arguments to find a ForgotToken
     * @example
     * // Get one ForgotToken
     * const forgotToken = await prisma.forgotToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ForgotTokenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ForgotTokenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ForgotToken'> extends True ? CheckSelect<T, Prisma__ForgotTokenClient<ForgotToken>, Prisma__ForgotTokenClient<ForgotTokenGetPayload<T>>> : CheckSelect<T, Prisma__ForgotTokenClient<ForgotToken | null >, Prisma__ForgotTokenClient<ForgotTokenGetPayload<T> | null >>

    /**
     * Find zero or more ForgotTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForgotTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForgotTokens
     * const forgotTokens = await prisma.forgotToken.findMany()
     * 
     * // Get first 10 ForgotTokens
     * const forgotTokens = await prisma.forgotToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forgotTokenWithIdOnly = await prisma.forgotToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ForgotTokenFindManyArgs>(
      args?: SelectSubset<T, ForgotTokenFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ForgotToken>>, PrismaPromise<Array<ForgotTokenGetPayload<T>>>>

    /**
     * Create a ForgotToken.
     * @param {ForgotTokenCreateArgs} args - Arguments to create a ForgotToken.
     * @example
     * // Create one ForgotToken
     * const ForgotToken = await prisma.forgotToken.create({
     *   data: {
     *     // ... data to create a ForgotToken
     *   }
     * })
     * 
    **/
    create<T extends ForgotTokenCreateArgs>(
      args: SelectSubset<T, ForgotTokenCreateArgs>
    ): CheckSelect<T, Prisma__ForgotTokenClient<ForgotToken>, Prisma__ForgotTokenClient<ForgotTokenGetPayload<T>>>

    /**
     * Create many ForgotTokens.
     *     @param {ForgotTokenCreateManyArgs} args - Arguments to create many ForgotTokens.
     *     @example
     *     // Create many ForgotTokens
     *     const forgotToken = await prisma.forgotToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ForgotTokenCreateManyArgs>(
      args?: SelectSubset<T, ForgotTokenCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ForgotToken.
     * @param {ForgotTokenDeleteArgs} args - Arguments to delete one ForgotToken.
     * @example
     * // Delete one ForgotToken
     * const ForgotToken = await prisma.forgotToken.delete({
     *   where: {
     *     // ... filter to delete one ForgotToken
     *   }
     * })
     * 
    **/
    delete<T extends ForgotTokenDeleteArgs>(
      args: SelectSubset<T, ForgotTokenDeleteArgs>
    ): CheckSelect<T, Prisma__ForgotTokenClient<ForgotToken>, Prisma__ForgotTokenClient<ForgotTokenGetPayload<T>>>

    /**
     * Update one ForgotToken.
     * @param {ForgotTokenUpdateArgs} args - Arguments to update one ForgotToken.
     * @example
     * // Update one ForgotToken
     * const forgotToken = await prisma.forgotToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ForgotTokenUpdateArgs>(
      args: SelectSubset<T, ForgotTokenUpdateArgs>
    ): CheckSelect<T, Prisma__ForgotTokenClient<ForgotToken>, Prisma__ForgotTokenClient<ForgotTokenGetPayload<T>>>

    /**
     * Delete zero or more ForgotTokens.
     * @param {ForgotTokenDeleteManyArgs} args - Arguments to filter ForgotTokens to delete.
     * @example
     * // Delete a few ForgotTokens
     * const { count } = await prisma.forgotToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ForgotTokenDeleteManyArgs>(
      args?: SelectSubset<T, ForgotTokenDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForgotTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForgotTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForgotTokens
     * const forgotToken = await prisma.forgotToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ForgotTokenUpdateManyArgs>(
      args: SelectSubset<T, ForgotTokenUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ForgotToken.
     * @param {ForgotTokenUpsertArgs} args - Arguments to update or create a ForgotToken.
     * @example
     * // Update or create a ForgotToken
     * const forgotToken = await prisma.forgotToken.upsert({
     *   create: {
     *     // ... data to create a ForgotToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForgotToken we want to update
     *   }
     * })
    **/
    upsert<T extends ForgotTokenUpsertArgs>(
      args: SelectSubset<T, ForgotTokenUpsertArgs>
    ): CheckSelect<T, Prisma__ForgotTokenClient<ForgotToken>, Prisma__ForgotTokenClient<ForgotTokenGetPayload<T>>>

    /**
     * Count the number of ForgotTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForgotTokenCountArgs} args - Arguments to filter ForgotTokens to count.
     * @example
     * // Count the number of ForgotTokens
     * const count = await prisma.forgotToken.count({
     *   where: {
     *     // ... the filter for the ForgotTokens we want to count
     *   }
     * })
    **/
    count<T extends ForgotTokenCountArgs>(
      args?: Subset<T, ForgotTokenCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForgotTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForgotToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForgotTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForgotTokenAggregateArgs>(args: Subset<T, ForgotTokenAggregateArgs>): PrismaPromise<GetForgotTokenAggregateType<T>>

    /**
     * Group by ForgotToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForgotTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForgotTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForgotTokenGroupByArgs['orderBy'] }
        : { orderBy?: ForgotTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForgotTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForgotTokenGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForgotToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ForgotTokenClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ForgotToken findUnique
   */
  export type ForgotTokenFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ForgotToken
     * 
    **/
    select?: ForgotTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ForgotTokenInclude | null
    /**
     * Throw an Error if a ForgotToken can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ForgotToken to fetch.
     * 
    **/
    where: ForgotTokenWhereUniqueInput
  }


  /**
   * ForgotToken findFirst
   */
  export type ForgotTokenFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ForgotToken
     * 
    **/
    select?: ForgotTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ForgotTokenInclude | null
    /**
     * Throw an Error if a ForgotToken can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ForgotToken to fetch.
     * 
    **/
    where?: ForgotTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForgotTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<ForgotTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForgotTokens.
     * 
    **/
    cursor?: ForgotTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForgotTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForgotTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForgotTokens.
     * 
    **/
    distinct?: Enumerable<ForgotTokenScalarFieldEnum>
  }


  /**
   * ForgotToken findMany
   */
  export type ForgotTokenFindManyArgs = {
    /**
     * Select specific fields to fetch from the ForgotToken
     * 
    **/
    select?: ForgotTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ForgotTokenInclude | null
    /**
     * Filter, which ForgotTokens to fetch.
     * 
    **/
    where?: ForgotTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForgotTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<ForgotTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForgotTokens.
     * 
    **/
    cursor?: ForgotTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForgotTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForgotTokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ForgotTokenScalarFieldEnum>
  }


  /**
   * ForgotToken create
   */
  export type ForgotTokenCreateArgs = {
    /**
     * Select specific fields to fetch from the ForgotToken
     * 
    **/
    select?: ForgotTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ForgotTokenInclude | null
    /**
     * The data needed to create a ForgotToken.
     * 
    **/
    data: XOR<ForgotTokenCreateInput, ForgotTokenUncheckedCreateInput>
  }


  /**
   * ForgotToken createMany
   */
  export type ForgotTokenCreateManyArgs = {
    /**
     * The data used to create many ForgotTokens.
     * 
    **/
    data: Enumerable<ForgotTokenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ForgotToken update
   */
  export type ForgotTokenUpdateArgs = {
    /**
     * Select specific fields to fetch from the ForgotToken
     * 
    **/
    select?: ForgotTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ForgotTokenInclude | null
    /**
     * The data needed to update a ForgotToken.
     * 
    **/
    data: XOR<ForgotTokenUpdateInput, ForgotTokenUncheckedUpdateInput>
    /**
     * Choose, which ForgotToken to update.
     * 
    **/
    where: ForgotTokenWhereUniqueInput
  }


  /**
   * ForgotToken updateMany
   */
  export type ForgotTokenUpdateManyArgs = {
    /**
     * The data used to update ForgotTokens.
     * 
    **/
    data: XOR<ForgotTokenUpdateManyMutationInput, ForgotTokenUncheckedUpdateManyInput>
    /**
     * Filter which ForgotTokens to update
     * 
    **/
    where?: ForgotTokenWhereInput
  }


  /**
   * ForgotToken upsert
   */
  export type ForgotTokenUpsertArgs = {
    /**
     * Select specific fields to fetch from the ForgotToken
     * 
    **/
    select?: ForgotTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ForgotTokenInclude | null
    /**
     * The filter to search for the ForgotToken to update in case it exists.
     * 
    **/
    where: ForgotTokenWhereUniqueInput
    /**
     * In case the ForgotToken found by the `where` argument doesn't exist, create a new ForgotToken with this data.
     * 
    **/
    create: XOR<ForgotTokenCreateInput, ForgotTokenUncheckedCreateInput>
    /**
     * In case the ForgotToken was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ForgotTokenUpdateInput, ForgotTokenUncheckedUpdateInput>
  }


  /**
   * ForgotToken delete
   */
  export type ForgotTokenDeleteArgs = {
    /**
     * Select specific fields to fetch from the ForgotToken
     * 
    **/
    select?: ForgotTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ForgotTokenInclude | null
    /**
     * Filter which ForgotToken to delete.
     * 
    **/
    where: ForgotTokenWhereUniqueInput
  }


  /**
   * ForgotToken deleteMany
   */
  export type ForgotTokenDeleteManyArgs = {
    /**
     * Filter which ForgotTokens to delete
     * 
    **/
    where?: ForgotTokenWhereInput
  }


  /**
   * ForgotToken without action
   */
  export type ForgotTokenArgs = {
    /**
     * Select specific fields to fetch from the ForgotToken
     * 
    **/
    select?: ForgotTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ForgotTokenInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const PersonScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    email: 'email',
    cpf: 'cpf',
    rg: 'rg',
    rgss: 'rgss',
    birth_date: 'birth_date',
    status: 'status',
    privacy: 'privacy',
    avatar: 'avatar',
    phone_id: 'phone_id',
    address_id: 'address_id'
  };

  export type PersonScalarFieldEnum = (typeof PersonScalarFieldEnum)[keyof typeof PersonScalarFieldEnum]


  export const AddressPersonScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    number: 'number',
    street: 'street',
    complement: 'complement',
    zip_code: 'zip_code',
    city: 'city',
    state: 'state',
    neighborhood: 'neighborhood',
    person_id: 'person_id'
  };

  export type AddressPersonScalarFieldEnum = (typeof AddressPersonScalarFieldEnum)[keyof typeof AddressPersonScalarFieldEnum]


  export const PhonePersonScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    phone: 'phone',
    person_id: 'person_id'
  };

  export type PhonePersonScalarFieldEnum = (typeof PhonePersonScalarFieldEnum)[keyof typeof PhonePersonScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    description: 'description'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    password: 'password',
    is_verified: 'is_verified',
    person_id: 'person_id'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserGroupScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_id: 'user_id',
    group_id: 'group_id'
  };

  export type UserGroupScalarFieldEnum = (typeof UserGroupScalarFieldEnum)[keyof typeof UserGroupScalarFieldEnum]


  export const RefresheTokenScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    refresh_token: 'refresh_token',
    device: 'device',
    expires_date: 'expires_date',
    user_id: 'user_id'
  };

  export type RefresheTokenScalarFieldEnum = (typeof RefresheTokenScalarFieldEnum)[keyof typeof RefresheTokenScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    type: 'type',
    slug: 'slug',
    description: 'description',
    photo: 'photo'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const PoliticScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    reading_time: 'reading_time',
    slug: 'slug',
    description: 'description'
  };

  export type PoliticScalarFieldEnum = (typeof PoliticScalarFieldEnum)[keyof typeof PoliticScalarFieldEnum]


  export const SubCategoryScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name'
  };

  export type SubCategoryScalarFieldEnum = (typeof SubCategoryScalarFieldEnum)[keyof typeof SubCategoryScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    total: 'total',
    freight: 'freight',
    canceled_at: 'canceled_at',
    status: 'status',
    user_id: 'user_id'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    sku: 'sku',
    bar_code: 'bar_code',
    other: 'other',
    canceled_at: 'canceled_at',
    status: 'status',
    status_freight: 'status_freight',
    status_product: 'status_product',
    price_id: 'price_id',
    description_id: 'description_id',
    subcategory_id: 'subcategory_id',
    product_info_id: 'product_info_id'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const CategoryProductScalarFieldEnum: {
    created_at: 'created_at',
    updated_at: 'updated_at',
    category_id: 'category_id',
    product_id: 'product_id'
  };

  export type CategoryProductScalarFieldEnum = (typeof CategoryProductScalarFieldEnum)[keyof typeof CategoryProductScalarFieldEnum]


  export const PhotoScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    priority: 'priority',
    product_id: 'product_id'
  };

  export type PhotoScalarFieldEnum = (typeof PhotoScalarFieldEnum)[keyof typeof PhotoScalarFieldEnum]


  export const PriceScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    price: 'price',
    price_promotion: 'price_promotion',
    product_id: 'product_id',
    user_id: 'user_id'
  };

  export type PriceScalarFieldEnum = (typeof PriceScalarFieldEnum)[keyof typeof PriceScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    slug: 'slug',
    product_id: 'product_id'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    comment: 'comment',
    status: 'status',
    product_id: 'product_id',
    author_id: 'author_id'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    text: 'text'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const DescriptionScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    description: 'description'
  };

  export type DescriptionScalarFieldEnum = (typeof DescriptionScalarFieldEnum)[keyof typeof DescriptionScalarFieldEnum]


  export const BannerScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    name: 'name',
    type: 'type',
    status: 'status',
    priority: 'priority'
  };

  export type BannerScalarFieldEnum = (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum]


  export const StockScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    stock: 'stock',
    status: 'status',
    action: 'action',
    product_id: 'product_id'
  };

  export type StockScalarFieldEnum = (typeof StockScalarFieldEnum)[keyof typeof StockScalarFieldEnum]


  export const OrderProductScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    subtotal: 'subtotal',
    quantity: 'quantity',
    status: 'status',
    order_id: 'order_id',
    product_id: 'product_id',
    user_id: 'user_id',
    price_id: 'price_id'
  };

  export type OrderProductScalarFieldEnum = (typeof OrderProductScalarFieldEnum)[keyof typeof OrderProductScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    transaction_id: 'transaction_id',
    status: 'status',
    brand: 'brand',
    authorization_code: 'authorization_code',
    authorized_amount: 'authorized_amount',
    tid: 'tid',
    installments: 'installments',
    order_id: 'order_id'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const ProductInfoScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    price: 'price',
    price_promotion: 'price_promotion',
    freight: 'freight',
    link: 'link',
    stock: 'stock',
    company: 'company',
    currency: 'currency',
    user_id: 'user_id'
  };

  export type ProductInfoScalarFieldEnum = (typeof ProductInfoScalarFieldEnum)[keyof typeof ProductInfoScalarFieldEnum]


  export const ForgotTokenScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    token: 'token',
    code: 'code',
    expires_date: 'expires_date',
    user_id: 'user_id'
  };

  export type ForgotTokenScalarFieldEnum = (typeof ForgotTokenScalarFieldEnum)[keyof typeof ForgotTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: 'DbNull',
    JsonNull: 'JsonNull'
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: 'DbNull',
    JsonNull: 'JsonNull',
    AnyNull: 'AnyNull'
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type PersonWhereInput = {
    AND?: Enumerable<PersonWhereInput>
    OR?: Enumerable<PersonWhereInput>
    NOT?: Enumerable<PersonWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    name?: StringFilter | string
    email?: StringFilter | string
    cpf?: StringNullableFilter | string | null
    rg?: StringNullableFilter | string | null
    rgss?: StringNullableFilter | string | null
    birth_date?: DateTimeNullableFilter | Date | string | null
    status?: BoolFilter | boolean
    privacy?: BoolFilter | boolean
    avatar?: StringNullableFilter | string | null
    users?: UserListRelationFilter
    phone_id?: StringNullableFilter | string | null
    phone?: XOR<PhonePersonRelationFilter, PhonePersonWhereInput> | null
    address_id?: StringNullableFilter | string | null
    address?: XOR<AddressPersonRelationFilter, AddressPersonWhereInput> | null
    addresses?: AddressPersonListRelationFilter
    phones?: PhonePersonListRelationFilter
  }

  export type PersonOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
    rgss?: SortOrder
    birth_date?: SortOrder
    status?: SortOrder
    privacy?: SortOrder
    avatar?: SortOrder
    users?: UserOrderByRelationAggregateInput
    phone_id?: SortOrder
    phone?: PhonePersonOrderByWithRelationInput
    address_id?: SortOrder
    address?: AddressPersonOrderByWithRelationInput
    addresses?: AddressPersonOrderByRelationAggregateInput
    phones?: PhonePersonOrderByRelationAggregateInput
  }

  export type PersonWhereUniqueInput = {
    id?: string
    email?: string
    cpf?: string
    phone_id?: string
    address_id?: string
  }

  export type PersonOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
    rgss?: SortOrder
    birth_date?: SortOrder
    status?: SortOrder
    privacy?: SortOrder
    avatar?: SortOrder
    phone_id?: SortOrder
    address_id?: SortOrder
    _count?: PersonCountOrderByAggregateInput
    _max?: PersonMaxOrderByAggregateInput
    _min?: PersonMinOrderByAggregateInput
  }

  export type PersonScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PersonScalarWhereWithAggregatesInput>
    OR?: Enumerable<PersonScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PersonScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    cpf?: StringNullableWithAggregatesFilter | string | null
    rg?: StringNullableWithAggregatesFilter | string | null
    rgss?: StringNullableWithAggregatesFilter | string | null
    birth_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    status?: BoolWithAggregatesFilter | boolean
    privacy?: BoolWithAggregatesFilter | boolean
    avatar?: StringNullableWithAggregatesFilter | string | null
    phone_id?: StringNullableWithAggregatesFilter | string | null
    address_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type AddressPersonWhereInput = {
    AND?: Enumerable<AddressPersonWhereInput>
    OR?: Enumerable<AddressPersonWhereInput>
    NOT?: Enumerable<AddressPersonWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    number?: IntFilter | number
    street?: StringFilter | string
    complement?: StringNullableFilter | string | null
    zip_code?: StringFilter | string
    city?: StringFilter | string
    state?: StringFilter | string
    neighborhood?: StringFilter | string
    person_id?: StringFilter | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    mainAddressPersons?: PersonListRelationFilter
  }

  export type AddressPersonOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    number?: SortOrder
    street?: SortOrder
    complement?: SortOrder
    zip_code?: SortOrder
    city?: SortOrder
    state?: SortOrder
    neighborhood?: SortOrder
    person_id?: SortOrder
    person?: PersonOrderByWithRelationInput
    mainAddressPersons?: PersonOrderByRelationAggregateInput
  }

  export type AddressPersonWhereUniqueInput = {
    id?: string
  }

  export type AddressPersonOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    number?: SortOrder
    street?: SortOrder
    complement?: SortOrder
    zip_code?: SortOrder
    city?: SortOrder
    state?: SortOrder
    neighborhood?: SortOrder
    person_id?: SortOrder
    _count?: AddressPersonCountOrderByAggregateInput
    _avg?: AddressPersonAvgOrderByAggregateInput
    _max?: AddressPersonMaxOrderByAggregateInput
    _min?: AddressPersonMinOrderByAggregateInput
    _sum?: AddressPersonSumOrderByAggregateInput
  }

  export type AddressPersonScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AddressPersonScalarWhereWithAggregatesInput>
    OR?: Enumerable<AddressPersonScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AddressPersonScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    number?: IntWithAggregatesFilter | number
    street?: StringWithAggregatesFilter | string
    complement?: StringNullableWithAggregatesFilter | string | null
    zip_code?: StringWithAggregatesFilter | string
    city?: StringWithAggregatesFilter | string
    state?: StringWithAggregatesFilter | string
    neighborhood?: StringWithAggregatesFilter | string
    person_id?: StringWithAggregatesFilter | string
  }

  export type PhonePersonWhereInput = {
    AND?: Enumerable<PhonePersonWhereInput>
    OR?: Enumerable<PhonePersonWhereInput>
    NOT?: Enumerable<PhonePersonWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    phone?: StringFilter | string
    person_id?: StringFilter | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    mainPhonePersons?: PersonListRelationFilter
  }

  export type PhonePersonOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phone?: SortOrder
    person_id?: SortOrder
    person?: PersonOrderByWithRelationInput
    mainPhonePersons?: PersonOrderByRelationAggregateInput
  }

  export type PhonePersonWhereUniqueInput = {
    id?: string
  }

  export type PhonePersonOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phone?: SortOrder
    person_id?: SortOrder
    _count?: PhonePersonCountOrderByAggregateInput
    _max?: PhonePersonMaxOrderByAggregateInput
    _min?: PhonePersonMinOrderByAggregateInput
  }

  export type PhonePersonScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PhonePersonScalarWhereWithAggregatesInput>
    OR?: Enumerable<PhonePersonScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PhonePersonScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    phone?: StringWithAggregatesFilter | string
    person_id?: StringWithAggregatesFilter | string
  }

  export type GroupWhereInput = {
    AND?: Enumerable<GroupWhereInput>
    OR?: Enumerable<GroupWhereInput>
    NOT?: Enumerable<GroupWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    name?: StringFilter | string
    description?: StringFilter | string
    usersGroups?: UserGroupListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    usersGroups?: UserGroupOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = {
    id?: string
  }

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GroupScalarWhereWithAggregatesInput>
    OR?: Enumerable<GroupScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GroupScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    password?: StringFilter | string
    is_verified?: BoolFilter | boolean
    person_id?: StringFilter | string
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    prices?: PriceListRelationFilter
    orders?: OrderListRelationFilter
    reviews?: ReviewListRelationFilter
    usersGroups?: UserGroupListRelationFilter
    refreshesTokens?: RefresheTokenListRelationFilter
    productsInfo?: ProductInfoListRelationFilter
    OrderProduct?: OrderProductListRelationFilter
    ForgotToken?: ForgotTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    password?: SortOrder
    is_verified?: SortOrder
    person_id?: SortOrder
    person?: PersonOrderByWithRelationInput
    prices?: PriceOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    usersGroups?: UserGroupOrderByRelationAggregateInput
    refreshesTokens?: RefresheTokenOrderByRelationAggregateInput
    productsInfo?: ProductInfoOrderByRelationAggregateInput
    OrderProduct?: OrderProductOrderByRelationAggregateInput
    ForgotToken?: ForgotTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    password?: SortOrder
    is_verified?: SortOrder
    person_id?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    password?: StringWithAggregatesFilter | string
    is_verified?: BoolWithAggregatesFilter | boolean
    person_id?: StringWithAggregatesFilter | string
  }

  export type UserGroupWhereInput = {
    AND?: Enumerable<UserGroupWhereInput>
    OR?: Enumerable<UserGroupWhereInput>
    NOT?: Enumerable<UserGroupWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    group_id?: StringFilter | string
    group?: XOR<GroupRelationFilter, GroupWhereInput>
  }

  export type UserGroupOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    group_id?: SortOrder
    group?: GroupOrderByWithRelationInput
  }

  export type UserGroupWhereUniqueInput = {
    user_id_group_id?: UserGroupUser_idGroup_idCompoundUniqueInput
  }

  export type UserGroupOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    group_id?: SortOrder
    _count?: UserGroupCountOrderByAggregateInput
    _max?: UserGroupMaxOrderByAggregateInput
    _min?: UserGroupMinOrderByAggregateInput
  }

  export type UserGroupScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserGroupScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserGroupScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserGroupScalarWhereWithAggregatesInput>
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    user_id?: StringWithAggregatesFilter | string
    group_id?: StringWithAggregatesFilter | string
  }

  export type RefresheTokenWhereInput = {
    AND?: Enumerable<RefresheTokenWhereInput>
    OR?: Enumerable<RefresheTokenWhereInput>
    NOT?: Enumerable<RefresheTokenWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    refresh_token?: StringFilter | string
    device?: StringFilter | string
    expires_date?: DateTimeFilter | Date | string
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RefresheTokenOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    refresh_token?: SortOrder
    device?: SortOrder
    expires_date?: SortOrder
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefresheTokenWhereUniqueInput = {
    id?: string
  }

  export type RefresheTokenOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    refresh_token?: SortOrder
    device?: SortOrder
    expires_date?: SortOrder
    user_id?: SortOrder
    _count?: RefresheTokenCountOrderByAggregateInput
    _max?: RefresheTokenMaxOrderByAggregateInput
    _min?: RefresheTokenMinOrderByAggregateInput
  }

  export type RefresheTokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RefresheTokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<RefresheTokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RefresheTokenScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    refresh_token?: StringWithAggregatesFilter | string
    device?: StringWithAggregatesFilter | string
    expires_date?: DateTimeWithAggregatesFilter | Date | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type CategoryWhereInput = {
    AND?: Enumerable<CategoryWhereInput>
    OR?: Enumerable<CategoryWhereInput>
    NOT?: Enumerable<CategoryWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    name?: StringFilter | string
    type?: EnumTypeCategoryEnumFilter | TypeCategoryEnum
    slug?: StringNullableFilter | string | null
    description?: StringFilter | string
    photo?: StringNullableFilter | string | null
    products?: CategoryProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    photo?: SortOrder
    products?: CategoryProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    photo?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    type?: EnumTypeCategoryEnumWithAggregatesFilter | TypeCategoryEnum
    slug?: StringNullableWithAggregatesFilter | string | null
    description?: StringWithAggregatesFilter | string
    photo?: StringNullableWithAggregatesFilter | string | null
  }

  export type PoliticWhereInput = {
    AND?: Enumerable<PoliticWhereInput>
    OR?: Enumerable<PoliticWhereInput>
    NOT?: Enumerable<PoliticWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    name?: StringFilter | string
    reading_time?: IntFilter | number
    slug?: StringFilter | string
    description?: StringFilter | string
  }

  export type PoliticOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    reading_time?: SortOrder
    slug?: SortOrder
    description?: SortOrder
  }

  export type PoliticWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type PoliticOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    reading_time?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    _count?: PoliticCountOrderByAggregateInput
    _avg?: PoliticAvgOrderByAggregateInput
    _max?: PoliticMaxOrderByAggregateInput
    _min?: PoliticMinOrderByAggregateInput
    _sum?: PoliticSumOrderByAggregateInput
  }

  export type PoliticScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PoliticScalarWhereWithAggregatesInput>
    OR?: Enumerable<PoliticScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PoliticScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    reading_time?: IntWithAggregatesFilter | number
    slug?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
  }

  export type SubCategoryWhereInput = {
    AND?: Enumerable<SubCategoryWhereInput>
    OR?: Enumerable<SubCategoryWhereInput>
    NOT?: Enumerable<SubCategoryWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    name?: StringFilter | string
    products?: ProductListRelationFilter
  }

  export type SubCategoryOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type SubCategoryWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type SubCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    _count?: SubCategoryCountOrderByAggregateInput
    _max?: SubCategoryMaxOrderByAggregateInput
    _min?: SubCategoryMinOrderByAggregateInput
  }

  export type SubCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubCategoryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
  }

  export type OrderWhereInput = {
    AND?: Enumerable<OrderWhereInput>
    OR?: Enumerable<OrderWhereInput>
    NOT?: Enumerable<OrderWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    total?: DecimalFilter | Decimal | number | string
    freight?: DecimalFilter | Decimal | number | string
    canceled_at?: DateTimeNullableFilter | Date | string | null
    status?: EnumStatusOrderEnumFilter | StatusOrderEnum
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    ordersProducts?: OrderProductListRelationFilter
    transactions?: TransactionListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    total?: SortOrder
    freight?: SortOrder
    canceled_at?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    ordersProducts?: OrderProductOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = {
    id?: string
  }

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    total?: SortOrder
    freight?: SortOrder
    canceled_at?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    total?: DecimalWithAggregatesFilter | Decimal | number | string
    freight?: DecimalWithAggregatesFilter | Decimal | number | string
    canceled_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    status?: EnumStatusOrderEnumWithAggregatesFilter | StatusOrderEnum
    user_id?: StringWithAggregatesFilter | string
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    sku?: StringNullableFilter | string | null
    bar_code?: StringNullableFilter | string | null
    other?: JsonNullableFilter
    canceled_at?: DateTimeNullableFilter | Date | string | null
    status?: BoolFilter | boolean
    status_freight?: BoolFilter | boolean
    status_product?: BoolFilter | boolean
    price_id?: StringNullableFilter | string | null
    price?: XOR<PriceRelationFilter, PriceWhereInput> | null
    description_id?: StringFilter | string
    description?: XOR<DescriptionRelationFilter, DescriptionWhereInput>
    subcategory_id?: StringFilter | string
    subcategory?: XOR<SubCategoryRelationFilter, SubCategoryWhereInput>
    product_info_id?: StringFilter | string
    product_info?: XOR<ProductInfoRelationFilter, ProductInfoWhereInput>
    categories?: CategoryProductListRelationFilter
    photos?: PhotoListRelationFilter
    reviews?: ReviewListRelationFilter
    videos?: VideoListRelationFilter
    stocks?: StockListRelationFilter
    ordersProducts?: OrderProductListRelationFilter
    prices?: PriceListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sku?: SortOrder
    bar_code?: SortOrder
    other?: SortOrder
    canceled_at?: SortOrder
    status?: SortOrder
    status_freight?: SortOrder
    status_product?: SortOrder
    price_id?: SortOrder
    price?: PriceOrderByWithRelationInput
    description_id?: SortOrder
    description?: DescriptionOrderByWithRelationInput
    subcategory_id?: SortOrder
    subcategory?: SubCategoryOrderByWithRelationInput
    product_info_id?: SortOrder
    product_info?: ProductInfoOrderByWithRelationInput
    categories?: CategoryProductOrderByRelationAggregateInput
    photos?: PhotoOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    videos?: VideoOrderByRelationAggregateInput
    stocks?: StockOrderByRelationAggregateInput
    ordersProducts?: OrderProductOrderByRelationAggregateInput
    prices?: PriceOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = {
    id?: string
    price_id?: string
    product_info_id?: string
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sku?: SortOrder
    bar_code?: SortOrder
    other?: SortOrder
    canceled_at?: SortOrder
    status?: SortOrder
    status_freight?: SortOrder
    status_product?: SortOrder
    price_id?: SortOrder
    description_id?: SortOrder
    subcategory_id?: SortOrder
    product_info_id?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    sku?: StringNullableWithAggregatesFilter | string | null
    bar_code?: StringNullableWithAggregatesFilter | string | null
    other?: JsonNullableWithAggregatesFilter
    canceled_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    status?: BoolWithAggregatesFilter | boolean
    status_freight?: BoolWithAggregatesFilter | boolean
    status_product?: BoolWithAggregatesFilter | boolean
    price_id?: StringNullableWithAggregatesFilter | string | null
    description_id?: StringWithAggregatesFilter | string
    subcategory_id?: StringWithAggregatesFilter | string
    product_info_id?: StringWithAggregatesFilter | string
  }

  export type CategoryProductWhereInput = {
    AND?: Enumerable<CategoryProductWhereInput>
    OR?: Enumerable<CategoryProductWhereInput>
    NOT?: Enumerable<CategoryProductWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    category_id?: StringFilter | string
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    product_id?: StringFilter | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type CategoryProductOrderByWithRelationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    category_id?: SortOrder
    category?: CategoryOrderByWithRelationInput
    product_id?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type CategoryProductWhereUniqueInput = {
    category_id_product_id?: CategoryProductCategory_idProduct_idCompoundUniqueInput
  }

  export type CategoryProductOrderByWithAggregationInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    category_id?: SortOrder
    product_id?: SortOrder
    _count?: CategoryProductCountOrderByAggregateInput
    _max?: CategoryProductMaxOrderByAggregateInput
    _min?: CategoryProductMinOrderByAggregateInput
  }

  export type CategoryProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryProductScalarWhereWithAggregatesInput>
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    category_id?: StringWithAggregatesFilter | string
    product_id?: StringWithAggregatesFilter | string
  }

  export type PhotoWhereInput = {
    AND?: Enumerable<PhotoWhereInput>
    OR?: Enumerable<PhotoWhereInput>
    NOT?: Enumerable<PhotoWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    name?: StringFilter | string
    priority?: IntFilter | number
    product_id?: StringFilter | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type PhotoOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    product_id?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type PhotoWhereUniqueInput = {
    id?: string
  }

  export type PhotoOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    product_id?: SortOrder
    _count?: PhotoCountOrderByAggregateInput
    _avg?: PhotoAvgOrderByAggregateInput
    _max?: PhotoMaxOrderByAggregateInput
    _min?: PhotoMinOrderByAggregateInput
    _sum?: PhotoSumOrderByAggregateInput
  }

  export type PhotoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PhotoScalarWhereWithAggregatesInput>
    OR?: Enumerable<PhotoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PhotoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    priority?: IntWithAggregatesFilter | number
    product_id?: StringWithAggregatesFilter | string
  }

  export type PriceWhereInput = {
    AND?: Enumerable<PriceWhereInput>
    OR?: Enumerable<PriceWhereInput>
    NOT?: Enumerable<PriceWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    price?: DecimalFilter | Decimal | number | string
    price_promotion?: DecimalFilter | Decimal | number | string
    product_id?: StringFilter | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    actualProduct?: ProductListRelationFilter
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    OrderProduct?: OrderProductListRelationFilter
  }

  export type PriceOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price?: SortOrder
    price_promotion?: SortOrder
    product_id?: SortOrder
    product?: ProductOrderByWithRelationInput
    actualProduct?: ProductOrderByRelationAggregateInput
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    OrderProduct?: OrderProductOrderByRelationAggregateInput
  }

  export type PriceWhereUniqueInput = {
    id?: string
  }

  export type PriceOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price?: SortOrder
    price_promotion?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
    _count?: PriceCountOrderByAggregateInput
    _avg?: PriceAvgOrderByAggregateInput
    _max?: PriceMaxOrderByAggregateInput
    _min?: PriceMinOrderByAggregateInput
    _sum?: PriceSumOrderByAggregateInput
  }

  export type PriceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PriceScalarWhereWithAggregatesInput>
    OR?: Enumerable<PriceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PriceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    price?: DecimalWithAggregatesFilter | Decimal | number | string
    price_promotion?: DecimalWithAggregatesFilter | Decimal | number | string
    product_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type VideoWhereInput = {
    AND?: Enumerable<VideoWhereInput>
    OR?: Enumerable<VideoWhereInput>
    NOT?: Enumerable<VideoWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    name?: StringFilter | string
    slug?: StringFilter | string
    product_id?: StringFilter | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type VideoOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    product_id?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type VideoWhereUniqueInput = {
    id?: string
  }

  export type VideoOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    product_id?: SortOrder
    _count?: VideoCountOrderByAggregateInput
    _max?: VideoMaxOrderByAggregateInput
    _min?: VideoMinOrderByAggregateInput
  }

  export type VideoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VideoScalarWhereWithAggregatesInput>
    OR?: Enumerable<VideoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VideoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    product_id?: StringWithAggregatesFilter | string
  }

  export type ReviewWhereInput = {
    AND?: Enumerable<ReviewWhereInput>
    OR?: Enumerable<ReviewWhereInput>
    NOT?: Enumerable<ReviewWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    comment?: StringFilter | string
    status?: EnumReviewsStatusEnumFilter | ReviewsStatusEnum
    product_id?: StringFilter | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput> | null
    author_id?: StringNullableFilter | string | null
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    product_id?: SortOrder
    product?: ProductOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    author_id?: SortOrder
  }

  export type ReviewWhereUniqueInput = {
    id?: string
  }

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    product_id?: SortOrder
    author_id?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReviewScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    comment?: StringWithAggregatesFilter | string
    status?: EnumReviewsStatusEnumWithAggregatesFilter | ReviewsStatusEnum
    product_id?: StringWithAggregatesFilter | string
    author_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type CommentWhereInput = {
    AND?: Enumerable<CommentWhereInput>
    OR?: Enumerable<CommentWhereInput>
    NOT?: Enumerable<CommentWhereInput>
    id?: StringFilter | string
    text?: StringFilter | string
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
  }

  export type CommentWhereUniqueInput = {
    id?: string
  }

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    text?: StringWithAggregatesFilter | string
  }

  export type DescriptionWhereInput = {
    AND?: Enumerable<DescriptionWhereInput>
    OR?: Enumerable<DescriptionWhereInput>
    NOT?: Enumerable<DescriptionWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    description?: StringFilter | string
    products?: ProductListRelationFilter
  }

  export type DescriptionOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type DescriptionWhereUniqueInput = {
    id?: string
  }

  export type DescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
    _count?: DescriptionCountOrderByAggregateInput
    _max?: DescriptionMaxOrderByAggregateInput
    _min?: DescriptionMinOrderByAggregateInput
  }

  export type DescriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DescriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<DescriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DescriptionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    description?: StringWithAggregatesFilter | string
  }

  export type BannerWhereInput = {
    AND?: Enumerable<BannerWhereInput>
    OR?: Enumerable<BannerWhereInput>
    NOT?: Enumerable<BannerWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    name?: StringFilter | string
    type?: StringFilter | string
    status?: BoolFilter | boolean
    priority?: IntFilter | number
  }

  export type BannerOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
  }

  export type BannerWhereUniqueInput = {
    id?: string
  }

  export type BannerOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    _count?: BannerCountOrderByAggregateInput
    _avg?: BannerAvgOrderByAggregateInput
    _max?: BannerMaxOrderByAggregateInput
    _min?: BannerMinOrderByAggregateInput
    _sum?: BannerSumOrderByAggregateInput
  }

  export type BannerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BannerScalarWhereWithAggregatesInput>
    OR?: Enumerable<BannerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BannerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    status?: BoolWithAggregatesFilter | boolean
    priority?: IntWithAggregatesFilter | number
  }

  export type StockWhereInput = {
    AND?: Enumerable<StockWhereInput>
    OR?: Enumerable<StockWhereInput>
    NOT?: Enumerable<StockWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    stock?: IntFilter | number
    status?: EnumStocksStatusEnumFilter | StocksStatusEnum
    action?: EnumStockActionEnumFilter | StockActionEnum
    product_id?: StringFilter | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type StockOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stock?: SortOrder
    status?: SortOrder
    action?: SortOrder
    product_id?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type StockWhereUniqueInput = {
    id?: string
  }

  export type StockOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stock?: SortOrder
    status?: SortOrder
    action?: SortOrder
    product_id?: SortOrder
    _count?: StockCountOrderByAggregateInput
    _avg?: StockAvgOrderByAggregateInput
    _max?: StockMaxOrderByAggregateInput
    _min?: StockMinOrderByAggregateInput
    _sum?: StockSumOrderByAggregateInput
  }

  export type StockScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StockScalarWhereWithAggregatesInput>
    OR?: Enumerable<StockScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StockScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    stock?: IntWithAggregatesFilter | number
    status?: EnumStocksStatusEnumWithAggregatesFilter | StocksStatusEnum
    action?: EnumStockActionEnumWithAggregatesFilter | StockActionEnum
    product_id?: StringWithAggregatesFilter | string
  }

  export type OrderProductWhereInput = {
    AND?: Enumerable<OrderProductWhereInput>
    OR?: Enumerable<OrderProductWhereInput>
    NOT?: Enumerable<OrderProductWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    subtotal?: DecimalFilter | Decimal | number | string
    quantity?: IntFilter | number
    status?: EnumStatusOrderEnumFilter | StatusOrderEnum
    order_id?: StringFilter | string
    product_id?: StringFilter | string
    user_id?: StringFilter | string
    price_id?: StringFilter | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    price?: XOR<PriceRelationFilter, PriceWhereInput>
  }

  export type OrderProductOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    subtotal?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
    price_id?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    price?: PriceOrderByWithRelationInput
  }

  export type OrderProductWhereUniqueInput = {
    id?: string
  }

  export type OrderProductOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    subtotal?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
    price_id?: SortOrder
    _count?: OrderProductCountOrderByAggregateInput
    _avg?: OrderProductAvgOrderByAggregateInput
    _max?: OrderProductMaxOrderByAggregateInput
    _min?: OrderProductMinOrderByAggregateInput
    _sum?: OrderProductSumOrderByAggregateInput
  }

  export type OrderProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    subtotal?: DecimalWithAggregatesFilter | Decimal | number | string
    quantity?: IntWithAggregatesFilter | number
    status?: EnumStatusOrderEnumWithAggregatesFilter | StatusOrderEnum
    order_id?: StringWithAggregatesFilter | string
    product_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
    price_id?: StringWithAggregatesFilter | string
  }

  export type TransactionWhereInput = {
    AND?: Enumerable<TransactionWhereInput>
    OR?: Enumerable<TransactionWhereInput>
    NOT?: Enumerable<TransactionWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    transaction_id?: StringFilter | string
    status?: StringFilter | string
    brand?: StringFilter | string
    authorization_code?: StringFilter | string
    authorized_amount?: DecimalFilter | Decimal | number | string
    tid?: StringFilter | string
    installments?: StringFilter | string
    order_id?: StringFilter | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    brand?: SortOrder
    authorization_code?: SortOrder
    authorized_amount?: SortOrder
    tid?: SortOrder
    installments?: SortOrder
    order_id?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = {
    id?: string
  }

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    brand?: SortOrder
    authorization_code?: SortOrder
    authorized_amount?: SortOrder
    tid?: SortOrder
    installments?: SortOrder
    order_id?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    transaction_id?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    brand?: StringWithAggregatesFilter | string
    authorization_code?: StringWithAggregatesFilter | string
    authorized_amount?: DecimalWithAggregatesFilter | Decimal | number | string
    tid?: StringWithAggregatesFilter | string
    installments?: StringWithAggregatesFilter | string
    order_id?: StringWithAggregatesFilter | string
  }

  export type ProductInfoWhereInput = {
    AND?: Enumerable<ProductInfoWhereInput>
    OR?: Enumerable<ProductInfoWhereInput>
    NOT?: Enumerable<ProductInfoWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    price?: DecimalFilter | Decimal | number | string
    price_promotion?: DecimalFilter | Decimal | number | string
    freight?: DecimalFilter | Decimal | number | string
    link?: StringFilter | string
    stock?: IntFilter | number
    company?: StringFilter | string
    currency?: StringFilter | string
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput> | null
  }

  export type ProductInfoOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price?: SortOrder
    price_promotion?: SortOrder
    freight?: SortOrder
    link?: SortOrder
    stock?: SortOrder
    company?: SortOrder
    currency?: SortOrder
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ProductInfoWhereUniqueInput = {
    id?: string
  }

  export type ProductInfoOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price?: SortOrder
    price_promotion?: SortOrder
    freight?: SortOrder
    link?: SortOrder
    stock?: SortOrder
    company?: SortOrder
    currency?: SortOrder
    user_id?: SortOrder
    _count?: ProductInfoCountOrderByAggregateInput
    _avg?: ProductInfoAvgOrderByAggregateInput
    _max?: ProductInfoMaxOrderByAggregateInput
    _min?: ProductInfoMinOrderByAggregateInput
    _sum?: ProductInfoSumOrderByAggregateInput
  }

  export type ProductInfoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductInfoScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductInfoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductInfoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    price?: DecimalWithAggregatesFilter | Decimal | number | string
    price_promotion?: DecimalWithAggregatesFilter | Decimal | number | string
    freight?: DecimalWithAggregatesFilter | Decimal | number | string
    link?: StringWithAggregatesFilter | string
    stock?: IntWithAggregatesFilter | number
    company?: StringWithAggregatesFilter | string
    currency?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type ForgotTokenWhereInput = {
    AND?: Enumerable<ForgotTokenWhereInput>
    OR?: Enumerable<ForgotTokenWhereInput>
    NOT?: Enumerable<ForgotTokenWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    token?: StringFilter | string
    code?: StringFilter | string
    expires_date?: DateTimeFilter | Date | string
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ForgotTokenOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    token?: SortOrder
    code?: SortOrder
    expires_date?: SortOrder
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ForgotTokenWhereUniqueInput = {
    id?: string
  }

  export type ForgotTokenOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    token?: SortOrder
    code?: SortOrder
    expires_date?: SortOrder
    user_id?: SortOrder
    _count?: ForgotTokenCountOrderByAggregateInput
    _max?: ForgotTokenMaxOrderByAggregateInput
    _min?: ForgotTokenMinOrderByAggregateInput
  }

  export type ForgotTokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ForgotTokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<ForgotTokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ForgotTokenScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    token?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    expires_date?: DateTimeWithAggregatesFilter | Date | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type PersonCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    email: string
    cpf?: string | null
    rg?: string | null
    rgss?: string | null
    birth_date?: Date | string | null
    status?: boolean
    privacy?: boolean
    avatar?: string | null
    users?: UserCreateNestedManyWithoutPersonInput
    phone?: PhonePersonCreateNestedOneWithoutMainPhonePersonsInput
    address?: AddressPersonCreateNestedOneWithoutMainAddressPersonsInput
    addresses?: AddressPersonCreateNestedManyWithoutPersonInput
    phones?: PhonePersonCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    email: string
    cpf?: string | null
    rg?: string | null
    rgss?: string | null
    birth_date?: Date | string | null
    status?: boolean
    privacy?: boolean
    avatar?: string | null
    users?: UserUncheckedCreateNestedManyWithoutPersonInput
    phone_id?: string | null
    address_id?: string | null
    addresses?: AddressPersonUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhonePersonUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutPersonInput
    phone?: PhonePersonUpdateOneWithoutMainPhonePersonsInput
    address?: AddressPersonUpdateOneWithoutMainAddressPersonsInput
    addresses?: AddressPersonUpdateManyWithoutPersonInput
    phones?: PhonePersonUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutPersonInput
    phone_id?: NullableStringFieldUpdateOperationsInput | string | null
    address_id?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: AddressPersonUncheckedUpdateManyWithoutPersonInput
    phones?: PhonePersonUncheckedUpdateManyWithoutPersonInput
  }

  export type PersonCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    email: string
    cpf?: string | null
    rg?: string | null
    rgss?: string | null
    birth_date?: Date | string | null
    status?: boolean
    privacy?: boolean
    avatar?: string | null
    phone_id?: string | null
    address_id?: string | null
  }

  export type PersonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone_id?: NullableStringFieldUpdateOperationsInput | string | null
    address_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressPersonCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    number: number
    street: string
    complement?: string | null
    zip_code: string
    city: string
    state: string
    neighborhood: string
    person: PersonCreateNestedOneWithoutAddressesInput
    mainAddressPersons?: PersonCreateNestedManyWithoutAddressInput
  }

  export type AddressPersonUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    number: number
    street: string
    complement?: string | null
    zip_code: string
    city: string
    state: string
    neighborhood: string
    person_id: string
    mainAddressPersons?: PersonUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressPersonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    neighborhood?: StringFieldUpdateOperationsInput | string
    person?: PersonUpdateOneRequiredWithoutAddressesInput
    mainAddressPersons?: PersonUpdateManyWithoutAddressInput
  }

  export type AddressPersonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    neighborhood?: StringFieldUpdateOperationsInput | string
    person_id?: StringFieldUpdateOperationsInput | string
    mainAddressPersons?: PersonUncheckedUpdateManyWithoutAddressInput
  }

  export type AddressPersonCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    number: number
    street: string
    complement?: string | null
    zip_code: string
    city: string
    state: string
    neighborhood: string
    person_id: string
  }

  export type AddressPersonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    neighborhood?: StringFieldUpdateOperationsInput | string
  }

  export type AddressPersonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    neighborhood?: StringFieldUpdateOperationsInput | string
    person_id?: StringFieldUpdateOperationsInput | string
  }

  export type PhonePersonCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    phone: string
    person: PersonCreateNestedOneWithoutPhonesInput
    mainPhonePersons?: PersonCreateNestedManyWithoutPhoneInput
  }

  export type PhonePersonUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    phone: string
    person_id: string
    mainPhonePersons?: PersonUncheckedCreateNestedManyWithoutPhoneInput
  }

  export type PhonePersonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    person?: PersonUpdateOneRequiredWithoutPhonesInput
    mainPhonePersons?: PersonUpdateManyWithoutPhoneInput
  }

  export type PhonePersonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    person_id?: StringFieldUpdateOperationsInput | string
    mainPhonePersons?: PersonUncheckedUpdateManyWithoutPhoneInput
  }

  export type PhonePersonCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    phone: string
    person_id: string
  }

  export type PhonePersonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type PhonePersonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    person_id?: StringFieldUpdateOperationsInput | string
  }

  export type GroupCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
    usersGroups?: UserGroupCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
    usersGroups?: UserGroupUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    usersGroups?: UserGroupUpdateManyWithoutGroupInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    usersGroups?: UserGroupUncheckedUpdateManyWithoutGroupInput
  }

  export type GroupCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person: PersonCreateNestedOneWithoutUsersInput
    prices?: PriceCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person_id: string
    prices?: PriceUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person?: PersonUpdateOneRequiredWithoutUsersInput
    prices?: PriceUpdateManyWithoutUserInput
    orders?: OrderUpdateManyWithoutUserInput
    reviews?: ReviewUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person_id?: StringFieldUpdateOperationsInput | string
    prices?: PriceUncheckedUpdateManyWithoutUserInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    reviews?: ReviewUncheckedUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person_id: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person_id?: StringFieldUpdateOperationsInput | string
  }

  export type UserGroupCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutUsersGroupsInput
    group: GroupCreateNestedOneWithoutUsersGroupsInput
  }

  export type UserGroupUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user_id: string
    group_id: string
  }

  export type UserGroupUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsersGroupsInput
    group?: GroupUpdateOneRequiredWithoutUsersGroupsInput
  }

  export type UserGroupUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
  }

  export type UserGroupCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user_id: string
    group_id: string
  }

  export type UserGroupUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
  }

  export type RefresheTokenCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    refresh_token: string
    device: string
    expires_date: Date | string
    user: UserCreateNestedOneWithoutRefreshesTokensInput
  }

  export type RefresheTokenUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    refresh_token: string
    device: string
    expires_date: Date | string
    user_id: string
  }

  export type RefresheTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    expires_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshesTokensInput
  }

  export type RefresheTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    expires_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type RefresheTokenCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    refresh_token: string
    device: string
    expires_date: Date | string
    user_id: string
  }

  export type RefresheTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    expires_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefresheTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    expires_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    type?: TypeCategoryEnum
    slug?: string | null
    description: string
    photo?: string | null
    products?: CategoryProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    type?: TypeCategoryEnum
    slug?: string | null
    description: string
    photo?: string | null
    products?: CategoryProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryEnumFieldUpdateOperationsInput | TypeCategoryEnum
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    products?: CategoryProductUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryEnumFieldUpdateOperationsInput | TypeCategoryEnum
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    products?: CategoryProductUncheckedUpdateManyWithoutCategoryInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    type?: TypeCategoryEnum
    slug?: string | null
    description: string
    photo?: string | null
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryEnumFieldUpdateOperationsInput | TypeCategoryEnum
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryEnumFieldUpdateOperationsInput | TypeCategoryEnum
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PoliticCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    reading_time: number
    slug: string
    description: string
  }

  export type PoliticUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    reading_time: number
    slug: string
    description: string
  }

  export type PoliticUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    reading_time?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PoliticUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    reading_time?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PoliticCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    reading_time: number
    slug: string
    description: string
  }

  export type PoliticUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    reading_time?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PoliticUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    reading_time?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type SubCategoryCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    products?: ProductCreateNestedManyWithoutSubcategoryInput
  }

  export type SubCategoryUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    products?: ProductUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type SubCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutSubcategoryInput
  }

  export type SubCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutSubcategoryInput
  }

  export type SubCategoryCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
  }

  export type SubCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SubCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OrderCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    total: Decimal | number | string
    freight: Decimal | number | string
    canceled_at?: Date | string | null
    status?: StatusOrderEnum
    user: UserCreateNestedOneWithoutOrdersInput
    ordersProducts?: OrderProductCreateNestedManyWithoutOrderInput
    transactions?: TransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    total: Decimal | number | string
    freight: Decimal | number | string
    canceled_at?: Date | string | null
    status?: StatusOrderEnum
    user_id: string
    ordersProducts?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    user?: UserUpdateOneRequiredWithoutOrdersInput
    ordersProducts?: OrderProductUpdateManyWithoutOrderInput
    transactions?: TransactionUpdateManyWithoutOrderInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    user_id?: StringFieldUpdateOperationsInput | string
    ordersProducts?: OrderProductUncheckedUpdateManyWithoutOrderInput
    transactions?: TransactionUncheckedUpdateManyWithoutOrderInput
  }

  export type OrderCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    total: Decimal | number | string
    freight: Decimal | number | string
    canceled_at?: Date | string | null
    status?: StatusOrderEnum
    user_id: string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price?: PriceCreateNestedOneWithoutActualProductInput
    description: DescriptionCreateNestedOneWithoutProductsInput
    subcategory: SubCategoryCreateNestedOneWithoutProductsInput
    product_info: ProductInfoCreateNestedOneWithoutProductInput
    categories?: CategoryProductCreateNestedManyWithoutProductInput
    photos?: PhotoCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    videos?: VideoCreateNestedManyWithoutProductInput
    stocks?: StockCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductCreateNestedManyWithoutProductInput
    prices?: PriceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price_id?: string | null
    description_id: string
    subcategory_id: string
    product_info_id: string
    categories?: CategoryProductUncheckedCreateNestedManyWithoutProductInput
    photos?: PhotoUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    videos?: VideoUncheckedCreateNestedManyWithoutProductInput
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    prices?: PriceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price?: PriceUpdateOneWithoutActualProductInput
    description?: DescriptionUpdateOneRequiredWithoutProductsInput
    subcategory?: SubCategoryUpdateOneRequiredWithoutProductsInput
    product_info?: ProductInfoUpdateOneRequiredWithoutProductInput
    categories?: CategoryProductUpdateManyWithoutProductInput
    photos?: PhotoUpdateManyWithoutProductInput
    reviews?: ReviewUpdateManyWithoutProductInput
    videos?: VideoUpdateManyWithoutProductInput
    stocks?: StockUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUpdateManyWithoutProductInput
    prices?: PriceUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price_id?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: StringFieldUpdateOperationsInput | string
    subcategory_id?: StringFieldUpdateOperationsInput | string
    product_info_id?: StringFieldUpdateOperationsInput | string
    categories?: CategoryProductUncheckedUpdateManyWithoutProductInput
    photos?: PhotoUncheckedUpdateManyWithoutProductInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductInput
    videos?: VideoUncheckedUpdateManyWithoutProductInput
    stocks?: StockUncheckedUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedUpdateManyWithoutProductInput
    prices?: PriceUncheckedUpdateManyWithoutProductInput
  }

  export type ProductCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price_id?: string | null
    description_id: string
    subcategory_id: string
    product_info_id: string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price_id?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: StringFieldUpdateOperationsInput | string
    subcategory_id?: StringFieldUpdateOperationsInput | string
    product_info_id?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryProductCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    product: ProductCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryProductUncheckedCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    category_id: string
    product_id: string
  }

  export type CategoryProductUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsInput
    product?: ProductUpdateOneRequiredWithoutCategoriesInput
  }

  export type CategoryProductUncheckedUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryProductCreateManyInput = {
    created_at?: Date | string
    updated_at?: Date | string
    category_id: string
    product_id: string
  }

  export type CategoryProductUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryProductUncheckedUpdateManyInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    priority?: number
    product: ProductCreateNestedOneWithoutPhotosInput
  }

  export type PhotoUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    priority?: number
    product_id: string
  }

  export type PhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutPhotosInput
  }

  export type PhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    priority?: number
    product_id: string
  }

  export type PhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type PhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type PriceCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    product: ProductCreateNestedOneWithoutPricesInput
    actualProduct?: ProductCreateNestedManyWithoutPriceInput
    user: UserCreateNestedOneWithoutPricesInput
    OrderProduct?: OrderProductCreateNestedManyWithoutPriceInput
  }

  export type PriceUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    product_id: string
    actualProduct?: ProductUncheckedCreateNestedManyWithoutPriceInput
    user_id: string
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PriceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    product?: ProductUpdateOneRequiredWithoutPricesInput
    actualProduct?: ProductUpdateManyWithoutPriceInput
    user?: UserUpdateOneRequiredWithoutPricesInput
    OrderProduct?: OrderProductUpdateManyWithoutPriceInput
  }

  export type PriceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    product_id?: StringFieldUpdateOperationsInput | string
    actualProduct?: ProductUncheckedUpdateManyWithoutPriceInput
    user_id?: StringFieldUpdateOperationsInput | string
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutPriceInput
  }

  export type PriceCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    product_id: string
    user_id: string
  }

  export type PriceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
  }

  export type PriceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    product_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type VideoCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    slug: string
    product: ProductCreateNestedOneWithoutVideosInput
  }

  export type VideoUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    slug: string
    product_id: string
  }

  export type VideoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutVideosInput
  }

  export type VideoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type VideoCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    slug: string
    product_id: string
  }

  export type VideoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type VideoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    comment: string
    status?: ReviewsStatusEnum
    product: ProductCreateNestedOneWithoutReviewsInput
    author?: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    comment: string
    status?: ReviewsStatusEnum
    product_id: string
    author_id?: string | null
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewsStatusEnumFieldUpdateOperationsInput | ReviewsStatusEnum
    product?: ProductUpdateOneRequiredWithoutReviewsInput
    author?: UserUpdateOneWithoutReviewsInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewsStatusEnumFieldUpdateOperationsInput | ReviewsStatusEnum
    product_id?: StringFieldUpdateOperationsInput | string
    author_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    comment: string
    status?: ReviewsStatusEnum
    product_id: string
    author_id?: string | null
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewsStatusEnumFieldUpdateOperationsInput | ReviewsStatusEnum
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewsStatusEnumFieldUpdateOperationsInput | ReviewsStatusEnum
    product_id?: StringFieldUpdateOperationsInput | string
    author_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateInput = {
    id?: string
    text: string
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    text: string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateManyInput = {
    id?: string
    text: string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type DescriptionCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    products?: ProductCreateNestedManyWithoutDescriptionInput
  }

  export type DescriptionUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    products?: ProductUncheckedCreateNestedManyWithoutDescriptionInput
  }

  export type DescriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutDescriptionInput
  }

  export type DescriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutDescriptionInput
  }

  export type DescriptionCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    description: string
  }

  export type DescriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type DescriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type BannerCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    type: string
    status?: boolean
    priority?: number
  }

  export type BannerUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    type: string
    status?: boolean
    priority?: number
  }

  export type BannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type BannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type BannerCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    type: string
    status?: boolean
    priority?: number
  }

  export type BannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type BannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type StockCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    stock: number
    status?: StocksStatusEnum
    action?: StockActionEnum
    product: ProductCreateNestedOneWithoutStocksInput
  }

  export type StockUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    stock: number
    status?: StocksStatusEnum
    action?: StockActionEnum
    product_id: string
  }

  export type StockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumStocksStatusEnumFieldUpdateOperationsInput | StocksStatusEnum
    action?: EnumStockActionEnumFieldUpdateOperationsInput | StockActionEnum
    product?: ProductUpdateOneRequiredWithoutStocksInput
  }

  export type StockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumStocksStatusEnumFieldUpdateOperationsInput | StocksStatusEnum
    action?: EnumStockActionEnumFieldUpdateOperationsInput | StockActionEnum
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type StockCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    stock: number
    status?: StocksStatusEnum
    action?: StockActionEnum
    product_id: string
  }

  export type StockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumStocksStatusEnumFieldUpdateOperationsInput | StocksStatusEnum
    action?: EnumStockActionEnumFieldUpdateOperationsInput | StockActionEnum
  }

  export type StockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumStocksStatusEnumFieldUpdateOperationsInput | StocksStatusEnum
    action?: EnumStockActionEnumFieldUpdateOperationsInput | StockActionEnum
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type OrderProductCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    subtotal: Decimal | number | string
    quantity: number
    status?: StatusOrderEnum
    order: OrderCreateNestedOneWithoutOrdersProductsInput
    product: ProductCreateNestedOneWithoutOrdersProductsInput
    user: UserCreateNestedOneWithoutOrderProductInput
    price: PriceCreateNestedOneWithoutOrderProductInput
  }

  export type OrderProductUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    subtotal: Decimal | number | string
    quantity: number
    status?: StatusOrderEnum
    order_id: string
    product_id: string
    user_id: string
    price_id: string
  }

  export type OrderProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    order?: OrderUpdateOneRequiredWithoutOrdersProductsInput
    product?: ProductUpdateOneRequiredWithoutOrdersProductsInput
    user?: UserUpdateOneRequiredWithoutOrderProductInput
    price?: PriceUpdateOneRequiredWithoutOrderProductInput
  }

  export type OrderProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    order_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    price_id?: StringFieldUpdateOperationsInput | string
  }

  export type OrderProductCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    subtotal: Decimal | number | string
    quantity: number
    status?: StatusOrderEnum
    order_id: string
    product_id: string
    user_id: string
    price_id: string
  }

  export type OrderProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
  }

  export type OrderProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    order_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    price_id?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    transaction_id: string
    status: string
    brand: string
    authorization_code: string
    authorized_amount: Decimal | number | string
    tid: string
    installments: string
    order: OrderCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    transaction_id: string
    status: string
    brand: string
    authorization_code: string
    authorized_amount: Decimal | number | string
    tid: string
    installments: string
    order_id: string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    authorization_code?: StringFieldUpdateOperationsInput | string
    authorized_amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    tid?: StringFieldUpdateOperationsInput | string
    installments?: StringFieldUpdateOperationsInput | string
    order?: OrderUpdateOneRequiredWithoutTransactionsInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    authorization_code?: StringFieldUpdateOperationsInput | string
    authorized_amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    tid?: StringFieldUpdateOperationsInput | string
    installments?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    transaction_id: string
    status: string
    brand: string
    authorization_code: string
    authorized_amount: Decimal | number | string
    tid: string
    installments: string
    order_id: string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    authorization_code?: StringFieldUpdateOperationsInput | string
    authorized_amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    tid?: StringFieldUpdateOperationsInput | string
    installments?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    authorization_code?: StringFieldUpdateOperationsInput | string
    authorized_amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    tid?: StringFieldUpdateOperationsInput | string
    installments?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
  }

  export type ProductInfoCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    freight: Decimal | number | string
    link: string
    stock: number
    company: string
    currency: string
    user: UserCreateNestedOneWithoutProductsInfoInput
    product?: ProductCreateNestedOneWithoutProduct_infoInput
  }

  export type ProductInfoUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    freight: Decimal | number | string
    link: string
    stock: number
    company: string
    currency: string
    user_id: string
    product?: ProductUncheckedCreateNestedOneWithoutProduct_infoInput
  }

  export type ProductInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    link?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutProductsInfoInput
    product?: ProductUpdateOneWithoutProduct_infoInput
  }

  export type ProductInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    link?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    product?: ProductUncheckedUpdateOneWithoutProduct_infoInput
  }

  export type ProductInfoCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    freight: Decimal | number | string
    link: string
    stock: number
    company: string
    currency: string
    user_id: string
  }

  export type ProductInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    link?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type ProductInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    link?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type ForgotTokenCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    token: string
    code: string
    expires_date: Date | string
    user: UserCreateNestedOneWithoutForgotTokenInput
  }

  export type ForgotTokenUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    token: string
    code: string
    expires_date: Date | string
    user_id: string
  }

  export type ForgotTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutForgotTokenInput
  }

  export type ForgotTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type ForgotTokenCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    token: string
    code: string
    expires_date: Date | string
    user_id: string
  }

  export type ForgotTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForgotTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PhonePersonRelationFilter = {
    is?: PhonePersonWhereInput | null
    isNot?: PhonePersonWhereInput | null
  }

  export type AddressPersonRelationFilter = {
    is?: AddressPersonWhereInput | null
    isNot?: AddressPersonWhereInput | null
  }

  export type AddressPersonListRelationFilter = {
    every?: AddressPersonWhereInput
    some?: AddressPersonWhereInput
    none?: AddressPersonWhereInput
  }

  export type PhonePersonListRelationFilter = {
    every?: PhonePersonWhereInput
    some?: PhonePersonWhereInput
    none?: PhonePersonWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressPersonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhonePersonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
    rgss?: SortOrder
    birth_date?: SortOrder
    status?: SortOrder
    privacy?: SortOrder
    avatar?: SortOrder
    phone_id?: SortOrder
    address_id?: SortOrder
  }

  export type PersonMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
    rgss?: SortOrder
    birth_date?: SortOrder
    status?: SortOrder
    privacy?: SortOrder
    avatar?: SortOrder
    phone_id?: SortOrder
    address_id?: SortOrder
  }

  export type PersonMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
    rgss?: SortOrder
    birth_date?: SortOrder
    status?: SortOrder
    privacy?: SortOrder
    avatar?: SortOrder
    phone_id?: SortOrder
    address_id?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type PersonRelationFilter = {
    is?: PersonWhereInput
    isNot?: PersonWhereInput
  }

  export type PersonListRelationFilter = {
    every?: PersonWhereInput
    some?: PersonWhereInput
    none?: PersonWhereInput
  }

  export type PersonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressPersonCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    number?: SortOrder
    street?: SortOrder
    complement?: SortOrder
    zip_code?: SortOrder
    city?: SortOrder
    state?: SortOrder
    neighborhood?: SortOrder
    person_id?: SortOrder
  }

  export type AddressPersonAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type AddressPersonMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    number?: SortOrder
    street?: SortOrder
    complement?: SortOrder
    zip_code?: SortOrder
    city?: SortOrder
    state?: SortOrder
    neighborhood?: SortOrder
    person_id?: SortOrder
  }

  export type AddressPersonMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    number?: SortOrder
    street?: SortOrder
    complement?: SortOrder
    zip_code?: SortOrder
    city?: SortOrder
    state?: SortOrder
    neighborhood?: SortOrder
    person_id?: SortOrder
  }

  export type AddressPersonSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type PhonePersonCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phone?: SortOrder
    person_id?: SortOrder
  }

  export type PhonePersonMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phone?: SortOrder
    person_id?: SortOrder
  }

  export type PhonePersonMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    phone?: SortOrder
    person_id?: SortOrder
  }

  export type UserGroupListRelationFilter = {
    every?: UserGroupWhereInput
    some?: UserGroupWhereInput
    none?: UserGroupWhereInput
  }

  export type UserGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type PriceListRelationFilter = {
    every?: PriceWhereInput
    some?: PriceWhereInput
    none?: PriceWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type RefresheTokenListRelationFilter = {
    every?: RefresheTokenWhereInput
    some?: RefresheTokenWhereInput
    none?: RefresheTokenWhereInput
  }

  export type ProductInfoListRelationFilter = {
    every?: ProductInfoWhereInput
    some?: ProductInfoWhereInput
    none?: ProductInfoWhereInput
  }

  export type OrderProductListRelationFilter = {
    every?: OrderProductWhereInput
    some?: OrderProductWhereInput
    none?: OrderProductWhereInput
  }

  export type ForgotTokenListRelationFilter = {
    every?: ForgotTokenWhereInput
    some?: ForgotTokenWhereInput
    none?: ForgotTokenWhereInput
  }

  export type PriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefresheTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForgotTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    password?: SortOrder
    is_verified?: SortOrder
    person_id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    password?: SortOrder
    is_verified?: SortOrder
    person_id?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    password?: SortOrder
    is_verified?: SortOrder
    person_id?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type GroupRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type UserGroupUser_idGroup_idCompoundUniqueInput = {
    user_id: string
    group_id: string
  }

  export type UserGroupCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    group_id?: SortOrder
  }

  export type UserGroupMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    group_id?: SortOrder
  }

  export type UserGroupMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    group_id?: SortOrder
  }

  export type RefresheTokenCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    refresh_token?: SortOrder
    device?: SortOrder
    expires_date?: SortOrder
    user_id?: SortOrder
  }

  export type RefresheTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    refresh_token?: SortOrder
    device?: SortOrder
    expires_date?: SortOrder
    user_id?: SortOrder
  }

  export type RefresheTokenMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    refresh_token?: SortOrder
    device?: SortOrder
    expires_date?: SortOrder
    user_id?: SortOrder
  }

  export type EnumTypeCategoryEnumFilter = {
    equals?: TypeCategoryEnum
    in?: Enumerable<TypeCategoryEnum>
    notIn?: Enumerable<TypeCategoryEnum>
    not?: NestedEnumTypeCategoryEnumFilter | TypeCategoryEnum
  }

  export type CategoryProductListRelationFilter = {
    every?: CategoryProductWhereInput
    some?: CategoryProductWhereInput
    none?: CategoryProductWhereInput
  }

  export type CategoryProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    photo?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    photo?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    photo?: SortOrder
  }

  export type EnumTypeCategoryEnumWithAggregatesFilter = {
    equals?: TypeCategoryEnum
    in?: Enumerable<TypeCategoryEnum>
    notIn?: Enumerable<TypeCategoryEnum>
    not?: NestedEnumTypeCategoryEnumWithAggregatesFilter | TypeCategoryEnum
    _count?: NestedIntFilter
    _min?: NestedEnumTypeCategoryEnumFilter
    _max?: NestedEnumTypeCategoryEnumFilter
  }

  export type PoliticCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    reading_time?: SortOrder
    slug?: SortOrder
    description?: SortOrder
  }

  export type PoliticAvgOrderByAggregateInput = {
    reading_time?: SortOrder
  }

  export type PoliticMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    reading_time?: SortOrder
    slug?: SortOrder
    description?: SortOrder
  }

  export type PoliticMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    reading_time?: SortOrder
    slug?: SortOrder
    description?: SortOrder
  }

  export type PoliticSumOrderByAggregateInput = {
    reading_time?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
  }

  export type SubCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
  }

  export type SubCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
  }

  export type DecimalFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalFilter | Decimal | number | string
  }

  export type EnumStatusOrderEnumFilter = {
    equals?: StatusOrderEnum
    in?: Enumerable<StatusOrderEnum>
    notIn?: Enumerable<StatusOrderEnum>
    not?: NestedEnumStatusOrderEnumFilter | StatusOrderEnum
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    total?: SortOrder
    freight?: SortOrder
    canceled_at?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    total?: SortOrder
    freight?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    total?: SortOrder
    freight?: SortOrder
    canceled_at?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    total?: SortOrder
    freight?: SortOrder
    canceled_at?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    total?: SortOrder
    freight?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type EnumStatusOrderEnumWithAggregatesFilter = {
    equals?: StatusOrderEnum
    in?: Enumerable<StatusOrderEnum>
    notIn?: Enumerable<StatusOrderEnum>
    not?: NestedEnumStatusOrderEnumWithAggregatesFilter | StatusOrderEnum
    _count?: NestedIntFilter
    _min?: NestedEnumStatusOrderEnumFilter
    _max?: NestedEnumStatusOrderEnumFilter
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type PriceRelationFilter = {
    is?: PriceWhereInput | null
    isNot?: PriceWhereInput | null
  }

  export type DescriptionRelationFilter = {
    is?: DescriptionWhereInput
    isNot?: DescriptionWhereInput
  }

  export type SubCategoryRelationFilter = {
    is?: SubCategoryWhereInput
    isNot?: SubCategoryWhereInput
  }

  export type ProductInfoRelationFilter = {
    is?: ProductInfoWhereInput
    isNot?: ProductInfoWhereInput
  }

  export type PhotoListRelationFilter = {
    every?: PhotoWhereInput
    some?: PhotoWhereInput
    none?: PhotoWhereInput
  }

  export type VideoListRelationFilter = {
    every?: VideoWhereInput
    some?: VideoWhereInput
    none?: VideoWhereInput
  }

  export type StockListRelationFilter = {
    every?: StockWhereInput
    some?: StockWhereInput
    none?: StockWhereInput
  }

  export type PhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sku?: SortOrder
    bar_code?: SortOrder
    other?: SortOrder
    canceled_at?: SortOrder
    status?: SortOrder
    status_freight?: SortOrder
    status_product?: SortOrder
    price_id?: SortOrder
    description_id?: SortOrder
    subcategory_id?: SortOrder
    product_info_id?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sku?: SortOrder
    bar_code?: SortOrder
    canceled_at?: SortOrder
    status?: SortOrder
    status_freight?: SortOrder
    status_product?: SortOrder
    price_id?: SortOrder
    description_id?: SortOrder
    subcategory_id?: SortOrder
    product_info_id?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sku?: SortOrder
    bar_code?: SortOrder
    canceled_at?: SortOrder
    status?: SortOrder
    status_freight?: SortOrder
    status_product?: SortOrder
    price_id?: SortOrder
    description_id?: SortOrder
    subcategory_id?: SortOrder
    product_info_id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type CategoryProductCategory_idProduct_idCompoundUniqueInput = {
    category_id: string
    product_id: string
  }

  export type CategoryProductCountOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    category_id?: SortOrder
    product_id?: SortOrder
  }

  export type CategoryProductMaxOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    category_id?: SortOrder
    product_id?: SortOrder
  }

  export type CategoryProductMinOrderByAggregateInput = {
    created_at?: SortOrder
    updated_at?: SortOrder
    category_id?: SortOrder
    product_id?: SortOrder
  }

  export type PhotoCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    product_id?: SortOrder
  }

  export type PhotoAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type PhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    product_id?: SortOrder
  }

  export type PhotoMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    product_id?: SortOrder
  }

  export type PhotoSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type PriceCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price?: SortOrder
    price_promotion?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
  }

  export type PriceAvgOrderByAggregateInput = {
    price?: SortOrder
    price_promotion?: SortOrder
  }

  export type PriceMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price?: SortOrder
    price_promotion?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
  }

  export type PriceMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price?: SortOrder
    price_promotion?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
  }

  export type PriceSumOrderByAggregateInput = {
    price?: SortOrder
    price_promotion?: SortOrder
  }

  export type VideoCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    product_id?: SortOrder
  }

  export type VideoMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    product_id?: SortOrder
  }

  export type VideoMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    product_id?: SortOrder
  }

  export type EnumReviewsStatusEnumFilter = {
    equals?: ReviewsStatusEnum
    in?: Enumerable<ReviewsStatusEnum>
    notIn?: Enumerable<ReviewsStatusEnum>
    not?: NestedEnumReviewsStatusEnumFilter | ReviewsStatusEnum
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    product_id?: SortOrder
    author_id?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    product_id?: SortOrder
    author_id?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    product_id?: SortOrder
    author_id?: SortOrder
  }

  export type EnumReviewsStatusEnumWithAggregatesFilter = {
    equals?: ReviewsStatusEnum
    in?: Enumerable<ReviewsStatusEnum>
    notIn?: Enumerable<ReviewsStatusEnum>
    not?: NestedEnumReviewsStatusEnumWithAggregatesFilter | ReviewsStatusEnum
    _count?: NestedIntFilter
    _min?: NestedEnumReviewsStatusEnumFilter
    _max?: NestedEnumReviewsStatusEnumFilter
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
  }

  export type DescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
  }

  export type DescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
  }

  export type DescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
  }

  export type BannerCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
  }

  export type BannerAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type BannerMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
  }

  export type BannerMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
  }

  export type BannerSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type EnumStocksStatusEnumFilter = {
    equals?: StocksStatusEnum
    in?: Enumerable<StocksStatusEnum>
    notIn?: Enumerable<StocksStatusEnum>
    not?: NestedEnumStocksStatusEnumFilter | StocksStatusEnum
  }

  export type EnumStockActionEnumFilter = {
    equals?: StockActionEnum
    in?: Enumerable<StockActionEnum>
    notIn?: Enumerable<StockActionEnum>
    not?: NestedEnumStockActionEnumFilter | StockActionEnum
  }

  export type StockCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stock?: SortOrder
    status?: SortOrder
    action?: SortOrder
    product_id?: SortOrder
  }

  export type StockAvgOrderByAggregateInput = {
    stock?: SortOrder
  }

  export type StockMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stock?: SortOrder
    status?: SortOrder
    action?: SortOrder
    product_id?: SortOrder
  }

  export type StockMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stock?: SortOrder
    status?: SortOrder
    action?: SortOrder
    product_id?: SortOrder
  }

  export type StockSumOrderByAggregateInput = {
    stock?: SortOrder
  }

  export type EnumStocksStatusEnumWithAggregatesFilter = {
    equals?: StocksStatusEnum
    in?: Enumerable<StocksStatusEnum>
    notIn?: Enumerable<StocksStatusEnum>
    not?: NestedEnumStocksStatusEnumWithAggregatesFilter | StocksStatusEnum
    _count?: NestedIntFilter
    _min?: NestedEnumStocksStatusEnumFilter
    _max?: NestedEnumStocksStatusEnumFilter
  }

  export type EnumStockActionEnumWithAggregatesFilter = {
    equals?: StockActionEnum
    in?: Enumerable<StockActionEnum>
    notIn?: Enumerable<StockActionEnum>
    not?: NestedEnumStockActionEnumWithAggregatesFilter | StockActionEnum
    _count?: NestedIntFilter
    _min?: NestedEnumStockActionEnumFilter
    _max?: NestedEnumStockActionEnumFilter
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderProductCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    subtotal?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
    price_id?: SortOrder
  }

  export type OrderProductAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    quantity?: SortOrder
  }

  export type OrderProductMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    subtotal?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
    price_id?: SortOrder
  }

  export type OrderProductMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    subtotal?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
    user_id?: SortOrder
    price_id?: SortOrder
  }

  export type OrderProductSumOrderByAggregateInput = {
    subtotal?: SortOrder
    quantity?: SortOrder
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    brand?: SortOrder
    authorization_code?: SortOrder
    authorized_amount?: SortOrder
    tid?: SortOrder
    installments?: SortOrder
    order_id?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    authorized_amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    brand?: SortOrder
    authorization_code?: SortOrder
    authorized_amount?: SortOrder
    tid?: SortOrder
    installments?: SortOrder
    order_id?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    brand?: SortOrder
    authorization_code?: SortOrder
    authorized_amount?: SortOrder
    tid?: SortOrder
    installments?: SortOrder
    order_id?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    authorized_amount?: SortOrder
  }

  export type ProductInfoCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price?: SortOrder
    price_promotion?: SortOrder
    freight?: SortOrder
    link?: SortOrder
    stock?: SortOrder
    company?: SortOrder
    currency?: SortOrder
    user_id?: SortOrder
  }

  export type ProductInfoAvgOrderByAggregateInput = {
    price?: SortOrder
    price_promotion?: SortOrder
    freight?: SortOrder
    stock?: SortOrder
  }

  export type ProductInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price?: SortOrder
    price_promotion?: SortOrder
    freight?: SortOrder
    link?: SortOrder
    stock?: SortOrder
    company?: SortOrder
    currency?: SortOrder
    user_id?: SortOrder
  }

  export type ProductInfoMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price?: SortOrder
    price_promotion?: SortOrder
    freight?: SortOrder
    link?: SortOrder
    stock?: SortOrder
    company?: SortOrder
    currency?: SortOrder
    user_id?: SortOrder
  }

  export type ProductInfoSumOrderByAggregateInput = {
    price?: SortOrder
    price_promotion?: SortOrder
    freight?: SortOrder
    stock?: SortOrder
  }

  export type ForgotTokenCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    token?: SortOrder
    code?: SortOrder
    expires_date?: SortOrder
    user_id?: SortOrder
  }

  export type ForgotTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    token?: SortOrder
    code?: SortOrder
    expires_date?: SortOrder
    user_id?: SortOrder
  }

  export type ForgotTokenMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    token?: SortOrder
    code?: SortOrder
    expires_date?: SortOrder
    user_id?: SortOrder
  }

  export type UserCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<UserCreateWithoutPersonInput>, Enumerable<UserUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutPersonInput>
    createMany?: UserCreateManyPersonInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type PhonePersonCreateNestedOneWithoutMainPhonePersonsInput = {
    create?: XOR<PhonePersonCreateWithoutMainPhonePersonsInput, PhonePersonUncheckedCreateWithoutMainPhonePersonsInput>
    connectOrCreate?: PhonePersonCreateOrConnectWithoutMainPhonePersonsInput
    connect?: PhonePersonWhereUniqueInput
  }

  export type AddressPersonCreateNestedOneWithoutMainAddressPersonsInput = {
    create?: XOR<AddressPersonCreateWithoutMainAddressPersonsInput, AddressPersonUncheckedCreateWithoutMainAddressPersonsInput>
    connectOrCreate?: AddressPersonCreateOrConnectWithoutMainAddressPersonsInput
    connect?: AddressPersonWhereUniqueInput
  }

  export type AddressPersonCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<AddressPersonCreateWithoutPersonInput>, Enumerable<AddressPersonUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<AddressPersonCreateOrConnectWithoutPersonInput>
    createMany?: AddressPersonCreateManyPersonInputEnvelope
    connect?: Enumerable<AddressPersonWhereUniqueInput>
  }

  export type PhonePersonCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<PhonePersonCreateWithoutPersonInput>, Enumerable<PhonePersonUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<PhonePersonCreateOrConnectWithoutPersonInput>
    createMany?: PhonePersonCreateManyPersonInputEnvelope
    connect?: Enumerable<PhonePersonWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<UserCreateWithoutPersonInput>, Enumerable<UserUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutPersonInput>
    createMany?: UserCreateManyPersonInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type AddressPersonUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<AddressPersonCreateWithoutPersonInput>, Enumerable<AddressPersonUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<AddressPersonCreateOrConnectWithoutPersonInput>
    createMany?: AddressPersonCreateManyPersonInputEnvelope
    connect?: Enumerable<AddressPersonWhereUniqueInput>
  }

  export type PhonePersonUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<PhonePersonCreateWithoutPersonInput>, Enumerable<PhonePersonUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<PhonePersonCreateOrConnectWithoutPersonInput>
    createMany?: PhonePersonCreateManyPersonInputEnvelope
    connect?: Enumerable<PhonePersonWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<UserCreateWithoutPersonInput>, Enumerable<UserUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: UserCreateManyPersonInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type PhonePersonUpdateOneWithoutMainPhonePersonsInput = {
    create?: XOR<PhonePersonCreateWithoutMainPhonePersonsInput, PhonePersonUncheckedCreateWithoutMainPhonePersonsInput>
    connectOrCreate?: PhonePersonCreateOrConnectWithoutMainPhonePersonsInput
    upsert?: PhonePersonUpsertWithoutMainPhonePersonsInput
    disconnect?: boolean
    delete?: boolean
    connect?: PhonePersonWhereUniqueInput
    update?: XOR<PhonePersonUpdateWithoutMainPhonePersonsInput, PhonePersonUncheckedUpdateWithoutMainPhonePersonsInput>
  }

  export type AddressPersonUpdateOneWithoutMainAddressPersonsInput = {
    create?: XOR<AddressPersonCreateWithoutMainAddressPersonsInput, AddressPersonUncheckedCreateWithoutMainAddressPersonsInput>
    connectOrCreate?: AddressPersonCreateOrConnectWithoutMainAddressPersonsInput
    upsert?: AddressPersonUpsertWithoutMainAddressPersonsInput
    disconnect?: boolean
    delete?: boolean
    connect?: AddressPersonWhereUniqueInput
    update?: XOR<AddressPersonUpdateWithoutMainAddressPersonsInput, AddressPersonUncheckedUpdateWithoutMainAddressPersonsInput>
  }

  export type AddressPersonUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<AddressPersonCreateWithoutPersonInput>, Enumerable<AddressPersonUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<AddressPersonCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<AddressPersonUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: AddressPersonCreateManyPersonInputEnvelope
    set?: Enumerable<AddressPersonWhereUniqueInput>
    disconnect?: Enumerable<AddressPersonWhereUniqueInput>
    delete?: Enumerable<AddressPersonWhereUniqueInput>
    connect?: Enumerable<AddressPersonWhereUniqueInput>
    update?: Enumerable<AddressPersonUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<AddressPersonUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<AddressPersonScalarWhereInput>
  }

  export type PhonePersonUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<PhonePersonCreateWithoutPersonInput>, Enumerable<PhonePersonUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<PhonePersonCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<PhonePersonUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: PhonePersonCreateManyPersonInputEnvelope
    set?: Enumerable<PhonePersonWhereUniqueInput>
    disconnect?: Enumerable<PhonePersonWhereUniqueInput>
    delete?: Enumerable<PhonePersonWhereUniqueInput>
    connect?: Enumerable<PhonePersonWhereUniqueInput>
    update?: Enumerable<PhonePersonUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<PhonePersonUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<PhonePersonScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<UserCreateWithoutPersonInput>, Enumerable<UserUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: UserCreateManyPersonInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type AddressPersonUncheckedUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<AddressPersonCreateWithoutPersonInput>, Enumerable<AddressPersonUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<AddressPersonCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<AddressPersonUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: AddressPersonCreateManyPersonInputEnvelope
    set?: Enumerable<AddressPersonWhereUniqueInput>
    disconnect?: Enumerable<AddressPersonWhereUniqueInput>
    delete?: Enumerable<AddressPersonWhereUniqueInput>
    connect?: Enumerable<AddressPersonWhereUniqueInput>
    update?: Enumerable<AddressPersonUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<AddressPersonUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<AddressPersonScalarWhereInput>
  }

  export type PhonePersonUncheckedUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<PhonePersonCreateWithoutPersonInput>, Enumerable<PhonePersonUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<PhonePersonCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<PhonePersonUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: PhonePersonCreateManyPersonInputEnvelope
    set?: Enumerable<PhonePersonWhereUniqueInput>
    disconnect?: Enumerable<PhonePersonWhereUniqueInput>
    delete?: Enumerable<PhonePersonWhereUniqueInput>
    connect?: Enumerable<PhonePersonWhereUniqueInput>
    update?: Enumerable<PhonePersonUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<PhonePersonUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<PhonePersonScalarWhereInput>
  }

  export type PersonCreateNestedOneWithoutAddressesInput = {
    create?: XOR<PersonCreateWithoutAddressesInput, PersonUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutAddressesInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<PersonCreateWithoutAddressInput>, Enumerable<PersonUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<PersonCreateOrConnectWithoutAddressInput>
    createMany?: PersonCreateManyAddressInputEnvelope
    connect?: Enumerable<PersonWhereUniqueInput>
  }

  export type PersonUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<PersonCreateWithoutAddressInput>, Enumerable<PersonUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<PersonCreateOrConnectWithoutAddressInput>
    createMany?: PersonCreateManyAddressInputEnvelope
    connect?: Enumerable<PersonWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PersonUpdateOneRequiredWithoutAddressesInput = {
    create?: XOR<PersonCreateWithoutAddressesInput, PersonUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutAddressesInput
    upsert?: PersonUpsertWithoutAddressesInput
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutAddressesInput, PersonUncheckedUpdateWithoutAddressesInput>
  }

  export type PersonUpdateManyWithoutAddressInput = {
    create?: XOR<Enumerable<PersonCreateWithoutAddressInput>, Enumerable<PersonUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<PersonCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<PersonUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: PersonCreateManyAddressInputEnvelope
    set?: Enumerable<PersonWhereUniqueInput>
    disconnect?: Enumerable<PersonWhereUniqueInput>
    delete?: Enumerable<PersonWhereUniqueInput>
    connect?: Enumerable<PersonWhereUniqueInput>
    update?: Enumerable<PersonUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<PersonUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<PersonScalarWhereInput>
  }

  export type PersonUncheckedUpdateManyWithoutAddressInput = {
    create?: XOR<Enumerable<PersonCreateWithoutAddressInput>, Enumerable<PersonUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<PersonCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<PersonUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: PersonCreateManyAddressInputEnvelope
    set?: Enumerable<PersonWhereUniqueInput>
    disconnect?: Enumerable<PersonWhereUniqueInput>
    delete?: Enumerable<PersonWhereUniqueInput>
    connect?: Enumerable<PersonWhereUniqueInput>
    update?: Enumerable<PersonUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<PersonUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<PersonScalarWhereInput>
  }

  export type PersonCreateNestedOneWithoutPhonesInput = {
    create?: XOR<PersonCreateWithoutPhonesInput, PersonUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutPhonesInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonCreateNestedManyWithoutPhoneInput = {
    create?: XOR<Enumerable<PersonCreateWithoutPhoneInput>, Enumerable<PersonUncheckedCreateWithoutPhoneInput>>
    connectOrCreate?: Enumerable<PersonCreateOrConnectWithoutPhoneInput>
    createMany?: PersonCreateManyPhoneInputEnvelope
    connect?: Enumerable<PersonWhereUniqueInput>
  }

  export type PersonUncheckedCreateNestedManyWithoutPhoneInput = {
    create?: XOR<Enumerable<PersonCreateWithoutPhoneInput>, Enumerable<PersonUncheckedCreateWithoutPhoneInput>>
    connectOrCreate?: Enumerable<PersonCreateOrConnectWithoutPhoneInput>
    createMany?: PersonCreateManyPhoneInputEnvelope
    connect?: Enumerable<PersonWhereUniqueInput>
  }

  export type PersonUpdateOneRequiredWithoutPhonesInput = {
    create?: XOR<PersonCreateWithoutPhonesInput, PersonUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutPhonesInput
    upsert?: PersonUpsertWithoutPhonesInput
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutPhonesInput, PersonUncheckedUpdateWithoutPhonesInput>
  }

  export type PersonUpdateManyWithoutPhoneInput = {
    create?: XOR<Enumerable<PersonCreateWithoutPhoneInput>, Enumerable<PersonUncheckedCreateWithoutPhoneInput>>
    connectOrCreate?: Enumerable<PersonCreateOrConnectWithoutPhoneInput>
    upsert?: Enumerable<PersonUpsertWithWhereUniqueWithoutPhoneInput>
    createMany?: PersonCreateManyPhoneInputEnvelope
    set?: Enumerable<PersonWhereUniqueInput>
    disconnect?: Enumerable<PersonWhereUniqueInput>
    delete?: Enumerable<PersonWhereUniqueInput>
    connect?: Enumerable<PersonWhereUniqueInput>
    update?: Enumerable<PersonUpdateWithWhereUniqueWithoutPhoneInput>
    updateMany?: Enumerable<PersonUpdateManyWithWhereWithoutPhoneInput>
    deleteMany?: Enumerable<PersonScalarWhereInput>
  }

  export type PersonUncheckedUpdateManyWithoutPhoneInput = {
    create?: XOR<Enumerable<PersonCreateWithoutPhoneInput>, Enumerable<PersonUncheckedCreateWithoutPhoneInput>>
    connectOrCreate?: Enumerable<PersonCreateOrConnectWithoutPhoneInput>
    upsert?: Enumerable<PersonUpsertWithWhereUniqueWithoutPhoneInput>
    createMany?: PersonCreateManyPhoneInputEnvelope
    set?: Enumerable<PersonWhereUniqueInput>
    disconnect?: Enumerable<PersonWhereUniqueInput>
    delete?: Enumerable<PersonWhereUniqueInput>
    connect?: Enumerable<PersonWhereUniqueInput>
    update?: Enumerable<PersonUpdateWithWhereUniqueWithoutPhoneInput>
    updateMany?: Enumerable<PersonUpdateManyWithWhereWithoutPhoneInput>
    deleteMany?: Enumerable<PersonScalarWhereInput>
  }

  export type UserGroupCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<UserGroupCreateWithoutGroupInput>, Enumerable<UserGroupUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<UserGroupCreateOrConnectWithoutGroupInput>
    createMany?: UserGroupCreateManyGroupInputEnvelope
    connect?: Enumerable<UserGroupWhereUniqueInput>
  }

  export type UserGroupUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<UserGroupCreateWithoutGroupInput>, Enumerable<UserGroupUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<UserGroupCreateOrConnectWithoutGroupInput>
    createMany?: UserGroupCreateManyGroupInputEnvelope
    connect?: Enumerable<UserGroupWhereUniqueInput>
  }

  export type UserGroupUpdateManyWithoutGroupInput = {
    create?: XOR<Enumerable<UserGroupCreateWithoutGroupInput>, Enumerable<UserGroupUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<UserGroupCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<UserGroupUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: UserGroupCreateManyGroupInputEnvelope
    set?: Enumerable<UserGroupWhereUniqueInput>
    disconnect?: Enumerable<UserGroupWhereUniqueInput>
    delete?: Enumerable<UserGroupWhereUniqueInput>
    connect?: Enumerable<UserGroupWhereUniqueInput>
    update?: Enumerable<UserGroupUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<UserGroupUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<UserGroupScalarWhereInput>
  }

  export type UserGroupUncheckedUpdateManyWithoutGroupInput = {
    create?: XOR<Enumerable<UserGroupCreateWithoutGroupInput>, Enumerable<UserGroupUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<UserGroupCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<UserGroupUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: UserGroupCreateManyGroupInputEnvelope
    set?: Enumerable<UserGroupWhereUniqueInput>
    disconnect?: Enumerable<UserGroupWhereUniqueInput>
    delete?: Enumerable<UserGroupWhereUniqueInput>
    connect?: Enumerable<UserGroupWhereUniqueInput>
    update?: Enumerable<UserGroupUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<UserGroupUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<UserGroupScalarWhereInput>
  }

  export type PersonCreateNestedOneWithoutUsersInput = {
    create?: XOR<PersonCreateWithoutUsersInput, PersonUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PersonCreateOrConnectWithoutUsersInput
    connect?: PersonWhereUniqueInput
  }

  export type PriceCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PriceCreateWithoutUserInput>, Enumerable<PriceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutUserInput>
    createMany?: PriceCreateManyUserInputEnvelope
    connect?: Enumerable<PriceWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type ReviewCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutAuthorInput>, Enumerable<ReviewUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutAuthorInput>
    createMany?: ReviewCreateManyAuthorInputEnvelope
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type UserGroupCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserGroupCreateWithoutUserInput>, Enumerable<UserGroupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserGroupCreateOrConnectWithoutUserInput>
    createMany?: UserGroupCreateManyUserInputEnvelope
    connect?: Enumerable<UserGroupWhereUniqueInput>
  }

  export type RefresheTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RefresheTokenCreateWithoutUserInput>, Enumerable<RefresheTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RefresheTokenCreateOrConnectWithoutUserInput>
    createMany?: RefresheTokenCreateManyUserInputEnvelope
    connect?: Enumerable<RefresheTokenWhereUniqueInput>
  }

  export type ProductInfoCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductInfoCreateWithoutUserInput>, Enumerable<ProductInfoUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductInfoCreateOrConnectWithoutUserInput>
    createMany?: ProductInfoCreateManyUserInputEnvelope
    connect?: Enumerable<ProductInfoWhereUniqueInput>
  }

  export type OrderProductCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutUserInput>, Enumerable<OrderProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutUserInput>
    createMany?: OrderProductCreateManyUserInputEnvelope
    connect?: Enumerable<OrderProductWhereUniqueInput>
  }

  export type ForgotTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ForgotTokenCreateWithoutUserInput>, Enumerable<ForgotTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ForgotTokenCreateOrConnectWithoutUserInput>
    createMany?: ForgotTokenCreateManyUserInputEnvelope
    connect?: Enumerable<ForgotTokenWhereUniqueInput>
  }

  export type PriceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PriceCreateWithoutUserInput>, Enumerable<PriceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutUserInput>
    createMany?: PriceCreateManyUserInputEnvelope
    connect?: Enumerable<PriceWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type ReviewUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutAuthorInput>, Enumerable<ReviewUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutAuthorInput>
    createMany?: ReviewCreateManyAuthorInputEnvelope
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type UserGroupUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserGroupCreateWithoutUserInput>, Enumerable<UserGroupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserGroupCreateOrConnectWithoutUserInput>
    createMany?: UserGroupCreateManyUserInputEnvelope
    connect?: Enumerable<UserGroupWhereUniqueInput>
  }

  export type RefresheTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RefresheTokenCreateWithoutUserInput>, Enumerable<RefresheTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RefresheTokenCreateOrConnectWithoutUserInput>
    createMany?: RefresheTokenCreateManyUserInputEnvelope
    connect?: Enumerable<RefresheTokenWhereUniqueInput>
  }

  export type ProductInfoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductInfoCreateWithoutUserInput>, Enumerable<ProductInfoUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductInfoCreateOrConnectWithoutUserInput>
    createMany?: ProductInfoCreateManyUserInputEnvelope
    connect?: Enumerable<ProductInfoWhereUniqueInput>
  }

  export type OrderProductUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutUserInput>, Enumerable<OrderProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutUserInput>
    createMany?: OrderProductCreateManyUserInputEnvelope
    connect?: Enumerable<OrderProductWhereUniqueInput>
  }

  export type ForgotTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ForgotTokenCreateWithoutUserInput>, Enumerable<ForgotTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ForgotTokenCreateOrConnectWithoutUserInput>
    createMany?: ForgotTokenCreateManyUserInputEnvelope
    connect?: Enumerable<ForgotTokenWhereUniqueInput>
  }

  export type PersonUpdateOneRequiredWithoutUsersInput = {
    create?: XOR<PersonCreateWithoutUsersInput, PersonUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PersonCreateOrConnectWithoutUsersInput
    upsert?: PersonUpsertWithoutUsersInput
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutUsersInput, PersonUncheckedUpdateWithoutUsersInput>
  }

  export type PriceUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<PriceCreateWithoutUserInput>, Enumerable<PriceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PriceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PriceCreateManyUserInputEnvelope
    set?: Enumerable<PriceWhereUniqueInput>
    disconnect?: Enumerable<PriceWhereUniqueInput>
    delete?: Enumerable<PriceWhereUniqueInput>
    connect?: Enumerable<PriceWhereUniqueInput>
    update?: Enumerable<PriceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PriceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PriceScalarWhereInput>
  }

  export type OrderUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type ReviewUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutAuthorInput>, Enumerable<ReviewUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ReviewCreateManyAuthorInputEnvelope
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type UserGroupUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserGroupCreateWithoutUserInput>, Enumerable<UserGroupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserGroupCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserGroupUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserGroupCreateManyUserInputEnvelope
    set?: Enumerable<UserGroupWhereUniqueInput>
    disconnect?: Enumerable<UserGroupWhereUniqueInput>
    delete?: Enumerable<UserGroupWhereUniqueInput>
    connect?: Enumerable<UserGroupWhereUniqueInput>
    update?: Enumerable<UserGroupUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserGroupUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserGroupScalarWhereInput>
  }

  export type RefresheTokenUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<RefresheTokenCreateWithoutUserInput>, Enumerable<RefresheTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RefresheTokenCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RefresheTokenUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RefresheTokenCreateManyUserInputEnvelope
    set?: Enumerable<RefresheTokenWhereUniqueInput>
    disconnect?: Enumerable<RefresheTokenWhereUniqueInput>
    delete?: Enumerable<RefresheTokenWhereUniqueInput>
    connect?: Enumerable<RefresheTokenWhereUniqueInput>
    update?: Enumerable<RefresheTokenUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RefresheTokenUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RefresheTokenScalarWhereInput>
  }

  export type ProductInfoUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductInfoCreateWithoutUserInput>, Enumerable<ProductInfoUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductInfoCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProductInfoUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProductInfoCreateManyUserInputEnvelope
    set?: Enumerable<ProductInfoWhereUniqueInput>
    disconnect?: Enumerable<ProductInfoWhereUniqueInput>
    delete?: Enumerable<ProductInfoWhereUniqueInput>
    connect?: Enumerable<ProductInfoWhereUniqueInput>
    update?: Enumerable<ProductInfoUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProductInfoUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProductInfoScalarWhereInput>
  }

  export type OrderProductUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutUserInput>, Enumerable<OrderProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrderProductUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrderProductCreateManyUserInputEnvelope
    set?: Enumerable<OrderProductWhereUniqueInput>
    disconnect?: Enumerable<OrderProductWhereUniqueInput>
    delete?: Enumerable<OrderProductWhereUniqueInput>
    connect?: Enumerable<OrderProductWhereUniqueInput>
    update?: Enumerable<OrderProductUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrderProductUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrderProductScalarWhereInput>
  }

  export type ForgotTokenUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ForgotTokenCreateWithoutUserInput>, Enumerable<ForgotTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ForgotTokenCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ForgotTokenUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ForgotTokenCreateManyUserInputEnvelope
    set?: Enumerable<ForgotTokenWhereUniqueInput>
    disconnect?: Enumerable<ForgotTokenWhereUniqueInput>
    delete?: Enumerable<ForgotTokenWhereUniqueInput>
    connect?: Enumerable<ForgotTokenWhereUniqueInput>
    update?: Enumerable<ForgotTokenUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ForgotTokenUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ForgotTokenScalarWhereInput>
  }

  export type PriceUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<PriceCreateWithoutUserInput>, Enumerable<PriceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PriceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PriceCreateManyUserInputEnvelope
    set?: Enumerable<PriceWhereUniqueInput>
    disconnect?: Enumerable<PriceWhereUniqueInput>
    delete?: Enumerable<PriceWhereUniqueInput>
    connect?: Enumerable<PriceWhereUniqueInput>
    update?: Enumerable<PriceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PriceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PriceScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type ReviewUncheckedUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutAuthorInput>, Enumerable<ReviewUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ReviewCreateManyAuthorInputEnvelope
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type UserGroupUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserGroupCreateWithoutUserInput>, Enumerable<UserGroupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserGroupCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserGroupUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserGroupCreateManyUserInputEnvelope
    set?: Enumerable<UserGroupWhereUniqueInput>
    disconnect?: Enumerable<UserGroupWhereUniqueInput>
    delete?: Enumerable<UserGroupWhereUniqueInput>
    connect?: Enumerable<UserGroupWhereUniqueInput>
    update?: Enumerable<UserGroupUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserGroupUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserGroupScalarWhereInput>
  }

  export type RefresheTokenUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<RefresheTokenCreateWithoutUserInput>, Enumerable<RefresheTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RefresheTokenCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RefresheTokenUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RefresheTokenCreateManyUserInputEnvelope
    set?: Enumerable<RefresheTokenWhereUniqueInput>
    disconnect?: Enumerable<RefresheTokenWhereUniqueInput>
    delete?: Enumerable<RefresheTokenWhereUniqueInput>
    connect?: Enumerable<RefresheTokenWhereUniqueInput>
    update?: Enumerable<RefresheTokenUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RefresheTokenUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RefresheTokenScalarWhereInput>
  }

  export type ProductInfoUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductInfoCreateWithoutUserInput>, Enumerable<ProductInfoUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductInfoCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProductInfoUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProductInfoCreateManyUserInputEnvelope
    set?: Enumerable<ProductInfoWhereUniqueInput>
    disconnect?: Enumerable<ProductInfoWhereUniqueInput>
    delete?: Enumerable<ProductInfoWhereUniqueInput>
    connect?: Enumerable<ProductInfoWhereUniqueInput>
    update?: Enumerable<ProductInfoUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProductInfoUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProductInfoScalarWhereInput>
  }

  export type OrderProductUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutUserInput>, Enumerable<OrderProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrderProductUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrderProductCreateManyUserInputEnvelope
    set?: Enumerable<OrderProductWhereUniqueInput>
    disconnect?: Enumerable<OrderProductWhereUniqueInput>
    delete?: Enumerable<OrderProductWhereUniqueInput>
    connect?: Enumerable<OrderProductWhereUniqueInput>
    update?: Enumerable<OrderProductUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrderProductUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrderProductScalarWhereInput>
  }

  export type ForgotTokenUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ForgotTokenCreateWithoutUserInput>, Enumerable<ForgotTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ForgotTokenCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ForgotTokenUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ForgotTokenCreateManyUserInputEnvelope
    set?: Enumerable<ForgotTokenWhereUniqueInput>
    disconnect?: Enumerable<ForgotTokenWhereUniqueInput>
    delete?: Enumerable<ForgotTokenWhereUniqueInput>
    connect?: Enumerable<ForgotTokenWhereUniqueInput>
    update?: Enumerable<ForgotTokenUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ForgotTokenUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ForgotTokenScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutUsersGroupsInput = {
    create?: XOR<UserCreateWithoutUsersGroupsInput, UserUncheckedCreateWithoutUsersGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsersGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutUsersGroupsInput = {
    create?: XOR<GroupCreateWithoutUsersGroupsInput, GroupUncheckedCreateWithoutUsersGroupsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutUsersGroupsInput
    connect?: GroupWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUsersGroupsInput = {
    create?: XOR<UserCreateWithoutUsersGroupsInput, UserUncheckedCreateWithoutUsersGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsersGroupsInput
    upsert?: UserUpsertWithoutUsersGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUsersGroupsInput, UserUncheckedUpdateWithoutUsersGroupsInput>
  }

  export type GroupUpdateOneRequiredWithoutUsersGroupsInput = {
    create?: XOR<GroupCreateWithoutUsersGroupsInput, GroupUncheckedCreateWithoutUsersGroupsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutUsersGroupsInput
    upsert?: GroupUpsertWithoutUsersGroupsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<GroupUpdateWithoutUsersGroupsInput, GroupUncheckedUpdateWithoutUsersGroupsInput>
  }

  export type UserCreateNestedOneWithoutRefreshesTokensInput = {
    create?: XOR<UserCreateWithoutRefreshesTokensInput, UserUncheckedCreateWithoutRefreshesTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshesTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshesTokensInput = {
    create?: XOR<UserCreateWithoutRefreshesTokensInput, UserUncheckedCreateWithoutRefreshesTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshesTokensInput
    upsert?: UserUpsertWithoutRefreshesTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRefreshesTokensInput, UserUncheckedUpdateWithoutRefreshesTokensInput>
  }

  export type CategoryProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<CategoryProductCreateWithoutCategoryInput>, Enumerable<CategoryProductUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<CategoryProductCreateOrConnectWithoutCategoryInput>
    createMany?: CategoryProductCreateManyCategoryInputEnvelope
    connect?: Enumerable<CategoryProductWhereUniqueInput>
  }

  export type CategoryProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<CategoryProductCreateWithoutCategoryInput>, Enumerable<CategoryProductUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<CategoryProductCreateOrConnectWithoutCategoryInput>
    createMany?: CategoryProductCreateManyCategoryInputEnvelope
    connect?: Enumerable<CategoryProductWhereUniqueInput>
  }

  export type EnumTypeCategoryEnumFieldUpdateOperationsInput = {
    set?: TypeCategoryEnum
  }

  export type CategoryProductUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<CategoryProductCreateWithoutCategoryInput>, Enumerable<CategoryProductUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<CategoryProductCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<CategoryProductUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: CategoryProductCreateManyCategoryInputEnvelope
    set?: Enumerable<CategoryProductWhereUniqueInput>
    disconnect?: Enumerable<CategoryProductWhereUniqueInput>
    delete?: Enumerable<CategoryProductWhereUniqueInput>
    connect?: Enumerable<CategoryProductWhereUniqueInput>
    update?: Enumerable<CategoryProductUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<CategoryProductUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<CategoryProductScalarWhereInput>
  }

  export type CategoryProductUncheckedUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<CategoryProductCreateWithoutCategoryInput>, Enumerable<CategoryProductUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<CategoryProductCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<CategoryProductUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: CategoryProductCreateManyCategoryInputEnvelope
    set?: Enumerable<CategoryProductWhereUniqueInput>
    disconnect?: Enumerable<CategoryProductWhereUniqueInput>
    delete?: Enumerable<CategoryProductWhereUniqueInput>
    connect?: Enumerable<CategoryProductWhereUniqueInput>
    update?: Enumerable<CategoryProductUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<CategoryProductUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<CategoryProductScalarWhereInput>
  }

  export type ProductCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<Enumerable<ProductCreateWithoutSubcategoryInput>, Enumerable<ProductUncheckedCreateWithoutSubcategoryInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutSubcategoryInput>
    createMany?: ProductCreateManySubcategoryInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<Enumerable<ProductCreateWithoutSubcategoryInput>, Enumerable<ProductUncheckedCreateWithoutSubcategoryInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutSubcategoryInput>
    createMany?: ProductCreateManySubcategoryInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUpdateManyWithoutSubcategoryInput = {
    create?: XOR<Enumerable<ProductCreateWithoutSubcategoryInput>, Enumerable<ProductUncheckedCreateWithoutSubcategoryInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutSubcategoryInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutSubcategoryInput>
    createMany?: ProductCreateManySubcategoryInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutSubcategoryInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutSubcategoryInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutSubcategoryInput = {
    create?: XOR<Enumerable<ProductCreateWithoutSubcategoryInput>, Enumerable<ProductUncheckedCreateWithoutSubcategoryInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutSubcategoryInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutSubcategoryInput>
    createMany?: ProductCreateManySubcategoryInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutSubcategoryInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutSubcategoryInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type OrderProductCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutOrderInput>, Enumerable<OrderProductUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutOrderInput>
    createMany?: OrderProductCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderProductWhereUniqueInput>
  }

  export type TransactionCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutOrderInput>, Enumerable<TransactionUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutOrderInput>
    createMany?: TransactionCreateManyOrderInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type OrderProductUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutOrderInput>, Enumerable<OrderProductUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutOrderInput>
    createMany?: OrderProductCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderProductWhereUniqueInput>
  }

  export type TransactionUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutOrderInput>, Enumerable<TransactionUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutOrderInput>
    createMany?: TransactionCreateManyOrderInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | number | string
    increment?: Decimal | number | string
    decrement?: Decimal | number | string
    multiply?: Decimal | number | string
    divide?: Decimal | number | string
  }

  export type EnumStatusOrderEnumFieldUpdateOperationsInput = {
    set?: StatusOrderEnum
  }

  export type UserUpdateOneRequiredWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderProductUpdateManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutOrderInput>, Enumerable<OrderProductUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<OrderProductUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: OrderProductCreateManyOrderInputEnvelope
    set?: Enumerable<OrderProductWhereUniqueInput>
    disconnect?: Enumerable<OrderProductWhereUniqueInput>
    delete?: Enumerable<OrderProductWhereUniqueInput>
    connect?: Enumerable<OrderProductWhereUniqueInput>
    update?: Enumerable<OrderProductUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<OrderProductUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<OrderProductScalarWhereInput>
  }

  export type TransactionUpdateManyWithoutOrderInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutOrderInput>, Enumerable<TransactionUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: TransactionCreateManyOrderInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type OrderProductUncheckedUpdateManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutOrderInput>, Enumerable<OrderProductUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<OrderProductUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: OrderProductCreateManyOrderInputEnvelope
    set?: Enumerable<OrderProductWhereUniqueInput>
    disconnect?: Enumerable<OrderProductWhereUniqueInput>
    delete?: Enumerable<OrderProductWhereUniqueInput>
    connect?: Enumerable<OrderProductWhereUniqueInput>
    update?: Enumerable<OrderProductUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<OrderProductUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<OrderProductScalarWhereInput>
  }

  export type TransactionUncheckedUpdateManyWithoutOrderInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutOrderInput>, Enumerable<TransactionUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: TransactionCreateManyOrderInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type PriceCreateNestedOneWithoutActualProductInput = {
    create?: XOR<PriceCreateWithoutActualProductInput, PriceUncheckedCreateWithoutActualProductInput>
    connectOrCreate?: PriceCreateOrConnectWithoutActualProductInput
    connect?: PriceWhereUniqueInput
  }

  export type DescriptionCreateNestedOneWithoutProductsInput = {
    create?: XOR<DescriptionCreateWithoutProductsInput, DescriptionUncheckedCreateWithoutProductsInput>
    connectOrCreate?: DescriptionCreateOrConnectWithoutProductsInput
    connect?: DescriptionWhereUniqueInput
  }

  export type SubCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<SubCategoryCreateWithoutProductsInput, SubCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SubCategoryCreateOrConnectWithoutProductsInput
    connect?: SubCategoryWhereUniqueInput
  }

  export type ProductInfoCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductInfoCreateWithoutProductInput, ProductInfoUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductInfoCreateOrConnectWithoutProductInput
    connect?: ProductInfoWhereUniqueInput
  }

  export type CategoryProductCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<CategoryProductCreateWithoutProductInput>, Enumerable<CategoryProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CategoryProductCreateOrConnectWithoutProductInput>
    createMany?: CategoryProductCreateManyProductInputEnvelope
    connect?: Enumerable<CategoryProductWhereUniqueInput>
  }

  export type PhotoCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PhotoCreateWithoutProductInput>, Enumerable<PhotoUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PhotoCreateOrConnectWithoutProductInput>
    createMany?: PhotoCreateManyProductInputEnvelope
    connect?: Enumerable<PhotoWhereUniqueInput>
  }

  export type ReviewCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutProductInput>, Enumerable<ReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutProductInput>
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type VideoCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<VideoCreateWithoutProductInput>, Enumerable<VideoUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutProductInput>
    createMany?: VideoCreateManyProductInputEnvelope
    connect?: Enumerable<VideoWhereUniqueInput>
  }

  export type StockCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<StockCreateWithoutProductInput>, Enumerable<StockUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<StockCreateOrConnectWithoutProductInput>
    createMany?: StockCreateManyProductInputEnvelope
    connect?: Enumerable<StockWhereUniqueInput>
  }

  export type OrderProductCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutProductInput>, Enumerable<OrderProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutProductInput>
    createMany?: OrderProductCreateManyProductInputEnvelope
    connect?: Enumerable<OrderProductWhereUniqueInput>
  }

  export type PriceCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PriceCreateWithoutProductInput>, Enumerable<PriceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutProductInput>
    createMany?: PriceCreateManyProductInputEnvelope
    connect?: Enumerable<PriceWhereUniqueInput>
  }

  export type CategoryProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<CategoryProductCreateWithoutProductInput>, Enumerable<CategoryProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CategoryProductCreateOrConnectWithoutProductInput>
    createMany?: CategoryProductCreateManyProductInputEnvelope
    connect?: Enumerable<CategoryProductWhereUniqueInput>
  }

  export type PhotoUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PhotoCreateWithoutProductInput>, Enumerable<PhotoUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PhotoCreateOrConnectWithoutProductInput>
    createMany?: PhotoCreateManyProductInputEnvelope
    connect?: Enumerable<PhotoWhereUniqueInput>
  }

  export type ReviewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutProductInput>, Enumerable<ReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutProductInput>
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type VideoUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<VideoCreateWithoutProductInput>, Enumerable<VideoUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutProductInput>
    createMany?: VideoCreateManyProductInputEnvelope
    connect?: Enumerable<VideoWhereUniqueInput>
  }

  export type StockUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<StockCreateWithoutProductInput>, Enumerable<StockUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<StockCreateOrConnectWithoutProductInput>
    createMany?: StockCreateManyProductInputEnvelope
    connect?: Enumerable<StockWhereUniqueInput>
  }

  export type OrderProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutProductInput>, Enumerable<OrderProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutProductInput>
    createMany?: OrderProductCreateManyProductInputEnvelope
    connect?: Enumerable<OrderProductWhereUniqueInput>
  }

  export type PriceUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PriceCreateWithoutProductInput>, Enumerable<PriceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutProductInput>
    createMany?: PriceCreateManyProductInputEnvelope
    connect?: Enumerable<PriceWhereUniqueInput>
  }

  export type PriceUpdateOneWithoutActualProductInput = {
    create?: XOR<PriceCreateWithoutActualProductInput, PriceUncheckedCreateWithoutActualProductInput>
    connectOrCreate?: PriceCreateOrConnectWithoutActualProductInput
    upsert?: PriceUpsertWithoutActualProductInput
    disconnect?: boolean
    delete?: boolean
    connect?: PriceWhereUniqueInput
    update?: XOR<PriceUpdateWithoutActualProductInput, PriceUncheckedUpdateWithoutActualProductInput>
  }

  export type DescriptionUpdateOneRequiredWithoutProductsInput = {
    create?: XOR<DescriptionCreateWithoutProductsInput, DescriptionUncheckedCreateWithoutProductsInput>
    connectOrCreate?: DescriptionCreateOrConnectWithoutProductsInput
    upsert?: DescriptionUpsertWithoutProductsInput
    connect?: DescriptionWhereUniqueInput
    update?: XOR<DescriptionUpdateWithoutProductsInput, DescriptionUncheckedUpdateWithoutProductsInput>
  }

  export type SubCategoryUpdateOneRequiredWithoutProductsInput = {
    create?: XOR<SubCategoryCreateWithoutProductsInput, SubCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SubCategoryCreateOrConnectWithoutProductsInput
    upsert?: SubCategoryUpsertWithoutProductsInput
    connect?: SubCategoryWhereUniqueInput
    update?: XOR<SubCategoryUpdateWithoutProductsInput, SubCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductInfoUpdateOneRequiredWithoutProductInput = {
    create?: XOR<ProductInfoCreateWithoutProductInput, ProductInfoUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductInfoCreateOrConnectWithoutProductInput
    upsert?: ProductInfoUpsertWithoutProductInput
    connect?: ProductInfoWhereUniqueInput
    update?: XOR<ProductInfoUpdateWithoutProductInput, ProductInfoUncheckedUpdateWithoutProductInput>
  }

  export type CategoryProductUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<CategoryProductCreateWithoutProductInput>, Enumerable<CategoryProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CategoryProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<CategoryProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: CategoryProductCreateManyProductInputEnvelope
    set?: Enumerable<CategoryProductWhereUniqueInput>
    disconnect?: Enumerable<CategoryProductWhereUniqueInput>
    delete?: Enumerable<CategoryProductWhereUniqueInput>
    connect?: Enumerable<CategoryProductWhereUniqueInput>
    update?: Enumerable<CategoryProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<CategoryProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<CategoryProductScalarWhereInput>
  }

  export type PhotoUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<PhotoCreateWithoutProductInput>, Enumerable<PhotoUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PhotoCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PhotoUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PhotoCreateManyProductInputEnvelope
    set?: Enumerable<PhotoWhereUniqueInput>
    disconnect?: Enumerable<PhotoWhereUniqueInput>
    delete?: Enumerable<PhotoWhereUniqueInput>
    connect?: Enumerable<PhotoWhereUniqueInput>
    update?: Enumerable<PhotoUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PhotoUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PhotoScalarWhereInput>
  }

  export type ReviewUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutProductInput>, Enumerable<ReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type VideoUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<VideoCreateWithoutProductInput>, Enumerable<VideoUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<VideoUpsertWithWhereUniqueWithoutProductInput>
    createMany?: VideoCreateManyProductInputEnvelope
    set?: Enumerable<VideoWhereUniqueInput>
    disconnect?: Enumerable<VideoWhereUniqueInput>
    delete?: Enumerable<VideoWhereUniqueInput>
    connect?: Enumerable<VideoWhereUniqueInput>
    update?: Enumerable<VideoUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<VideoUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<VideoScalarWhereInput>
  }

  export type StockUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<StockCreateWithoutProductInput>, Enumerable<StockUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<StockCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<StockUpsertWithWhereUniqueWithoutProductInput>
    createMany?: StockCreateManyProductInputEnvelope
    set?: Enumerable<StockWhereUniqueInput>
    disconnect?: Enumerable<StockWhereUniqueInput>
    delete?: Enumerable<StockWhereUniqueInput>
    connect?: Enumerable<StockWhereUniqueInput>
    update?: Enumerable<StockUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<StockUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<StockScalarWhereInput>
  }

  export type OrderProductUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutProductInput>, Enumerable<OrderProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<OrderProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: OrderProductCreateManyProductInputEnvelope
    set?: Enumerable<OrderProductWhereUniqueInput>
    disconnect?: Enumerable<OrderProductWhereUniqueInput>
    delete?: Enumerable<OrderProductWhereUniqueInput>
    connect?: Enumerable<OrderProductWhereUniqueInput>
    update?: Enumerable<OrderProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<OrderProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<OrderProductScalarWhereInput>
  }

  export type PriceUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<PriceCreateWithoutProductInput>, Enumerable<PriceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PriceUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PriceCreateManyProductInputEnvelope
    set?: Enumerable<PriceWhereUniqueInput>
    disconnect?: Enumerable<PriceWhereUniqueInput>
    delete?: Enumerable<PriceWhereUniqueInput>
    connect?: Enumerable<PriceWhereUniqueInput>
    update?: Enumerable<PriceUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PriceUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PriceScalarWhereInput>
  }

  export type CategoryProductUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<CategoryProductCreateWithoutProductInput>, Enumerable<CategoryProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CategoryProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<CategoryProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: CategoryProductCreateManyProductInputEnvelope
    set?: Enumerable<CategoryProductWhereUniqueInput>
    disconnect?: Enumerable<CategoryProductWhereUniqueInput>
    delete?: Enumerable<CategoryProductWhereUniqueInput>
    connect?: Enumerable<CategoryProductWhereUniqueInput>
    update?: Enumerable<CategoryProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<CategoryProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<CategoryProductScalarWhereInput>
  }

  export type PhotoUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<PhotoCreateWithoutProductInput>, Enumerable<PhotoUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PhotoCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PhotoUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PhotoCreateManyProductInputEnvelope
    set?: Enumerable<PhotoWhereUniqueInput>
    disconnect?: Enumerable<PhotoWhereUniqueInput>
    delete?: Enumerable<PhotoWhereUniqueInput>
    connect?: Enumerable<PhotoWhereUniqueInput>
    update?: Enumerable<PhotoUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PhotoUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PhotoScalarWhereInput>
  }

  export type ReviewUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutProductInput>, Enumerable<ReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type VideoUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<VideoCreateWithoutProductInput>, Enumerable<VideoUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<VideoCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<VideoUpsertWithWhereUniqueWithoutProductInput>
    createMany?: VideoCreateManyProductInputEnvelope
    set?: Enumerable<VideoWhereUniqueInput>
    disconnect?: Enumerable<VideoWhereUniqueInput>
    delete?: Enumerable<VideoWhereUniqueInput>
    connect?: Enumerable<VideoWhereUniqueInput>
    update?: Enumerable<VideoUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<VideoUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<VideoScalarWhereInput>
  }

  export type StockUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<StockCreateWithoutProductInput>, Enumerable<StockUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<StockCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<StockUpsertWithWhereUniqueWithoutProductInput>
    createMany?: StockCreateManyProductInputEnvelope
    set?: Enumerable<StockWhereUniqueInput>
    disconnect?: Enumerable<StockWhereUniqueInput>
    delete?: Enumerable<StockWhereUniqueInput>
    connect?: Enumerable<StockWhereUniqueInput>
    update?: Enumerable<StockUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<StockUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<StockScalarWhereInput>
  }

  export type OrderProductUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutProductInput>, Enumerable<OrderProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<OrderProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: OrderProductCreateManyProductInputEnvelope
    set?: Enumerable<OrderProductWhereUniqueInput>
    disconnect?: Enumerable<OrderProductWhereUniqueInput>
    delete?: Enumerable<OrderProductWhereUniqueInput>
    connect?: Enumerable<OrderProductWhereUniqueInput>
    update?: Enumerable<OrderProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<OrderProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<OrderProductScalarWhereInput>
  }

  export type PriceUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<PriceCreateWithoutProductInput>, Enumerable<PriceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PriceCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PriceUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PriceCreateManyProductInputEnvelope
    set?: Enumerable<PriceWhereUniqueInput>
    disconnect?: Enumerable<PriceWhereUniqueInput>
    delete?: Enumerable<PriceWhereUniqueInput>
    connect?: Enumerable<PriceWhereUniqueInput>
    update?: Enumerable<PriceUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PriceUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PriceScalarWhereInput>
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput
    connect?: ProductWhereUniqueInput
  }

  export type CategoryUpdateOneRequiredWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutCategoriesInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput
    upsert?: ProductUpsertWithoutCategoriesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductCreateNestedOneWithoutPhotosInput = {
    create?: XOR<ProductCreateWithoutPhotosInput, ProductUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPhotosInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutPhotosInput = {
    create?: XOR<ProductCreateWithoutPhotosInput, ProductUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPhotosInput
    upsert?: ProductUpsertWithoutPhotosInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutPhotosInput, ProductUncheckedUpdateWithoutPhotosInput>
  }

  export type ProductCreateNestedOneWithoutPricesInput = {
    create?: XOR<ProductCreateWithoutPricesInput, ProductUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPricesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutPriceInput = {
    create?: XOR<Enumerable<ProductCreateWithoutPriceInput>, Enumerable<ProductUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutPriceInput>
    createMany?: ProductCreateManyPriceInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutPricesInput = {
    create?: XOR<UserCreateWithoutPricesInput, UserUncheckedCreateWithoutPricesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPricesInput
    connect?: UserWhereUniqueInput
  }

  export type OrderProductCreateNestedManyWithoutPriceInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutPriceInput>, Enumerable<OrderProductUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutPriceInput>
    createMany?: OrderProductCreateManyPriceInputEnvelope
    connect?: Enumerable<OrderProductWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutPriceInput = {
    create?: XOR<Enumerable<ProductCreateWithoutPriceInput>, Enumerable<ProductUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutPriceInput>
    createMany?: ProductCreateManyPriceInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type OrderProductUncheckedCreateNestedManyWithoutPriceInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutPriceInput>, Enumerable<OrderProductUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutPriceInput>
    createMany?: OrderProductCreateManyPriceInputEnvelope
    connect?: Enumerable<OrderProductWhereUniqueInput>
  }

  export type ProductUpdateOneRequiredWithoutPricesInput = {
    create?: XOR<ProductCreateWithoutPricesInput, ProductUncheckedCreateWithoutPricesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPricesInput
    upsert?: ProductUpsertWithoutPricesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutPricesInput, ProductUncheckedUpdateWithoutPricesInput>
  }

  export type ProductUpdateManyWithoutPriceInput = {
    create?: XOR<Enumerable<ProductCreateWithoutPriceInput>, Enumerable<ProductUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutPriceInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutPriceInput>
    createMany?: ProductCreateManyPriceInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutPriceInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutPriceInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutPricesInput = {
    create?: XOR<UserCreateWithoutPricesInput, UserUncheckedCreateWithoutPricesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPricesInput
    upsert?: UserUpsertWithoutPricesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPricesInput, UserUncheckedUpdateWithoutPricesInput>
  }

  export type OrderProductUpdateManyWithoutPriceInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutPriceInput>, Enumerable<OrderProductUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutPriceInput>
    upsert?: Enumerable<OrderProductUpsertWithWhereUniqueWithoutPriceInput>
    createMany?: OrderProductCreateManyPriceInputEnvelope
    set?: Enumerable<OrderProductWhereUniqueInput>
    disconnect?: Enumerable<OrderProductWhereUniqueInput>
    delete?: Enumerable<OrderProductWhereUniqueInput>
    connect?: Enumerable<OrderProductWhereUniqueInput>
    update?: Enumerable<OrderProductUpdateWithWhereUniqueWithoutPriceInput>
    updateMany?: Enumerable<OrderProductUpdateManyWithWhereWithoutPriceInput>
    deleteMany?: Enumerable<OrderProductScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutPriceInput = {
    create?: XOR<Enumerable<ProductCreateWithoutPriceInput>, Enumerable<ProductUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutPriceInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutPriceInput>
    createMany?: ProductCreateManyPriceInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutPriceInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutPriceInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type OrderProductUncheckedUpdateManyWithoutPriceInput = {
    create?: XOR<Enumerable<OrderProductCreateWithoutPriceInput>, Enumerable<OrderProductUncheckedCreateWithoutPriceInput>>
    connectOrCreate?: Enumerable<OrderProductCreateOrConnectWithoutPriceInput>
    upsert?: Enumerable<OrderProductUpsertWithWhereUniqueWithoutPriceInput>
    createMany?: OrderProductCreateManyPriceInputEnvelope
    set?: Enumerable<OrderProductWhereUniqueInput>
    disconnect?: Enumerable<OrderProductWhereUniqueInput>
    delete?: Enumerable<OrderProductWhereUniqueInput>
    connect?: Enumerable<OrderProductWhereUniqueInput>
    update?: Enumerable<OrderProductUpdateWithWhereUniqueWithoutPriceInput>
    updateMany?: Enumerable<OrderProductUpdateManyWithWhereWithoutPriceInput>
    deleteMany?: Enumerable<OrderProductScalarWhereInput>
  }

  export type ProductCreateNestedOneWithoutVideosInput = {
    create?: XOR<ProductCreateWithoutVideosInput, ProductUncheckedCreateWithoutVideosInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVideosInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutVideosInput = {
    create?: XOR<ProductCreateWithoutVideosInput, ProductUncheckedCreateWithoutVideosInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVideosInput
    upsert?: ProductUpsertWithoutVideosInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutVideosInput, ProductUncheckedUpdateWithoutVideosInput>
  }

  export type ProductCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReviewsStatusEnumFieldUpdateOperationsInput = {
    set?: ReviewsStatusEnum
  }

  export type ProductUpdateOneRequiredWithoutReviewsInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    upsert?: ProductUpsertWithoutReviewsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type ProductCreateNestedManyWithoutDescriptionInput = {
    create?: XOR<Enumerable<ProductCreateWithoutDescriptionInput>, Enumerable<ProductUncheckedCreateWithoutDescriptionInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutDescriptionInput>
    createMany?: ProductCreateManyDescriptionInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutDescriptionInput = {
    create?: XOR<Enumerable<ProductCreateWithoutDescriptionInput>, Enumerable<ProductUncheckedCreateWithoutDescriptionInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutDescriptionInput>
    createMany?: ProductCreateManyDescriptionInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUpdateManyWithoutDescriptionInput = {
    create?: XOR<Enumerable<ProductCreateWithoutDescriptionInput>, Enumerable<ProductUncheckedCreateWithoutDescriptionInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutDescriptionInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutDescriptionInput>
    createMany?: ProductCreateManyDescriptionInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutDescriptionInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutDescriptionInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutDescriptionInput = {
    create?: XOR<Enumerable<ProductCreateWithoutDescriptionInput>, Enumerable<ProductUncheckedCreateWithoutDescriptionInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutDescriptionInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutDescriptionInput>
    createMany?: ProductCreateManyDescriptionInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutDescriptionInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutDescriptionInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductCreateNestedOneWithoutStocksInput = {
    create?: XOR<ProductCreateWithoutStocksInput, ProductUncheckedCreateWithoutStocksInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStocksInput
    connect?: ProductWhereUniqueInput
  }

  export type EnumStocksStatusEnumFieldUpdateOperationsInput = {
    set?: StocksStatusEnum
  }

  export type EnumStockActionEnumFieldUpdateOperationsInput = {
    set?: StockActionEnum
  }

  export type ProductUpdateOneRequiredWithoutStocksInput = {
    create?: XOR<ProductCreateWithoutStocksInput, ProductUncheckedCreateWithoutStocksInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStocksInput
    upsert?: ProductUpsertWithoutStocksInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutStocksInput, ProductUncheckedUpdateWithoutStocksInput>
  }

  export type OrderCreateNestedOneWithoutOrdersProductsInput = {
    create?: XOR<OrderCreateWithoutOrdersProductsInput, OrderUncheckedCreateWithoutOrdersProductsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrdersProductsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrdersProductsInput = {
    create?: XOR<ProductCreateWithoutOrdersProductsInput, ProductUncheckedCreateWithoutOrdersProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrderProductInput = {
    create?: XOR<UserCreateWithoutOrderProductInput, UserUncheckedCreateWithoutOrderProductInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderProductInput
    connect?: UserWhereUniqueInput
  }

  export type PriceCreateNestedOneWithoutOrderProductInput = {
    create?: XOR<PriceCreateWithoutOrderProductInput, PriceUncheckedCreateWithoutOrderProductInput>
    connectOrCreate?: PriceCreateOrConnectWithoutOrderProductInput
    connect?: PriceWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutOrdersProductsInput = {
    create?: XOR<OrderCreateWithoutOrdersProductsInput, OrderUncheckedCreateWithoutOrdersProductsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrdersProductsInput
    upsert?: OrderUpsertWithoutOrdersProductsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<OrderUpdateWithoutOrdersProductsInput, OrderUncheckedUpdateWithoutOrdersProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrdersProductsInput = {
    create?: XOR<ProductCreateWithoutOrdersProductsInput, ProductUncheckedCreateWithoutOrdersProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersProductsInput
    upsert?: ProductUpsertWithoutOrdersProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutOrdersProductsInput, ProductUncheckedUpdateWithoutOrdersProductsInput>
  }

  export type UserUpdateOneRequiredWithoutOrderProductInput = {
    create?: XOR<UserCreateWithoutOrderProductInput, UserUncheckedCreateWithoutOrderProductInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderProductInput
    upsert?: UserUpsertWithoutOrderProductInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOrderProductInput, UserUncheckedUpdateWithoutOrderProductInput>
  }

  export type PriceUpdateOneRequiredWithoutOrderProductInput = {
    create?: XOR<PriceCreateWithoutOrderProductInput, PriceUncheckedCreateWithoutOrderProductInput>
    connectOrCreate?: PriceCreateOrConnectWithoutOrderProductInput
    upsert?: PriceUpsertWithoutOrderProductInput
    connect?: PriceWhereUniqueInput
    update?: XOR<PriceUpdateWithoutOrderProductInput, PriceUncheckedUpdateWithoutOrderProductInput>
  }

  export type OrderCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<OrderCreateWithoutTransactionsInput, OrderUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutTransactionsInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutTransactionsInput = {
    create?: XOR<OrderCreateWithoutTransactionsInput, OrderUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutTransactionsInput
    upsert?: OrderUpsertWithoutTransactionsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<OrderUpdateWithoutTransactionsInput, OrderUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserCreateNestedOneWithoutProductsInfoInput = {
    create?: XOR<UserCreateWithoutProductsInfoInput, UserUncheckedCreateWithoutProductsInfoInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInfoInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutProduct_infoInput = {
    create?: XOR<ProductCreateWithoutProduct_infoInput, ProductUncheckedCreateWithoutProduct_infoInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_infoInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedOneWithoutProduct_infoInput = {
    create?: XOR<ProductCreateWithoutProduct_infoInput, ProductUncheckedCreateWithoutProduct_infoInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_infoInput
    connect?: ProductWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProductsInfoInput = {
    create?: XOR<UserCreateWithoutProductsInfoInput, UserUncheckedCreateWithoutProductsInfoInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInfoInput
    upsert?: UserUpsertWithoutProductsInfoInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProductsInfoInput, UserUncheckedUpdateWithoutProductsInfoInput>
  }

  export type ProductUpdateOneWithoutProduct_infoInput = {
    create?: XOR<ProductCreateWithoutProduct_infoInput, ProductUncheckedCreateWithoutProduct_infoInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_infoInput
    upsert?: ProductUpsertWithoutProduct_infoInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutProduct_infoInput, ProductUncheckedUpdateWithoutProduct_infoInput>
  }

  export type ProductUncheckedUpdateOneWithoutProduct_infoInput = {
    create?: XOR<ProductCreateWithoutProduct_infoInput, ProductUncheckedCreateWithoutProduct_infoInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_infoInput
    upsert?: ProductUpsertWithoutProduct_infoInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutProduct_infoInput, ProductUncheckedUpdateWithoutProduct_infoInput>
  }

  export type UserCreateNestedOneWithoutForgotTokenInput = {
    create?: XOR<UserCreateWithoutForgotTokenInput, UserUncheckedCreateWithoutForgotTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutForgotTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutForgotTokenInput = {
    create?: XOR<UserCreateWithoutForgotTokenInput, UserUncheckedCreateWithoutForgotTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutForgotTokenInput
    upsert?: UserUpsertWithoutForgotTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutForgotTokenInput, UserUncheckedUpdateWithoutForgotTokenInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumTypeCategoryEnumFilter = {
    equals?: TypeCategoryEnum
    in?: Enumerable<TypeCategoryEnum>
    notIn?: Enumerable<TypeCategoryEnum>
    not?: NestedEnumTypeCategoryEnumFilter | TypeCategoryEnum
  }

  export type NestedEnumTypeCategoryEnumWithAggregatesFilter = {
    equals?: TypeCategoryEnum
    in?: Enumerable<TypeCategoryEnum>
    notIn?: Enumerable<TypeCategoryEnum>
    not?: NestedEnumTypeCategoryEnumWithAggregatesFilter | TypeCategoryEnum
    _count?: NestedIntFilter
    _min?: NestedEnumTypeCategoryEnumFilter
    _max?: NestedEnumTypeCategoryEnumFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalFilter | Decimal | number | string
  }

  export type NestedEnumStatusOrderEnumFilter = {
    equals?: StatusOrderEnum
    in?: Enumerable<StatusOrderEnum>
    notIn?: Enumerable<StatusOrderEnum>
    not?: NestedEnumStatusOrderEnumFilter | StatusOrderEnum
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedEnumStatusOrderEnumWithAggregatesFilter = {
    equals?: StatusOrderEnum
    in?: Enumerable<StatusOrderEnum>
    notIn?: Enumerable<StatusOrderEnum>
    not?: NestedEnumStatusOrderEnumWithAggregatesFilter | StatusOrderEnum
    _count?: NestedIntFilter
    _min?: NestedEnumStatusOrderEnumFilter
    _max?: NestedEnumStatusOrderEnumFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type NestedEnumReviewsStatusEnumFilter = {
    equals?: ReviewsStatusEnum
    in?: Enumerable<ReviewsStatusEnum>
    notIn?: Enumerable<ReviewsStatusEnum>
    not?: NestedEnumReviewsStatusEnumFilter | ReviewsStatusEnum
  }

  export type NestedEnumReviewsStatusEnumWithAggregatesFilter = {
    equals?: ReviewsStatusEnum
    in?: Enumerable<ReviewsStatusEnum>
    notIn?: Enumerable<ReviewsStatusEnum>
    not?: NestedEnumReviewsStatusEnumWithAggregatesFilter | ReviewsStatusEnum
    _count?: NestedIntFilter
    _min?: NestedEnumReviewsStatusEnumFilter
    _max?: NestedEnumReviewsStatusEnumFilter
  }

  export type NestedEnumStocksStatusEnumFilter = {
    equals?: StocksStatusEnum
    in?: Enumerable<StocksStatusEnum>
    notIn?: Enumerable<StocksStatusEnum>
    not?: NestedEnumStocksStatusEnumFilter | StocksStatusEnum
  }

  export type NestedEnumStockActionEnumFilter = {
    equals?: StockActionEnum
    in?: Enumerable<StockActionEnum>
    notIn?: Enumerable<StockActionEnum>
    not?: NestedEnumStockActionEnumFilter | StockActionEnum
  }

  export type NestedEnumStocksStatusEnumWithAggregatesFilter = {
    equals?: StocksStatusEnum
    in?: Enumerable<StocksStatusEnum>
    notIn?: Enumerable<StocksStatusEnum>
    not?: NestedEnumStocksStatusEnumWithAggregatesFilter | StocksStatusEnum
    _count?: NestedIntFilter
    _min?: NestedEnumStocksStatusEnumFilter
    _max?: NestedEnumStocksStatusEnumFilter
  }

  export type NestedEnumStockActionEnumWithAggregatesFilter = {
    equals?: StockActionEnum
    in?: Enumerable<StockActionEnum>
    notIn?: Enumerable<StockActionEnum>
    not?: NestedEnumStockActionEnumWithAggregatesFilter | StockActionEnum
    _count?: NestedIntFilter
    _min?: NestedEnumStockActionEnumFilter
    _max?: NestedEnumStockActionEnumFilter
  }

  export type UserCreateWithoutPersonInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    prices?: PriceCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPersonInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    prices?: PriceUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPersonInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonInput, UserUncheckedCreateWithoutPersonInput>
  }

  export type UserCreateManyPersonInputEnvelope = {
    data: Enumerable<UserCreateManyPersonInput>
    skipDuplicates?: boolean
  }

  export type PhonePersonCreateWithoutMainPhonePersonsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    phone: string
    person: PersonCreateNestedOneWithoutPhonesInput
  }

  export type PhonePersonUncheckedCreateWithoutMainPhonePersonsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    phone: string
    person_id: string
  }

  export type PhonePersonCreateOrConnectWithoutMainPhonePersonsInput = {
    where: PhonePersonWhereUniqueInput
    create: XOR<PhonePersonCreateWithoutMainPhonePersonsInput, PhonePersonUncheckedCreateWithoutMainPhonePersonsInput>
  }

  export type AddressPersonCreateWithoutMainAddressPersonsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    number: number
    street: string
    complement?: string | null
    zip_code: string
    city: string
    state: string
    neighborhood: string
    person: PersonCreateNestedOneWithoutAddressesInput
  }

  export type AddressPersonUncheckedCreateWithoutMainAddressPersonsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    number: number
    street: string
    complement?: string | null
    zip_code: string
    city: string
    state: string
    neighborhood: string
    person_id: string
  }

  export type AddressPersonCreateOrConnectWithoutMainAddressPersonsInput = {
    where: AddressPersonWhereUniqueInput
    create: XOR<AddressPersonCreateWithoutMainAddressPersonsInput, AddressPersonUncheckedCreateWithoutMainAddressPersonsInput>
  }

  export type AddressPersonCreateWithoutPersonInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    number: number
    street: string
    complement?: string | null
    zip_code: string
    city: string
    state: string
    neighborhood: string
    mainAddressPersons?: PersonCreateNestedManyWithoutAddressInput
  }

  export type AddressPersonUncheckedCreateWithoutPersonInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    number: number
    street: string
    complement?: string | null
    zip_code: string
    city: string
    state: string
    neighborhood: string
    mainAddressPersons?: PersonUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressPersonCreateOrConnectWithoutPersonInput = {
    where: AddressPersonWhereUniqueInput
    create: XOR<AddressPersonCreateWithoutPersonInput, AddressPersonUncheckedCreateWithoutPersonInput>
  }

  export type AddressPersonCreateManyPersonInputEnvelope = {
    data: Enumerable<AddressPersonCreateManyPersonInput>
    skipDuplicates?: boolean
  }

  export type PhonePersonCreateWithoutPersonInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    phone: string
    mainPhonePersons?: PersonCreateNestedManyWithoutPhoneInput
  }

  export type PhonePersonUncheckedCreateWithoutPersonInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    phone: string
    mainPhonePersons?: PersonUncheckedCreateNestedManyWithoutPhoneInput
  }

  export type PhonePersonCreateOrConnectWithoutPersonInput = {
    where: PhonePersonWhereUniqueInput
    create: XOR<PhonePersonCreateWithoutPersonInput, PhonePersonUncheckedCreateWithoutPersonInput>
  }

  export type PhonePersonCreateManyPersonInputEnvelope = {
    data: Enumerable<PhonePersonCreateManyPersonInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutPersonInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutPersonInput, UserUncheckedUpdateWithoutPersonInput>
    create: XOR<UserCreateWithoutPersonInput, UserUncheckedCreateWithoutPersonInput>
  }

  export type UserUpdateWithWhereUniqueWithoutPersonInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutPersonInput, UserUncheckedUpdateWithoutPersonInput>
  }

  export type UserUpdateManyWithWhereWithoutPersonInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    password?: StringFilter | string
    is_verified?: BoolFilter | boolean
    person_id?: StringFilter | string
  }

  export type PhonePersonUpsertWithoutMainPhonePersonsInput = {
    update: XOR<PhonePersonUpdateWithoutMainPhonePersonsInput, PhonePersonUncheckedUpdateWithoutMainPhonePersonsInput>
    create: XOR<PhonePersonCreateWithoutMainPhonePersonsInput, PhonePersonUncheckedCreateWithoutMainPhonePersonsInput>
  }

  export type PhonePersonUpdateWithoutMainPhonePersonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    person?: PersonUpdateOneRequiredWithoutPhonesInput
  }

  export type PhonePersonUncheckedUpdateWithoutMainPhonePersonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    person_id?: StringFieldUpdateOperationsInput | string
  }

  export type AddressPersonUpsertWithoutMainAddressPersonsInput = {
    update: XOR<AddressPersonUpdateWithoutMainAddressPersonsInput, AddressPersonUncheckedUpdateWithoutMainAddressPersonsInput>
    create: XOR<AddressPersonCreateWithoutMainAddressPersonsInput, AddressPersonUncheckedCreateWithoutMainAddressPersonsInput>
  }

  export type AddressPersonUpdateWithoutMainAddressPersonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    neighborhood?: StringFieldUpdateOperationsInput | string
    person?: PersonUpdateOneRequiredWithoutAddressesInput
  }

  export type AddressPersonUncheckedUpdateWithoutMainAddressPersonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    neighborhood?: StringFieldUpdateOperationsInput | string
    person_id?: StringFieldUpdateOperationsInput | string
  }

  export type AddressPersonUpsertWithWhereUniqueWithoutPersonInput = {
    where: AddressPersonWhereUniqueInput
    update: XOR<AddressPersonUpdateWithoutPersonInput, AddressPersonUncheckedUpdateWithoutPersonInput>
    create: XOR<AddressPersonCreateWithoutPersonInput, AddressPersonUncheckedCreateWithoutPersonInput>
  }

  export type AddressPersonUpdateWithWhereUniqueWithoutPersonInput = {
    where: AddressPersonWhereUniqueInput
    data: XOR<AddressPersonUpdateWithoutPersonInput, AddressPersonUncheckedUpdateWithoutPersonInput>
  }

  export type AddressPersonUpdateManyWithWhereWithoutPersonInput = {
    where: AddressPersonScalarWhereInput
    data: XOR<AddressPersonUpdateManyMutationInput, AddressPersonUncheckedUpdateManyWithoutAddressesInput>
  }

  export type AddressPersonScalarWhereInput = {
    AND?: Enumerable<AddressPersonScalarWhereInput>
    OR?: Enumerable<AddressPersonScalarWhereInput>
    NOT?: Enumerable<AddressPersonScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    number?: IntFilter | number
    street?: StringFilter | string
    complement?: StringNullableFilter | string | null
    zip_code?: StringFilter | string
    city?: StringFilter | string
    state?: StringFilter | string
    neighborhood?: StringFilter | string
    person_id?: StringFilter | string
  }

  export type PhonePersonUpsertWithWhereUniqueWithoutPersonInput = {
    where: PhonePersonWhereUniqueInput
    update: XOR<PhonePersonUpdateWithoutPersonInput, PhonePersonUncheckedUpdateWithoutPersonInput>
    create: XOR<PhonePersonCreateWithoutPersonInput, PhonePersonUncheckedCreateWithoutPersonInput>
  }

  export type PhonePersonUpdateWithWhereUniqueWithoutPersonInput = {
    where: PhonePersonWhereUniqueInput
    data: XOR<PhonePersonUpdateWithoutPersonInput, PhonePersonUncheckedUpdateWithoutPersonInput>
  }

  export type PhonePersonUpdateManyWithWhereWithoutPersonInput = {
    where: PhonePersonScalarWhereInput
    data: XOR<PhonePersonUpdateManyMutationInput, PhonePersonUncheckedUpdateManyWithoutPhonesInput>
  }

  export type PhonePersonScalarWhereInput = {
    AND?: Enumerable<PhonePersonScalarWhereInput>
    OR?: Enumerable<PhonePersonScalarWhereInput>
    NOT?: Enumerable<PhonePersonScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    phone?: StringFilter | string
    person_id?: StringFilter | string
  }

  export type PersonCreateWithoutAddressesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    email: string
    cpf?: string | null
    rg?: string | null
    rgss?: string | null
    birth_date?: Date | string | null
    status?: boolean
    privacy?: boolean
    avatar?: string | null
    users?: UserCreateNestedManyWithoutPersonInput
    phone?: PhonePersonCreateNestedOneWithoutMainPhonePersonsInput
    address?: AddressPersonCreateNestedOneWithoutMainAddressPersonsInput
    phones?: PhonePersonCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutAddressesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    email: string
    cpf?: string | null
    rg?: string | null
    rgss?: string | null
    birth_date?: Date | string | null
    status?: boolean
    privacy?: boolean
    avatar?: string | null
    users?: UserUncheckedCreateNestedManyWithoutPersonInput
    phone_id?: string | null
    address_id?: string | null
    phones?: PhonePersonUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutAddressesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutAddressesInput, PersonUncheckedCreateWithoutAddressesInput>
  }

  export type PersonCreateWithoutAddressInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    email: string
    cpf?: string | null
    rg?: string | null
    rgss?: string | null
    birth_date?: Date | string | null
    status?: boolean
    privacy?: boolean
    avatar?: string | null
    users?: UserCreateNestedManyWithoutPersonInput
    phone?: PhonePersonCreateNestedOneWithoutMainPhonePersonsInput
    addresses?: AddressPersonCreateNestedManyWithoutPersonInput
    phones?: PhonePersonCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutAddressInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    email: string
    cpf?: string | null
    rg?: string | null
    rgss?: string | null
    birth_date?: Date | string | null
    status?: boolean
    privacy?: boolean
    avatar?: string | null
    users?: UserUncheckedCreateNestedManyWithoutPersonInput
    phone_id?: string | null
    addresses?: AddressPersonUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhonePersonUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutAddressInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutAddressInput, PersonUncheckedCreateWithoutAddressInput>
  }

  export type PersonCreateManyAddressInputEnvelope = {
    data: Enumerable<PersonCreateManyAddressInput>
    skipDuplicates?: boolean
  }

  export type PersonUpsertWithoutAddressesInput = {
    update: XOR<PersonUpdateWithoutAddressesInput, PersonUncheckedUpdateWithoutAddressesInput>
    create: XOR<PersonCreateWithoutAddressesInput, PersonUncheckedCreateWithoutAddressesInput>
  }

  export type PersonUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutPersonInput
    phone?: PhonePersonUpdateOneWithoutMainPhonePersonsInput
    address?: AddressPersonUpdateOneWithoutMainAddressPersonsInput
    phones?: PhonePersonUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutPersonInput
    phone_id?: NullableStringFieldUpdateOperationsInput | string | null
    address_id?: NullableStringFieldUpdateOperationsInput | string | null
    phones?: PhonePersonUncheckedUpdateManyWithoutPersonInput
  }

  export type PersonUpsertWithWhereUniqueWithoutAddressInput = {
    where: PersonWhereUniqueInput
    update: XOR<PersonUpdateWithoutAddressInput, PersonUncheckedUpdateWithoutAddressInput>
    create: XOR<PersonCreateWithoutAddressInput, PersonUncheckedCreateWithoutAddressInput>
  }

  export type PersonUpdateWithWhereUniqueWithoutAddressInput = {
    where: PersonWhereUniqueInput
    data: XOR<PersonUpdateWithoutAddressInput, PersonUncheckedUpdateWithoutAddressInput>
  }

  export type PersonUpdateManyWithWhereWithoutAddressInput = {
    where: PersonScalarWhereInput
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyWithoutMainAddressPersonsInput>
  }

  export type PersonScalarWhereInput = {
    AND?: Enumerable<PersonScalarWhereInput>
    OR?: Enumerable<PersonScalarWhereInput>
    NOT?: Enumerable<PersonScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    name?: StringFilter | string
    email?: StringFilter | string
    cpf?: StringNullableFilter | string | null
    rg?: StringNullableFilter | string | null
    rgss?: StringNullableFilter | string | null
    birth_date?: DateTimeNullableFilter | Date | string | null
    status?: BoolFilter | boolean
    privacy?: BoolFilter | boolean
    avatar?: StringNullableFilter | string | null
    phone_id?: StringNullableFilter | string | null
    address_id?: StringNullableFilter | string | null
  }

  export type PersonCreateWithoutPhonesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    email: string
    cpf?: string | null
    rg?: string | null
    rgss?: string | null
    birth_date?: Date | string | null
    status?: boolean
    privacy?: boolean
    avatar?: string | null
    users?: UserCreateNestedManyWithoutPersonInput
    phone?: PhonePersonCreateNestedOneWithoutMainPhonePersonsInput
    address?: AddressPersonCreateNestedOneWithoutMainAddressPersonsInput
    addresses?: AddressPersonCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutPhonesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    email: string
    cpf?: string | null
    rg?: string | null
    rgss?: string | null
    birth_date?: Date | string | null
    status?: boolean
    privacy?: boolean
    avatar?: string | null
    users?: UserUncheckedCreateNestedManyWithoutPersonInput
    phone_id?: string | null
    address_id?: string | null
    addresses?: AddressPersonUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutPhonesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutPhonesInput, PersonUncheckedCreateWithoutPhonesInput>
  }

  export type PersonCreateWithoutPhoneInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    email: string
    cpf?: string | null
    rg?: string | null
    rgss?: string | null
    birth_date?: Date | string | null
    status?: boolean
    privacy?: boolean
    avatar?: string | null
    users?: UserCreateNestedManyWithoutPersonInput
    address?: AddressPersonCreateNestedOneWithoutMainAddressPersonsInput
    addresses?: AddressPersonCreateNestedManyWithoutPersonInput
    phones?: PhonePersonCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutPhoneInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    email: string
    cpf?: string | null
    rg?: string | null
    rgss?: string | null
    birth_date?: Date | string | null
    status?: boolean
    privacy?: boolean
    avatar?: string | null
    users?: UserUncheckedCreateNestedManyWithoutPersonInput
    address_id?: string | null
    addresses?: AddressPersonUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhonePersonUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutPhoneInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutPhoneInput, PersonUncheckedCreateWithoutPhoneInput>
  }

  export type PersonCreateManyPhoneInputEnvelope = {
    data: Enumerable<PersonCreateManyPhoneInput>
    skipDuplicates?: boolean
  }

  export type PersonUpsertWithoutPhonesInput = {
    update: XOR<PersonUpdateWithoutPhonesInput, PersonUncheckedUpdateWithoutPhonesInput>
    create: XOR<PersonCreateWithoutPhonesInput, PersonUncheckedCreateWithoutPhonesInput>
  }

  export type PersonUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutPersonInput
    phone?: PhonePersonUpdateOneWithoutMainPhonePersonsInput
    address?: AddressPersonUpdateOneWithoutMainAddressPersonsInput
    addresses?: AddressPersonUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutPersonInput
    phone_id?: NullableStringFieldUpdateOperationsInput | string | null
    address_id?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: AddressPersonUncheckedUpdateManyWithoutPersonInput
  }

  export type PersonUpsertWithWhereUniqueWithoutPhoneInput = {
    where: PersonWhereUniqueInput
    update: XOR<PersonUpdateWithoutPhoneInput, PersonUncheckedUpdateWithoutPhoneInput>
    create: XOR<PersonCreateWithoutPhoneInput, PersonUncheckedCreateWithoutPhoneInput>
  }

  export type PersonUpdateWithWhereUniqueWithoutPhoneInput = {
    where: PersonWhereUniqueInput
    data: XOR<PersonUpdateWithoutPhoneInput, PersonUncheckedUpdateWithoutPhoneInput>
  }

  export type PersonUpdateManyWithWhereWithoutPhoneInput = {
    where: PersonScalarWhereInput
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyWithoutMainPhonePersonsInput>
  }

  export type UserGroupCreateWithoutGroupInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutUsersGroupsInput
  }

  export type UserGroupUncheckedCreateWithoutGroupInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user_id: string
  }

  export type UserGroupCreateOrConnectWithoutGroupInput = {
    where: UserGroupWhereUniqueInput
    create: XOR<UserGroupCreateWithoutGroupInput, UserGroupUncheckedCreateWithoutGroupInput>
  }

  export type UserGroupCreateManyGroupInputEnvelope = {
    data: Enumerable<UserGroupCreateManyGroupInput>
    skipDuplicates?: boolean
  }

  export type UserGroupUpsertWithWhereUniqueWithoutGroupInput = {
    where: UserGroupWhereUniqueInput
    update: XOR<UserGroupUpdateWithoutGroupInput, UserGroupUncheckedUpdateWithoutGroupInput>
    create: XOR<UserGroupCreateWithoutGroupInput, UserGroupUncheckedCreateWithoutGroupInput>
  }

  export type UserGroupUpdateWithWhereUniqueWithoutGroupInput = {
    where: UserGroupWhereUniqueInput
    data: XOR<UserGroupUpdateWithoutGroupInput, UserGroupUncheckedUpdateWithoutGroupInput>
  }

  export type UserGroupUpdateManyWithWhereWithoutGroupInput = {
    where: UserGroupScalarWhereInput
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyWithoutUsersGroupsInput>
  }

  export type UserGroupScalarWhereInput = {
    AND?: Enumerable<UserGroupScalarWhereInput>
    OR?: Enumerable<UserGroupScalarWhereInput>
    NOT?: Enumerable<UserGroupScalarWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    user_id?: StringFilter | string
    group_id?: StringFilter | string
  }

  export type PersonCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    email: string
    cpf?: string | null
    rg?: string | null
    rgss?: string | null
    birth_date?: Date | string | null
    status?: boolean
    privacy?: boolean
    avatar?: string | null
    phone?: PhonePersonCreateNestedOneWithoutMainPhonePersonsInput
    address?: AddressPersonCreateNestedOneWithoutMainAddressPersonsInput
    addresses?: AddressPersonCreateNestedManyWithoutPersonInput
    phones?: PhonePersonCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutUsersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    email: string
    cpf?: string | null
    rg?: string | null
    rgss?: string | null
    birth_date?: Date | string | null
    status?: boolean
    privacy?: boolean
    avatar?: string | null
    phone_id?: string | null
    address_id?: string | null
    addresses?: AddressPersonUncheckedCreateNestedManyWithoutPersonInput
    phones?: PhonePersonUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutUsersInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutUsersInput, PersonUncheckedCreateWithoutUsersInput>
  }

  export type PriceCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    product: ProductCreateNestedOneWithoutPricesInput
    actualProduct?: ProductCreateNestedManyWithoutPriceInput
    OrderProduct?: OrderProductCreateNestedManyWithoutPriceInput
  }

  export type PriceUncheckedCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    product_id: string
    actualProduct?: ProductUncheckedCreateNestedManyWithoutPriceInput
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PriceCreateOrConnectWithoutUserInput = {
    where: PriceWhereUniqueInput
    create: XOR<PriceCreateWithoutUserInput, PriceUncheckedCreateWithoutUserInput>
  }

  export type PriceCreateManyUserInputEnvelope = {
    data: Enumerable<PriceCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    total: Decimal | number | string
    freight: Decimal | number | string
    canceled_at?: Date | string | null
    status?: StatusOrderEnum
    ordersProducts?: OrderProductCreateNestedManyWithoutOrderInput
    transactions?: TransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    total: Decimal | number | string
    freight: Decimal | number | string
    canceled_at?: Date | string | null
    status?: StatusOrderEnum
    ordersProducts?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: Enumerable<OrderCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutAuthorInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    comment: string
    status?: ReviewsStatusEnum
    product: ProductCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutAuthorInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    comment: string
    status?: ReviewsStatusEnum
    product_id: string
  }

  export type ReviewCreateOrConnectWithoutAuthorInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutAuthorInput, ReviewUncheckedCreateWithoutAuthorInput>
  }

  export type ReviewCreateManyAuthorInputEnvelope = {
    data: Enumerable<ReviewCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type UserGroupCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    group: GroupCreateNestedOneWithoutUsersGroupsInput
  }

  export type UserGroupUncheckedCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    group_id: string
  }

  export type UserGroupCreateOrConnectWithoutUserInput = {
    where: UserGroupWhereUniqueInput
    create: XOR<UserGroupCreateWithoutUserInput, UserGroupUncheckedCreateWithoutUserInput>
  }

  export type UserGroupCreateManyUserInputEnvelope = {
    data: Enumerable<UserGroupCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RefresheTokenCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    refresh_token: string
    device: string
    expires_date: Date | string
  }

  export type RefresheTokenUncheckedCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    refresh_token: string
    device: string
    expires_date: Date | string
  }

  export type RefresheTokenCreateOrConnectWithoutUserInput = {
    where: RefresheTokenWhereUniqueInput
    create: XOR<RefresheTokenCreateWithoutUserInput, RefresheTokenUncheckedCreateWithoutUserInput>
  }

  export type RefresheTokenCreateManyUserInputEnvelope = {
    data: Enumerable<RefresheTokenCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ProductInfoCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    freight: Decimal | number | string
    link: string
    stock: number
    company: string
    currency: string
    product?: ProductCreateNestedOneWithoutProduct_infoInput
  }

  export type ProductInfoUncheckedCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    freight: Decimal | number | string
    link: string
    stock: number
    company: string
    currency: string
    product?: ProductUncheckedCreateNestedOneWithoutProduct_infoInput
  }

  export type ProductInfoCreateOrConnectWithoutUserInput = {
    where: ProductInfoWhereUniqueInput
    create: XOR<ProductInfoCreateWithoutUserInput, ProductInfoUncheckedCreateWithoutUserInput>
  }

  export type ProductInfoCreateManyUserInputEnvelope = {
    data: Enumerable<ProductInfoCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OrderProductCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    subtotal: Decimal | number | string
    quantity: number
    status?: StatusOrderEnum
    order: OrderCreateNestedOneWithoutOrdersProductsInput
    product: ProductCreateNestedOneWithoutOrdersProductsInput
    price: PriceCreateNestedOneWithoutOrderProductInput
  }

  export type OrderProductUncheckedCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    subtotal: Decimal | number | string
    quantity: number
    status?: StatusOrderEnum
    order_id: string
    product_id: string
    price_id: string
  }

  export type OrderProductCreateOrConnectWithoutUserInput = {
    where: OrderProductWhereUniqueInput
    create: XOR<OrderProductCreateWithoutUserInput, OrderProductUncheckedCreateWithoutUserInput>
  }

  export type OrderProductCreateManyUserInputEnvelope = {
    data: Enumerable<OrderProductCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ForgotTokenCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    token: string
    code: string
    expires_date: Date | string
  }

  export type ForgotTokenUncheckedCreateWithoutUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    token: string
    code: string
    expires_date: Date | string
  }

  export type ForgotTokenCreateOrConnectWithoutUserInput = {
    where: ForgotTokenWhereUniqueInput
    create: XOR<ForgotTokenCreateWithoutUserInput, ForgotTokenUncheckedCreateWithoutUserInput>
  }

  export type ForgotTokenCreateManyUserInputEnvelope = {
    data: Enumerable<ForgotTokenCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type PersonUpsertWithoutUsersInput = {
    update: XOR<PersonUpdateWithoutUsersInput, PersonUncheckedUpdateWithoutUsersInput>
    create: XOR<PersonCreateWithoutUsersInput, PersonUncheckedCreateWithoutUsersInput>
  }

  export type PersonUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: PhonePersonUpdateOneWithoutMainPhonePersonsInput
    address?: AddressPersonUpdateOneWithoutMainAddressPersonsInput
    addresses?: AddressPersonUpdateManyWithoutPersonInput
    phones?: PhonePersonUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone_id?: NullableStringFieldUpdateOperationsInput | string | null
    address_id?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: AddressPersonUncheckedUpdateManyWithoutPersonInput
    phones?: PhonePersonUncheckedUpdateManyWithoutPersonInput
  }

  export type PriceUpsertWithWhereUniqueWithoutUserInput = {
    where: PriceWhereUniqueInput
    update: XOR<PriceUpdateWithoutUserInput, PriceUncheckedUpdateWithoutUserInput>
    create: XOR<PriceCreateWithoutUserInput, PriceUncheckedCreateWithoutUserInput>
  }

  export type PriceUpdateWithWhereUniqueWithoutUserInput = {
    where: PriceWhereUniqueInput
    data: XOR<PriceUpdateWithoutUserInput, PriceUncheckedUpdateWithoutUserInput>
  }

  export type PriceUpdateManyWithWhereWithoutUserInput = {
    where: PriceScalarWhereInput
    data: XOR<PriceUpdateManyMutationInput, PriceUncheckedUpdateManyWithoutPricesInput>
  }

  export type PriceScalarWhereInput = {
    AND?: Enumerable<PriceScalarWhereInput>
    OR?: Enumerable<PriceScalarWhereInput>
    NOT?: Enumerable<PriceScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    price?: DecimalFilter | Decimal | number | string
    price_promotion?: DecimalFilter | Decimal | number | string
    product_id?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type OrderScalarWhereInput = {
    AND?: Enumerable<OrderScalarWhereInput>
    OR?: Enumerable<OrderScalarWhereInput>
    NOT?: Enumerable<OrderScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    total?: DecimalFilter | Decimal | number | string
    freight?: DecimalFilter | Decimal | number | string
    canceled_at?: DateTimeNullableFilter | Date | string | null
    status?: EnumStatusOrderEnumFilter | StatusOrderEnum
    user_id?: StringFilter | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutAuthorInput, ReviewUncheckedUpdateWithoutAuthorInput>
    create: XOR<ReviewCreateWithoutAuthorInput, ReviewUncheckedCreateWithoutAuthorInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutAuthorInput, ReviewUncheckedUpdateWithoutAuthorInput>
  }

  export type ReviewUpdateManyWithWhereWithoutAuthorInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutReviewsInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: Enumerable<ReviewScalarWhereInput>
    OR?: Enumerable<ReviewScalarWhereInput>
    NOT?: Enumerable<ReviewScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    comment?: StringFilter | string
    status?: EnumReviewsStatusEnumFilter | ReviewsStatusEnum
    product_id?: StringFilter | string
    author_id?: StringNullableFilter | string | null
  }

  export type UserGroupUpsertWithWhereUniqueWithoutUserInput = {
    where: UserGroupWhereUniqueInput
    update: XOR<UserGroupUpdateWithoutUserInput, UserGroupUncheckedUpdateWithoutUserInput>
    create: XOR<UserGroupCreateWithoutUserInput, UserGroupUncheckedCreateWithoutUserInput>
  }

  export type UserGroupUpdateWithWhereUniqueWithoutUserInput = {
    where: UserGroupWhereUniqueInput
    data: XOR<UserGroupUpdateWithoutUserInput, UserGroupUncheckedUpdateWithoutUserInput>
  }

  export type UserGroupUpdateManyWithWhereWithoutUserInput = {
    where: UserGroupScalarWhereInput
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyWithoutUsersGroupsInput>
  }

  export type RefresheTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefresheTokenWhereUniqueInput
    update: XOR<RefresheTokenUpdateWithoutUserInput, RefresheTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefresheTokenCreateWithoutUserInput, RefresheTokenUncheckedCreateWithoutUserInput>
  }

  export type RefresheTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefresheTokenWhereUniqueInput
    data: XOR<RefresheTokenUpdateWithoutUserInput, RefresheTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefresheTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefresheTokenScalarWhereInput
    data: XOR<RefresheTokenUpdateManyMutationInput, RefresheTokenUncheckedUpdateManyWithoutRefreshesTokensInput>
  }

  export type RefresheTokenScalarWhereInput = {
    AND?: Enumerable<RefresheTokenScalarWhereInput>
    OR?: Enumerable<RefresheTokenScalarWhereInput>
    NOT?: Enumerable<RefresheTokenScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    refresh_token?: StringFilter | string
    device?: StringFilter | string
    expires_date?: DateTimeFilter | Date | string
    user_id?: StringFilter | string
  }

  export type ProductInfoUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductInfoWhereUniqueInput
    update: XOR<ProductInfoUpdateWithoutUserInput, ProductInfoUncheckedUpdateWithoutUserInput>
    create: XOR<ProductInfoCreateWithoutUserInput, ProductInfoUncheckedCreateWithoutUserInput>
  }

  export type ProductInfoUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductInfoWhereUniqueInput
    data: XOR<ProductInfoUpdateWithoutUserInput, ProductInfoUncheckedUpdateWithoutUserInput>
  }

  export type ProductInfoUpdateManyWithWhereWithoutUserInput = {
    where: ProductInfoScalarWhereInput
    data: XOR<ProductInfoUpdateManyMutationInput, ProductInfoUncheckedUpdateManyWithoutProductsInfoInput>
  }

  export type ProductInfoScalarWhereInput = {
    AND?: Enumerable<ProductInfoScalarWhereInput>
    OR?: Enumerable<ProductInfoScalarWhereInput>
    NOT?: Enumerable<ProductInfoScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    price?: DecimalFilter | Decimal | number | string
    price_promotion?: DecimalFilter | Decimal | number | string
    freight?: DecimalFilter | Decimal | number | string
    link?: StringFilter | string
    stock?: IntFilter | number
    company?: StringFilter | string
    currency?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type OrderProductUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderProductWhereUniqueInput
    update: XOR<OrderProductUpdateWithoutUserInput, OrderProductUncheckedUpdateWithoutUserInput>
    create: XOR<OrderProductCreateWithoutUserInput, OrderProductUncheckedCreateWithoutUserInput>
  }

  export type OrderProductUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderProductWhereUniqueInput
    data: XOR<OrderProductUpdateWithoutUserInput, OrderProductUncheckedUpdateWithoutUserInput>
  }

  export type OrderProductUpdateManyWithWhereWithoutUserInput = {
    where: OrderProductScalarWhereInput
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyWithoutOrderProductInput>
  }

  export type OrderProductScalarWhereInput = {
    AND?: Enumerable<OrderProductScalarWhereInput>
    OR?: Enumerable<OrderProductScalarWhereInput>
    NOT?: Enumerable<OrderProductScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    subtotal?: DecimalFilter | Decimal | number | string
    quantity?: IntFilter | number
    status?: EnumStatusOrderEnumFilter | StatusOrderEnum
    order_id?: StringFilter | string
    product_id?: StringFilter | string
    user_id?: StringFilter | string
    price_id?: StringFilter | string
  }

  export type ForgotTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: ForgotTokenWhereUniqueInput
    update: XOR<ForgotTokenUpdateWithoutUserInput, ForgotTokenUncheckedUpdateWithoutUserInput>
    create: XOR<ForgotTokenCreateWithoutUserInput, ForgotTokenUncheckedCreateWithoutUserInput>
  }

  export type ForgotTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: ForgotTokenWhereUniqueInput
    data: XOR<ForgotTokenUpdateWithoutUserInput, ForgotTokenUncheckedUpdateWithoutUserInput>
  }

  export type ForgotTokenUpdateManyWithWhereWithoutUserInput = {
    where: ForgotTokenScalarWhereInput
    data: XOR<ForgotTokenUpdateManyMutationInput, ForgotTokenUncheckedUpdateManyWithoutForgotTokenInput>
  }

  export type ForgotTokenScalarWhereInput = {
    AND?: Enumerable<ForgotTokenScalarWhereInput>
    OR?: Enumerable<ForgotTokenScalarWhereInput>
    NOT?: Enumerable<ForgotTokenScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    token?: StringFilter | string
    code?: StringFilter | string
    expires_date?: DateTimeFilter | Date | string
    user_id?: StringFilter | string
  }

  export type UserCreateWithoutUsersGroupsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person: PersonCreateNestedOneWithoutUsersInput
    prices?: PriceCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutAuthorInput
    refreshesTokens?: RefresheTokenCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUsersGroupsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person_id: string
    prices?: PriceUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    refreshesTokens?: RefresheTokenUncheckedCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUsersGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsersGroupsInput, UserUncheckedCreateWithoutUsersGroupsInput>
  }

  export type GroupCreateWithoutUsersGroupsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
  }

  export type GroupUncheckedCreateWithoutUsersGroupsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    description: string
  }

  export type GroupCreateOrConnectWithoutUsersGroupsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutUsersGroupsInput, GroupUncheckedCreateWithoutUsersGroupsInput>
  }

  export type UserUpsertWithoutUsersGroupsInput = {
    update: XOR<UserUpdateWithoutUsersGroupsInput, UserUncheckedUpdateWithoutUsersGroupsInput>
    create: XOR<UserCreateWithoutUsersGroupsInput, UserUncheckedCreateWithoutUsersGroupsInput>
  }

  export type UserUpdateWithoutUsersGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person?: PersonUpdateOneRequiredWithoutUsersInput
    prices?: PriceUpdateManyWithoutUserInput
    orders?: OrderUpdateManyWithoutUserInput
    reviews?: ReviewUpdateManyWithoutAuthorInput
    refreshesTokens?: RefresheTokenUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUsersGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person_id?: StringFieldUpdateOperationsInput | string
    prices?: PriceUncheckedUpdateManyWithoutUserInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    reviews?: ReviewUncheckedUpdateManyWithoutAuthorInput
    refreshesTokens?: RefresheTokenUncheckedUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedUpdateManyWithoutUserInput
  }

  export type GroupUpsertWithoutUsersGroupsInput = {
    update: XOR<GroupUpdateWithoutUsersGroupsInput, GroupUncheckedUpdateWithoutUsersGroupsInput>
    create: XOR<GroupCreateWithoutUsersGroupsInput, GroupUncheckedCreateWithoutUsersGroupsInput>
  }

  export type GroupUpdateWithoutUsersGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type GroupUncheckedUpdateWithoutUsersGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutRefreshesTokensInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person: PersonCreateNestedOneWithoutUsersInput
    prices?: PriceCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshesTokensInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person_id: string
    prices?: PriceUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshesTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshesTokensInput, UserUncheckedCreateWithoutRefreshesTokensInput>
  }

  export type UserUpsertWithoutRefreshesTokensInput = {
    update: XOR<UserUpdateWithoutRefreshesTokensInput, UserUncheckedUpdateWithoutRefreshesTokensInput>
    create: XOR<UserCreateWithoutRefreshesTokensInput, UserUncheckedCreateWithoutRefreshesTokensInput>
  }

  export type UserUpdateWithoutRefreshesTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person?: PersonUpdateOneRequiredWithoutUsersInput
    prices?: PriceUpdateManyWithoutUserInput
    orders?: OrderUpdateManyWithoutUserInput
    reviews?: ReviewUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutRefreshesTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person_id?: StringFieldUpdateOperationsInput | string
    prices?: PriceUncheckedUpdateManyWithoutUserInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    reviews?: ReviewUncheckedUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedUpdateManyWithoutUserInput
  }

  export type CategoryProductCreateWithoutCategoryInput = {
    created_at?: Date | string
    updated_at?: Date | string
    product: ProductCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryProductUncheckedCreateWithoutCategoryInput = {
    created_at?: Date | string
    updated_at?: Date | string
    product_id: string
  }

  export type CategoryProductCreateOrConnectWithoutCategoryInput = {
    where: CategoryProductWhereUniqueInput
    create: XOR<CategoryProductCreateWithoutCategoryInput, CategoryProductUncheckedCreateWithoutCategoryInput>
  }

  export type CategoryProductCreateManyCategoryInputEnvelope = {
    data: Enumerable<CategoryProductCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type CategoryProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CategoryProductWhereUniqueInput
    update: XOR<CategoryProductUpdateWithoutCategoryInput, CategoryProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<CategoryProductCreateWithoutCategoryInput, CategoryProductUncheckedCreateWithoutCategoryInput>
  }

  export type CategoryProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CategoryProductWhereUniqueInput
    data: XOR<CategoryProductUpdateWithoutCategoryInput, CategoryProductUncheckedUpdateWithoutCategoryInput>
  }

  export type CategoryProductUpdateManyWithWhereWithoutCategoryInput = {
    where: CategoryProductScalarWhereInput
    data: XOR<CategoryProductUpdateManyMutationInput, CategoryProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type CategoryProductScalarWhereInput = {
    AND?: Enumerable<CategoryProductScalarWhereInput>
    OR?: Enumerable<CategoryProductScalarWhereInput>
    NOT?: Enumerable<CategoryProductScalarWhereInput>
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    category_id?: StringFilter | string
    product_id?: StringFilter | string
  }

  export type ProductCreateWithoutSubcategoryInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price?: PriceCreateNestedOneWithoutActualProductInput
    description: DescriptionCreateNestedOneWithoutProductsInput
    product_info: ProductInfoCreateNestedOneWithoutProductInput
    categories?: CategoryProductCreateNestedManyWithoutProductInput
    photos?: PhotoCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    videos?: VideoCreateNestedManyWithoutProductInput
    stocks?: StockCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductCreateNestedManyWithoutProductInput
    prices?: PriceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSubcategoryInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price_id?: string | null
    description_id: string
    product_info_id: string
    categories?: CategoryProductUncheckedCreateNestedManyWithoutProductInput
    photos?: PhotoUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    videos?: VideoUncheckedCreateNestedManyWithoutProductInput
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    prices?: PriceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSubcategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSubcategoryInput, ProductUncheckedCreateWithoutSubcategoryInput>
  }

  export type ProductCreateManySubcategoryInputEnvelope = {
    data: Enumerable<ProductCreateManySubcategoryInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutSubcategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSubcategoryInput, ProductUncheckedUpdateWithoutSubcategoryInput>
    create: XOR<ProductCreateWithoutSubcategoryInput, ProductUncheckedCreateWithoutSubcategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSubcategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSubcategoryInput, ProductUncheckedUpdateWithoutSubcategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutSubcategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductScalarWhereInput = {
    AND?: Enumerable<ProductScalarWhereInput>
    OR?: Enumerable<ProductScalarWhereInput>
    NOT?: Enumerable<ProductScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    sku?: StringNullableFilter | string | null
    bar_code?: StringNullableFilter | string | null
    other?: JsonNullableFilter
    canceled_at?: DateTimeNullableFilter | Date | string | null
    status?: BoolFilter | boolean
    status_freight?: BoolFilter | boolean
    status_product?: BoolFilter | boolean
    price_id?: StringNullableFilter | string | null
    description_id?: StringFilter | string
    subcategory_id?: StringFilter | string
    product_info_id?: StringFilter | string
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person: PersonCreateNestedOneWithoutUsersInput
    prices?: PriceCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person_id: string
    prices?: PriceUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type OrderProductCreateWithoutOrderInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    subtotal: Decimal | number | string
    quantity: number
    status?: StatusOrderEnum
    product: ProductCreateNestedOneWithoutOrdersProductsInput
    user: UserCreateNestedOneWithoutOrderProductInput
    price: PriceCreateNestedOneWithoutOrderProductInput
  }

  export type OrderProductUncheckedCreateWithoutOrderInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    subtotal: Decimal | number | string
    quantity: number
    status?: StatusOrderEnum
    product_id: string
    user_id: string
    price_id: string
  }

  export type OrderProductCreateOrConnectWithoutOrderInput = {
    where: OrderProductWhereUniqueInput
    create: XOR<OrderProductCreateWithoutOrderInput, OrderProductUncheckedCreateWithoutOrderInput>
  }

  export type OrderProductCreateManyOrderInputEnvelope = {
    data: Enumerable<OrderProductCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutOrderInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    transaction_id: string
    status: string
    brand: string
    authorization_code: string
    authorized_amount: Decimal | number | string
    tid: string
    installments: string
  }

  export type TransactionUncheckedCreateWithoutOrderInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    transaction_id: string
    status: string
    brand: string
    authorization_code: string
    authorized_amount: Decimal | number | string
    tid: string
    installments: string
  }

  export type TransactionCreateOrConnectWithoutOrderInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutOrderInput, TransactionUncheckedCreateWithoutOrderInput>
  }

  export type TransactionCreateManyOrderInputEnvelope = {
    data: Enumerable<TransactionCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person?: PersonUpdateOneRequiredWithoutUsersInput
    prices?: PriceUpdateManyWithoutUserInput
    reviews?: ReviewUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person_id?: StringFieldUpdateOperationsInput | string
    prices?: PriceUncheckedUpdateManyWithoutUserInput
    reviews?: ReviewUncheckedUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedUpdateManyWithoutUserInput
  }

  export type OrderProductUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderProductWhereUniqueInput
    update: XOR<OrderProductUpdateWithoutOrderInput, OrderProductUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderProductCreateWithoutOrderInput, OrderProductUncheckedCreateWithoutOrderInput>
  }

  export type OrderProductUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderProductWhereUniqueInput
    data: XOR<OrderProductUpdateWithoutOrderInput, OrderProductUncheckedUpdateWithoutOrderInput>
  }

  export type OrderProductUpdateManyWithWhereWithoutOrderInput = {
    where: OrderProductScalarWhereInput
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyWithoutOrdersProductsInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutOrderInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutOrderInput, TransactionUncheckedUpdateWithoutOrderInput>
    create: XOR<TransactionCreateWithoutOrderInput, TransactionUncheckedCreateWithoutOrderInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutOrderInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutOrderInput, TransactionUncheckedUpdateWithoutOrderInput>
  }

  export type TransactionUpdateManyWithWhereWithoutOrderInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: Enumerable<TransactionScalarWhereInput>
    OR?: Enumerable<TransactionScalarWhereInput>
    NOT?: Enumerable<TransactionScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    transaction_id?: StringFilter | string
    status?: StringFilter | string
    brand?: StringFilter | string
    authorization_code?: StringFilter | string
    authorized_amount?: DecimalFilter | Decimal | number | string
    tid?: StringFilter | string
    installments?: StringFilter | string
    order_id?: StringFilter | string
  }

  export type PriceCreateWithoutActualProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    product: ProductCreateNestedOneWithoutPricesInput
    user: UserCreateNestedOneWithoutPricesInput
    OrderProduct?: OrderProductCreateNestedManyWithoutPriceInput
  }

  export type PriceUncheckedCreateWithoutActualProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    product_id: string
    user_id: string
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PriceCreateOrConnectWithoutActualProductInput = {
    where: PriceWhereUniqueInput
    create: XOR<PriceCreateWithoutActualProductInput, PriceUncheckedCreateWithoutActualProductInput>
  }

  export type DescriptionCreateWithoutProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    description: string
  }

  export type DescriptionUncheckedCreateWithoutProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    description: string
  }

  export type DescriptionCreateOrConnectWithoutProductsInput = {
    where: DescriptionWhereUniqueInput
    create: XOR<DescriptionCreateWithoutProductsInput, DescriptionUncheckedCreateWithoutProductsInput>
  }

  export type SubCategoryCreateWithoutProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
  }

  export type SubCategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
  }

  export type SubCategoryCreateOrConnectWithoutProductsInput = {
    where: SubCategoryWhereUniqueInput
    create: XOR<SubCategoryCreateWithoutProductsInput, SubCategoryUncheckedCreateWithoutProductsInput>
  }

  export type ProductInfoCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    freight: Decimal | number | string
    link: string
    stock: number
    company: string
    currency: string
    user: UserCreateNestedOneWithoutProductsInfoInput
  }

  export type ProductInfoUncheckedCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    freight: Decimal | number | string
    link: string
    stock: number
    company: string
    currency: string
    user_id: string
  }

  export type ProductInfoCreateOrConnectWithoutProductInput = {
    where: ProductInfoWhereUniqueInput
    create: XOR<ProductInfoCreateWithoutProductInput, ProductInfoUncheckedCreateWithoutProductInput>
  }

  export type CategoryProductCreateWithoutProductInput = {
    created_at?: Date | string
    updated_at?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
  }

  export type CategoryProductUncheckedCreateWithoutProductInput = {
    created_at?: Date | string
    updated_at?: Date | string
    category_id: string
  }

  export type CategoryProductCreateOrConnectWithoutProductInput = {
    where: CategoryProductWhereUniqueInput
    create: XOR<CategoryProductCreateWithoutProductInput, CategoryProductUncheckedCreateWithoutProductInput>
  }

  export type CategoryProductCreateManyProductInputEnvelope = {
    data: Enumerable<CategoryProductCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type PhotoCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    priority?: number
  }

  export type PhotoUncheckedCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    priority?: number
  }

  export type PhotoCreateOrConnectWithoutProductInput = {
    where: PhotoWhereUniqueInput
    create: XOR<PhotoCreateWithoutProductInput, PhotoUncheckedCreateWithoutProductInput>
  }

  export type PhotoCreateManyProductInputEnvelope = {
    data: Enumerable<PhotoCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    comment: string
    status?: ReviewsStatusEnum
    author?: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    comment: string
    status?: ReviewsStatusEnum
    author_id?: string | null
  }

  export type ReviewCreateOrConnectWithoutProductInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewCreateManyProductInputEnvelope = {
    data: Enumerable<ReviewCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type VideoCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    slug: string
  }

  export type VideoUncheckedCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    slug: string
  }

  export type VideoCreateOrConnectWithoutProductInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutProductInput, VideoUncheckedCreateWithoutProductInput>
  }

  export type VideoCreateManyProductInputEnvelope = {
    data: Enumerable<VideoCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type StockCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    stock: number
    status?: StocksStatusEnum
    action?: StockActionEnum
  }

  export type StockUncheckedCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    stock: number
    status?: StocksStatusEnum
    action?: StockActionEnum
  }

  export type StockCreateOrConnectWithoutProductInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
  }

  export type StockCreateManyProductInputEnvelope = {
    data: Enumerable<StockCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type OrderProductCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    subtotal: Decimal | number | string
    quantity: number
    status?: StatusOrderEnum
    order: OrderCreateNestedOneWithoutOrdersProductsInput
    user: UserCreateNestedOneWithoutOrderProductInput
    price: PriceCreateNestedOneWithoutOrderProductInput
  }

  export type OrderProductUncheckedCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    subtotal: Decimal | number | string
    quantity: number
    status?: StatusOrderEnum
    order_id: string
    user_id: string
    price_id: string
  }

  export type OrderProductCreateOrConnectWithoutProductInput = {
    where: OrderProductWhereUniqueInput
    create: XOR<OrderProductCreateWithoutProductInput, OrderProductUncheckedCreateWithoutProductInput>
  }

  export type OrderProductCreateManyProductInputEnvelope = {
    data: Enumerable<OrderProductCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type PriceCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    actualProduct?: ProductCreateNestedManyWithoutPriceInput
    user: UserCreateNestedOneWithoutPricesInput
    OrderProduct?: OrderProductCreateNestedManyWithoutPriceInput
  }

  export type PriceUncheckedCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    actualProduct?: ProductUncheckedCreateNestedManyWithoutPriceInput
    user_id: string
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutPriceInput
  }

  export type PriceCreateOrConnectWithoutProductInput = {
    where: PriceWhereUniqueInput
    create: XOR<PriceCreateWithoutProductInput, PriceUncheckedCreateWithoutProductInput>
  }

  export type PriceCreateManyProductInputEnvelope = {
    data: Enumerable<PriceCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type PriceUpsertWithoutActualProductInput = {
    update: XOR<PriceUpdateWithoutActualProductInput, PriceUncheckedUpdateWithoutActualProductInput>
    create: XOR<PriceCreateWithoutActualProductInput, PriceUncheckedCreateWithoutActualProductInput>
  }

  export type PriceUpdateWithoutActualProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    product?: ProductUpdateOneRequiredWithoutPricesInput
    user?: UserUpdateOneRequiredWithoutPricesInput
    OrderProduct?: OrderProductUpdateManyWithoutPriceInput
  }

  export type PriceUncheckedUpdateWithoutActualProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    product_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutPriceInput
  }

  export type DescriptionUpsertWithoutProductsInput = {
    update: XOR<DescriptionUpdateWithoutProductsInput, DescriptionUncheckedUpdateWithoutProductsInput>
    create: XOR<DescriptionCreateWithoutProductsInput, DescriptionUncheckedCreateWithoutProductsInput>
  }

  export type DescriptionUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type DescriptionUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type SubCategoryUpsertWithoutProductsInput = {
    update: XOR<SubCategoryUpdateWithoutProductsInput, SubCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<SubCategoryCreateWithoutProductsInput, SubCategoryUncheckedCreateWithoutProductsInput>
  }

  export type SubCategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SubCategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProductInfoUpsertWithoutProductInput = {
    update: XOR<ProductInfoUpdateWithoutProductInput, ProductInfoUncheckedUpdateWithoutProductInput>
    create: XOR<ProductInfoCreateWithoutProductInput, ProductInfoUncheckedCreateWithoutProductInput>
  }

  export type ProductInfoUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    link?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutProductsInfoInput
  }

  export type ProductInfoUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    link?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryProductUpsertWithWhereUniqueWithoutProductInput = {
    where: CategoryProductWhereUniqueInput
    update: XOR<CategoryProductUpdateWithoutProductInput, CategoryProductUncheckedUpdateWithoutProductInput>
    create: XOR<CategoryProductCreateWithoutProductInput, CategoryProductUncheckedCreateWithoutProductInput>
  }

  export type CategoryProductUpdateWithWhereUniqueWithoutProductInput = {
    where: CategoryProductWhereUniqueInput
    data: XOR<CategoryProductUpdateWithoutProductInput, CategoryProductUncheckedUpdateWithoutProductInput>
  }

  export type CategoryProductUpdateManyWithWhereWithoutProductInput = {
    where: CategoryProductScalarWhereInput
    data: XOR<CategoryProductUpdateManyMutationInput, CategoryProductUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type PhotoUpsertWithWhereUniqueWithoutProductInput = {
    where: PhotoWhereUniqueInput
    update: XOR<PhotoUpdateWithoutProductInput, PhotoUncheckedUpdateWithoutProductInput>
    create: XOR<PhotoCreateWithoutProductInput, PhotoUncheckedCreateWithoutProductInput>
  }

  export type PhotoUpdateWithWhereUniqueWithoutProductInput = {
    where: PhotoWhereUniqueInput
    data: XOR<PhotoUpdateWithoutProductInput, PhotoUncheckedUpdateWithoutProductInput>
  }

  export type PhotoUpdateManyWithWhereWithoutProductInput = {
    where: PhotoScalarWhereInput
    data: XOR<PhotoUpdateManyMutationInput, PhotoUncheckedUpdateManyWithoutPhotosInput>
  }

  export type PhotoScalarWhereInput = {
    AND?: Enumerable<PhotoScalarWhereInput>
    OR?: Enumerable<PhotoScalarWhereInput>
    NOT?: Enumerable<PhotoScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    name?: StringFilter | string
    priority?: IntFilter | number
    product_id?: StringFilter | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
  }

  export type ReviewUpdateManyWithWhereWithoutProductInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutReviewsInput>
  }

  export type VideoUpsertWithWhereUniqueWithoutProductInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutProductInput, VideoUncheckedUpdateWithoutProductInput>
    create: XOR<VideoCreateWithoutProductInput, VideoUncheckedCreateWithoutProductInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutProductInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutProductInput, VideoUncheckedUpdateWithoutProductInput>
  }

  export type VideoUpdateManyWithWhereWithoutProductInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutVideosInput>
  }

  export type VideoScalarWhereInput = {
    AND?: Enumerable<VideoScalarWhereInput>
    OR?: Enumerable<VideoScalarWhereInput>
    NOT?: Enumerable<VideoScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    name?: StringFilter | string
    slug?: StringFilter | string
    product_id?: StringFilter | string
  }

  export type StockUpsertWithWhereUniqueWithoutProductInput = {
    where: StockWhereUniqueInput
    update: XOR<StockUpdateWithoutProductInput, StockUncheckedUpdateWithoutProductInput>
    create: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
  }

  export type StockUpdateWithWhereUniqueWithoutProductInput = {
    where: StockWhereUniqueInput
    data: XOR<StockUpdateWithoutProductInput, StockUncheckedUpdateWithoutProductInput>
  }

  export type StockUpdateManyWithWhereWithoutProductInput = {
    where: StockScalarWhereInput
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyWithoutStocksInput>
  }

  export type StockScalarWhereInput = {
    AND?: Enumerable<StockScalarWhereInput>
    OR?: Enumerable<StockScalarWhereInput>
    NOT?: Enumerable<StockScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    stock?: IntFilter | number
    status?: EnumStocksStatusEnumFilter | StocksStatusEnum
    action?: EnumStockActionEnumFilter | StockActionEnum
    product_id?: StringFilter | string
  }

  export type OrderProductUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderProductWhereUniqueInput
    update: XOR<OrderProductUpdateWithoutProductInput, OrderProductUncheckedUpdateWithoutProductInput>
    create: XOR<OrderProductCreateWithoutProductInput, OrderProductUncheckedCreateWithoutProductInput>
  }

  export type OrderProductUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderProductWhereUniqueInput
    data: XOR<OrderProductUpdateWithoutProductInput, OrderProductUncheckedUpdateWithoutProductInput>
  }

  export type OrderProductUpdateManyWithWhereWithoutProductInput = {
    where: OrderProductScalarWhereInput
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyWithoutOrdersProductsInput>
  }

  export type PriceUpsertWithWhereUniqueWithoutProductInput = {
    where: PriceWhereUniqueInput
    update: XOR<PriceUpdateWithoutProductInput, PriceUncheckedUpdateWithoutProductInput>
    create: XOR<PriceCreateWithoutProductInput, PriceUncheckedCreateWithoutProductInput>
  }

  export type PriceUpdateWithWhereUniqueWithoutProductInput = {
    where: PriceWhereUniqueInput
    data: XOR<PriceUpdateWithoutProductInput, PriceUncheckedUpdateWithoutProductInput>
  }

  export type PriceUpdateManyWithWhereWithoutProductInput = {
    where: PriceScalarWhereInput
    data: XOR<PriceUpdateManyMutationInput, PriceUncheckedUpdateManyWithoutPricesInput>
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    type?: TypeCategoryEnum
    slug?: string | null
    description: string
    photo?: string | null
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    type?: TypeCategoryEnum
    slug?: string | null
    description: string
    photo?: string | null
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutCategoriesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price?: PriceCreateNestedOneWithoutActualProductInput
    description: DescriptionCreateNestedOneWithoutProductsInput
    subcategory: SubCategoryCreateNestedOneWithoutProductsInput
    product_info: ProductInfoCreateNestedOneWithoutProductInput
    photos?: PhotoCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    videos?: VideoCreateNestedManyWithoutProductInput
    stocks?: StockCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductCreateNestedManyWithoutProductInput
    prices?: PriceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoriesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price_id?: string | null
    description_id: string
    subcategory_id: string
    product_info_id: string
    photos?: PhotoUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    videos?: VideoUncheckedCreateNestedManyWithoutProductInput
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    prices?: PriceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryEnumFieldUpdateOperationsInput | TypeCategoryEnum
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryEnumFieldUpdateOperationsInput | TypeCategoryEnum
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpsertWithoutCategoriesInput = {
    update: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price?: PriceUpdateOneWithoutActualProductInput
    description?: DescriptionUpdateOneRequiredWithoutProductsInput
    subcategory?: SubCategoryUpdateOneRequiredWithoutProductsInput
    product_info?: ProductInfoUpdateOneRequiredWithoutProductInput
    photos?: PhotoUpdateManyWithoutProductInput
    reviews?: ReviewUpdateManyWithoutProductInput
    videos?: VideoUpdateManyWithoutProductInput
    stocks?: StockUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUpdateManyWithoutProductInput
    prices?: PriceUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price_id?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: StringFieldUpdateOperationsInput | string
    subcategory_id?: StringFieldUpdateOperationsInput | string
    product_info_id?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutProductInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductInput
    videos?: VideoUncheckedUpdateManyWithoutProductInput
    stocks?: StockUncheckedUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedUpdateManyWithoutProductInput
    prices?: PriceUncheckedUpdateManyWithoutProductInput
  }

  export type ProductCreateWithoutPhotosInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price?: PriceCreateNestedOneWithoutActualProductInput
    description: DescriptionCreateNestedOneWithoutProductsInput
    subcategory: SubCategoryCreateNestedOneWithoutProductsInput
    product_info: ProductInfoCreateNestedOneWithoutProductInput
    categories?: CategoryProductCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    videos?: VideoCreateNestedManyWithoutProductInput
    stocks?: StockCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductCreateNestedManyWithoutProductInput
    prices?: PriceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPhotosInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price_id?: string | null
    description_id: string
    subcategory_id: string
    product_info_id: string
    categories?: CategoryProductUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    videos?: VideoUncheckedCreateNestedManyWithoutProductInput
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    prices?: PriceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPhotosInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPhotosInput, ProductUncheckedCreateWithoutPhotosInput>
  }

  export type ProductUpsertWithoutPhotosInput = {
    update: XOR<ProductUpdateWithoutPhotosInput, ProductUncheckedUpdateWithoutPhotosInput>
    create: XOR<ProductCreateWithoutPhotosInput, ProductUncheckedCreateWithoutPhotosInput>
  }

  export type ProductUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price?: PriceUpdateOneWithoutActualProductInput
    description?: DescriptionUpdateOneRequiredWithoutProductsInput
    subcategory?: SubCategoryUpdateOneRequiredWithoutProductsInput
    product_info?: ProductInfoUpdateOneRequiredWithoutProductInput
    categories?: CategoryProductUpdateManyWithoutProductInput
    reviews?: ReviewUpdateManyWithoutProductInput
    videos?: VideoUpdateManyWithoutProductInput
    stocks?: StockUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUpdateManyWithoutProductInput
    prices?: PriceUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price_id?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: StringFieldUpdateOperationsInput | string
    subcategory_id?: StringFieldUpdateOperationsInput | string
    product_info_id?: StringFieldUpdateOperationsInput | string
    categories?: CategoryProductUncheckedUpdateManyWithoutProductInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductInput
    videos?: VideoUncheckedUpdateManyWithoutProductInput
    stocks?: StockUncheckedUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedUpdateManyWithoutProductInput
    prices?: PriceUncheckedUpdateManyWithoutProductInput
  }

  export type ProductCreateWithoutPricesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price?: PriceCreateNestedOneWithoutActualProductInput
    description: DescriptionCreateNestedOneWithoutProductsInput
    subcategory: SubCategoryCreateNestedOneWithoutProductsInput
    product_info: ProductInfoCreateNestedOneWithoutProductInput
    categories?: CategoryProductCreateNestedManyWithoutProductInput
    photos?: PhotoCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    videos?: VideoCreateNestedManyWithoutProductInput
    stocks?: StockCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPricesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price_id?: string | null
    description_id: string
    subcategory_id: string
    product_info_id: string
    categories?: CategoryProductUncheckedCreateNestedManyWithoutProductInput
    photos?: PhotoUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    videos?: VideoUncheckedCreateNestedManyWithoutProductInput
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPricesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPricesInput, ProductUncheckedCreateWithoutPricesInput>
  }

  export type ProductCreateWithoutPriceInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    description: DescriptionCreateNestedOneWithoutProductsInput
    subcategory: SubCategoryCreateNestedOneWithoutProductsInput
    product_info: ProductInfoCreateNestedOneWithoutProductInput
    categories?: CategoryProductCreateNestedManyWithoutProductInput
    photos?: PhotoCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    videos?: VideoCreateNestedManyWithoutProductInput
    stocks?: StockCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductCreateNestedManyWithoutProductInput
    prices?: PriceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPriceInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    description_id: string
    subcategory_id: string
    product_info_id: string
    categories?: CategoryProductUncheckedCreateNestedManyWithoutProductInput
    photos?: PhotoUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    videos?: VideoUncheckedCreateNestedManyWithoutProductInput
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    prices?: PriceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPriceInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPriceInput, ProductUncheckedCreateWithoutPriceInput>
  }

  export type ProductCreateManyPriceInputEnvelope = {
    data: Enumerable<ProductCreateManyPriceInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPricesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person: PersonCreateNestedOneWithoutUsersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPricesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person_id: string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPricesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPricesInput, UserUncheckedCreateWithoutPricesInput>
  }

  export type OrderProductCreateWithoutPriceInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    subtotal: Decimal | number | string
    quantity: number
    status?: StatusOrderEnum
    order: OrderCreateNestedOneWithoutOrdersProductsInput
    product: ProductCreateNestedOneWithoutOrdersProductsInput
    user: UserCreateNestedOneWithoutOrderProductInput
  }

  export type OrderProductUncheckedCreateWithoutPriceInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    subtotal: Decimal | number | string
    quantity: number
    status?: StatusOrderEnum
    order_id: string
    product_id: string
    user_id: string
  }

  export type OrderProductCreateOrConnectWithoutPriceInput = {
    where: OrderProductWhereUniqueInput
    create: XOR<OrderProductCreateWithoutPriceInput, OrderProductUncheckedCreateWithoutPriceInput>
  }

  export type OrderProductCreateManyPriceInputEnvelope = {
    data: Enumerable<OrderProductCreateManyPriceInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutPricesInput = {
    update: XOR<ProductUpdateWithoutPricesInput, ProductUncheckedUpdateWithoutPricesInput>
    create: XOR<ProductCreateWithoutPricesInput, ProductUncheckedCreateWithoutPricesInput>
  }

  export type ProductUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price?: PriceUpdateOneWithoutActualProductInput
    description?: DescriptionUpdateOneRequiredWithoutProductsInput
    subcategory?: SubCategoryUpdateOneRequiredWithoutProductsInput
    product_info?: ProductInfoUpdateOneRequiredWithoutProductInput
    categories?: CategoryProductUpdateManyWithoutProductInput
    photos?: PhotoUpdateManyWithoutProductInput
    reviews?: ReviewUpdateManyWithoutProductInput
    videos?: VideoUpdateManyWithoutProductInput
    stocks?: StockUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price_id?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: StringFieldUpdateOperationsInput | string
    subcategory_id?: StringFieldUpdateOperationsInput | string
    product_info_id?: StringFieldUpdateOperationsInput | string
    categories?: CategoryProductUncheckedUpdateManyWithoutProductInput
    photos?: PhotoUncheckedUpdateManyWithoutProductInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductInput
    videos?: VideoUncheckedUpdateManyWithoutProductInput
    stocks?: StockUncheckedUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedUpdateManyWithoutProductInput
  }

  export type ProductUpsertWithWhereUniqueWithoutPriceInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutPriceInput, ProductUncheckedUpdateWithoutPriceInput>
    create: XOR<ProductCreateWithoutPriceInput, ProductUncheckedCreateWithoutPriceInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutPriceInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutPriceInput, ProductUncheckedUpdateWithoutPriceInput>
  }

  export type ProductUpdateManyWithWhereWithoutPriceInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutActualProductInput>
  }

  export type UserUpsertWithoutPricesInput = {
    update: XOR<UserUpdateWithoutPricesInput, UserUncheckedUpdateWithoutPricesInput>
    create: XOR<UserCreateWithoutPricesInput, UserUncheckedCreateWithoutPricesInput>
  }

  export type UserUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person?: PersonUpdateOneRequiredWithoutUsersInput
    orders?: OrderUpdateManyWithoutUserInput
    reviews?: ReviewUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person_id?: StringFieldUpdateOperationsInput | string
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    reviews?: ReviewUncheckedUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedUpdateManyWithoutUserInput
  }

  export type OrderProductUpsertWithWhereUniqueWithoutPriceInput = {
    where: OrderProductWhereUniqueInput
    update: XOR<OrderProductUpdateWithoutPriceInput, OrderProductUncheckedUpdateWithoutPriceInput>
    create: XOR<OrderProductCreateWithoutPriceInput, OrderProductUncheckedCreateWithoutPriceInput>
  }

  export type OrderProductUpdateWithWhereUniqueWithoutPriceInput = {
    where: OrderProductWhereUniqueInput
    data: XOR<OrderProductUpdateWithoutPriceInput, OrderProductUncheckedUpdateWithoutPriceInput>
  }

  export type OrderProductUpdateManyWithWhereWithoutPriceInput = {
    where: OrderProductScalarWhereInput
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyWithoutOrderProductInput>
  }

  export type ProductCreateWithoutVideosInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price?: PriceCreateNestedOneWithoutActualProductInput
    description: DescriptionCreateNestedOneWithoutProductsInput
    subcategory: SubCategoryCreateNestedOneWithoutProductsInput
    product_info: ProductInfoCreateNestedOneWithoutProductInput
    categories?: CategoryProductCreateNestedManyWithoutProductInput
    photos?: PhotoCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    stocks?: StockCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductCreateNestedManyWithoutProductInput
    prices?: PriceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutVideosInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price_id?: string | null
    description_id: string
    subcategory_id: string
    product_info_id: string
    categories?: CategoryProductUncheckedCreateNestedManyWithoutProductInput
    photos?: PhotoUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    prices?: PriceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutVideosInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVideosInput, ProductUncheckedCreateWithoutVideosInput>
  }

  export type ProductUpsertWithoutVideosInput = {
    update: XOR<ProductUpdateWithoutVideosInput, ProductUncheckedUpdateWithoutVideosInput>
    create: XOR<ProductCreateWithoutVideosInput, ProductUncheckedCreateWithoutVideosInput>
  }

  export type ProductUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price?: PriceUpdateOneWithoutActualProductInput
    description?: DescriptionUpdateOneRequiredWithoutProductsInput
    subcategory?: SubCategoryUpdateOneRequiredWithoutProductsInput
    product_info?: ProductInfoUpdateOneRequiredWithoutProductInput
    categories?: CategoryProductUpdateManyWithoutProductInput
    photos?: PhotoUpdateManyWithoutProductInput
    reviews?: ReviewUpdateManyWithoutProductInput
    stocks?: StockUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUpdateManyWithoutProductInput
    prices?: PriceUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price_id?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: StringFieldUpdateOperationsInput | string
    subcategory_id?: StringFieldUpdateOperationsInput | string
    product_info_id?: StringFieldUpdateOperationsInput | string
    categories?: CategoryProductUncheckedUpdateManyWithoutProductInput
    photos?: PhotoUncheckedUpdateManyWithoutProductInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductInput
    stocks?: StockUncheckedUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedUpdateManyWithoutProductInput
    prices?: PriceUncheckedUpdateManyWithoutProductInput
  }

  export type ProductCreateWithoutReviewsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price?: PriceCreateNestedOneWithoutActualProductInput
    description: DescriptionCreateNestedOneWithoutProductsInput
    subcategory: SubCategoryCreateNestedOneWithoutProductsInput
    product_info: ProductInfoCreateNestedOneWithoutProductInput
    categories?: CategoryProductCreateNestedManyWithoutProductInput
    photos?: PhotoCreateNestedManyWithoutProductInput
    videos?: VideoCreateNestedManyWithoutProductInput
    stocks?: StockCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductCreateNestedManyWithoutProductInput
    prices?: PriceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutReviewsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price_id?: string | null
    description_id: string
    subcategory_id: string
    product_info_id: string
    categories?: CategoryProductUncheckedCreateNestedManyWithoutProductInput
    photos?: PhotoUncheckedCreateNestedManyWithoutProductInput
    videos?: VideoUncheckedCreateNestedManyWithoutProductInput
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    prices?: PriceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutReviewsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person: PersonCreateNestedOneWithoutUsersInput
    prices?: PriceCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    usersGroups?: UserGroupCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person_id: string
    prices?: PriceUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    usersGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type ProductUpsertWithoutReviewsInput = {
    update: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
  }

  export type ProductUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price?: PriceUpdateOneWithoutActualProductInput
    description?: DescriptionUpdateOneRequiredWithoutProductsInput
    subcategory?: SubCategoryUpdateOneRequiredWithoutProductsInput
    product_info?: ProductInfoUpdateOneRequiredWithoutProductInput
    categories?: CategoryProductUpdateManyWithoutProductInput
    photos?: PhotoUpdateManyWithoutProductInput
    videos?: VideoUpdateManyWithoutProductInput
    stocks?: StockUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUpdateManyWithoutProductInput
    prices?: PriceUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price_id?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: StringFieldUpdateOperationsInput | string
    subcategory_id?: StringFieldUpdateOperationsInput | string
    product_info_id?: StringFieldUpdateOperationsInput | string
    categories?: CategoryProductUncheckedUpdateManyWithoutProductInput
    photos?: PhotoUncheckedUpdateManyWithoutProductInput
    videos?: VideoUncheckedUpdateManyWithoutProductInput
    stocks?: StockUncheckedUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedUpdateManyWithoutProductInput
    prices?: PriceUncheckedUpdateManyWithoutProductInput
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person?: PersonUpdateOneRequiredWithoutUsersInput
    prices?: PriceUpdateManyWithoutUserInput
    orders?: OrderUpdateManyWithoutUserInput
    usersGroups?: UserGroupUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person_id?: StringFieldUpdateOperationsInput | string
    prices?: PriceUncheckedUpdateManyWithoutUserInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    usersGroups?: UserGroupUncheckedUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedUpdateManyWithoutUserInput
  }

  export type ProductCreateWithoutDescriptionInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price?: PriceCreateNestedOneWithoutActualProductInput
    subcategory: SubCategoryCreateNestedOneWithoutProductsInput
    product_info: ProductInfoCreateNestedOneWithoutProductInput
    categories?: CategoryProductCreateNestedManyWithoutProductInput
    photos?: PhotoCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    videos?: VideoCreateNestedManyWithoutProductInput
    stocks?: StockCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductCreateNestedManyWithoutProductInput
    prices?: PriceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutDescriptionInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price_id?: string | null
    subcategory_id: string
    product_info_id: string
    categories?: CategoryProductUncheckedCreateNestedManyWithoutProductInput
    photos?: PhotoUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    videos?: VideoUncheckedCreateNestedManyWithoutProductInput
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    prices?: PriceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutDescriptionInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutDescriptionInput, ProductUncheckedCreateWithoutDescriptionInput>
  }

  export type ProductCreateManyDescriptionInputEnvelope = {
    data: Enumerable<ProductCreateManyDescriptionInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutDescriptionInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutDescriptionInput, ProductUncheckedUpdateWithoutDescriptionInput>
    create: XOR<ProductCreateWithoutDescriptionInput, ProductUncheckedCreateWithoutDescriptionInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutDescriptionInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutDescriptionInput, ProductUncheckedUpdateWithoutDescriptionInput>
  }

  export type ProductUpdateManyWithWhereWithoutDescriptionInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductCreateWithoutStocksInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price?: PriceCreateNestedOneWithoutActualProductInput
    description: DescriptionCreateNestedOneWithoutProductsInput
    subcategory: SubCategoryCreateNestedOneWithoutProductsInput
    product_info: ProductInfoCreateNestedOneWithoutProductInput
    categories?: CategoryProductCreateNestedManyWithoutProductInput
    photos?: PhotoCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    videos?: VideoCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductCreateNestedManyWithoutProductInput
    prices?: PriceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStocksInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price_id?: string | null
    description_id: string
    subcategory_id: string
    product_info_id: string
    categories?: CategoryProductUncheckedCreateNestedManyWithoutProductInput
    photos?: PhotoUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    videos?: VideoUncheckedCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    prices?: PriceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStocksInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStocksInput, ProductUncheckedCreateWithoutStocksInput>
  }

  export type ProductUpsertWithoutStocksInput = {
    update: XOR<ProductUpdateWithoutStocksInput, ProductUncheckedUpdateWithoutStocksInput>
    create: XOR<ProductCreateWithoutStocksInput, ProductUncheckedCreateWithoutStocksInput>
  }

  export type ProductUpdateWithoutStocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price?: PriceUpdateOneWithoutActualProductInput
    description?: DescriptionUpdateOneRequiredWithoutProductsInput
    subcategory?: SubCategoryUpdateOneRequiredWithoutProductsInput
    product_info?: ProductInfoUpdateOneRequiredWithoutProductInput
    categories?: CategoryProductUpdateManyWithoutProductInput
    photos?: PhotoUpdateManyWithoutProductInput
    reviews?: ReviewUpdateManyWithoutProductInput
    videos?: VideoUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUpdateManyWithoutProductInput
    prices?: PriceUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutStocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price_id?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: StringFieldUpdateOperationsInput | string
    subcategory_id?: StringFieldUpdateOperationsInput | string
    product_info_id?: StringFieldUpdateOperationsInput | string
    categories?: CategoryProductUncheckedUpdateManyWithoutProductInput
    photos?: PhotoUncheckedUpdateManyWithoutProductInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductInput
    videos?: VideoUncheckedUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedUpdateManyWithoutProductInput
    prices?: PriceUncheckedUpdateManyWithoutProductInput
  }

  export type OrderCreateWithoutOrdersProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    total: Decimal | number | string
    freight: Decimal | number | string
    canceled_at?: Date | string | null
    status?: StatusOrderEnum
    user: UserCreateNestedOneWithoutOrdersInput
    transactions?: TransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrdersProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    total: Decimal | number | string
    freight: Decimal | number | string
    canceled_at?: Date | string | null
    status?: StatusOrderEnum
    user_id: string
    transactions?: TransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrdersProductsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrdersProductsInput, OrderUncheckedCreateWithoutOrdersProductsInput>
  }

  export type ProductCreateWithoutOrdersProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price?: PriceCreateNestedOneWithoutActualProductInput
    description: DescriptionCreateNestedOneWithoutProductsInput
    subcategory: SubCategoryCreateNestedOneWithoutProductsInput
    product_info: ProductInfoCreateNestedOneWithoutProductInput
    categories?: CategoryProductCreateNestedManyWithoutProductInput
    photos?: PhotoCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    videos?: VideoCreateNestedManyWithoutProductInput
    stocks?: StockCreateNestedManyWithoutProductInput
    prices?: PriceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrdersProductsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price_id?: string | null
    description_id: string
    subcategory_id: string
    product_info_id: string
    categories?: CategoryProductUncheckedCreateNestedManyWithoutProductInput
    photos?: PhotoUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    videos?: VideoUncheckedCreateNestedManyWithoutProductInput
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    prices?: PriceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrdersProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrdersProductsInput, ProductUncheckedCreateWithoutOrdersProductsInput>
  }

  export type UserCreateWithoutOrderProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person: PersonCreateNestedOneWithoutUsersInput
    prices?: PriceCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrderProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person_id: string
    prices?: PriceUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrderProductInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrderProductInput, UserUncheckedCreateWithoutOrderProductInput>
  }

  export type PriceCreateWithoutOrderProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    product: ProductCreateNestedOneWithoutPricesInput
    actualProduct?: ProductCreateNestedManyWithoutPriceInput
    user: UserCreateNestedOneWithoutPricesInput
  }

  export type PriceUncheckedCreateWithoutOrderProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    product_id: string
    actualProduct?: ProductUncheckedCreateNestedManyWithoutPriceInput
    user_id: string
  }

  export type PriceCreateOrConnectWithoutOrderProductInput = {
    where: PriceWhereUniqueInput
    create: XOR<PriceCreateWithoutOrderProductInput, PriceUncheckedCreateWithoutOrderProductInput>
  }

  export type OrderUpsertWithoutOrdersProductsInput = {
    update: XOR<OrderUpdateWithoutOrdersProductsInput, OrderUncheckedUpdateWithoutOrdersProductsInput>
    create: XOR<OrderCreateWithoutOrdersProductsInput, OrderUncheckedCreateWithoutOrdersProductsInput>
  }

  export type OrderUpdateWithoutOrdersProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    user?: UserUpdateOneRequiredWithoutOrdersInput
    transactions?: TransactionUpdateManyWithoutOrderInput
  }

  export type OrderUncheckedUpdateWithoutOrdersProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    user_id?: StringFieldUpdateOperationsInput | string
    transactions?: TransactionUncheckedUpdateManyWithoutOrderInput
  }

  export type ProductUpsertWithoutOrdersProductsInput = {
    update: XOR<ProductUpdateWithoutOrdersProductsInput, ProductUncheckedUpdateWithoutOrdersProductsInput>
    create: XOR<ProductCreateWithoutOrdersProductsInput, ProductUncheckedCreateWithoutOrdersProductsInput>
  }

  export type ProductUpdateWithoutOrdersProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price?: PriceUpdateOneWithoutActualProductInput
    description?: DescriptionUpdateOneRequiredWithoutProductsInput
    subcategory?: SubCategoryUpdateOneRequiredWithoutProductsInput
    product_info?: ProductInfoUpdateOneRequiredWithoutProductInput
    categories?: CategoryProductUpdateManyWithoutProductInput
    photos?: PhotoUpdateManyWithoutProductInput
    reviews?: ReviewUpdateManyWithoutProductInput
    videos?: VideoUpdateManyWithoutProductInput
    stocks?: StockUpdateManyWithoutProductInput
    prices?: PriceUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutOrdersProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price_id?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: StringFieldUpdateOperationsInput | string
    subcategory_id?: StringFieldUpdateOperationsInput | string
    product_info_id?: StringFieldUpdateOperationsInput | string
    categories?: CategoryProductUncheckedUpdateManyWithoutProductInput
    photos?: PhotoUncheckedUpdateManyWithoutProductInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductInput
    videos?: VideoUncheckedUpdateManyWithoutProductInput
    stocks?: StockUncheckedUpdateManyWithoutProductInput
    prices?: PriceUncheckedUpdateManyWithoutProductInput
  }

  export type UserUpsertWithoutOrderProductInput = {
    update: XOR<UserUpdateWithoutOrderProductInput, UserUncheckedUpdateWithoutOrderProductInput>
    create: XOR<UserCreateWithoutOrderProductInput, UserUncheckedCreateWithoutOrderProductInput>
  }

  export type UserUpdateWithoutOrderProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person?: PersonUpdateOneRequiredWithoutUsersInput
    prices?: PriceUpdateManyWithoutUserInput
    orders?: OrderUpdateManyWithoutUserInput
    reviews?: ReviewUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutOrderProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person_id?: StringFieldUpdateOperationsInput | string
    prices?: PriceUncheckedUpdateManyWithoutUserInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    reviews?: ReviewUncheckedUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedUpdateManyWithoutUserInput
  }

  export type PriceUpsertWithoutOrderProductInput = {
    update: XOR<PriceUpdateWithoutOrderProductInput, PriceUncheckedUpdateWithoutOrderProductInput>
    create: XOR<PriceCreateWithoutOrderProductInput, PriceUncheckedCreateWithoutOrderProductInput>
  }

  export type PriceUpdateWithoutOrderProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    product?: ProductUpdateOneRequiredWithoutPricesInput
    actualProduct?: ProductUpdateManyWithoutPriceInput
    user?: UserUpdateOneRequiredWithoutPricesInput
  }

  export type PriceUncheckedUpdateWithoutOrderProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    product_id?: StringFieldUpdateOperationsInput | string
    actualProduct?: ProductUncheckedUpdateManyWithoutPriceInput
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type OrderCreateWithoutTransactionsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    total: Decimal | number | string
    freight: Decimal | number | string
    canceled_at?: Date | string | null
    status?: StatusOrderEnum
    user: UserCreateNestedOneWithoutOrdersInput
    ordersProducts?: OrderProductCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutTransactionsInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    total: Decimal | number | string
    freight: Decimal | number | string
    canceled_at?: Date | string | null
    status?: StatusOrderEnum
    user_id: string
    ordersProducts?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutTransactionsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutTransactionsInput, OrderUncheckedCreateWithoutTransactionsInput>
  }

  export type OrderUpsertWithoutTransactionsInput = {
    update: XOR<OrderUpdateWithoutTransactionsInput, OrderUncheckedUpdateWithoutTransactionsInput>
    create: XOR<OrderCreateWithoutTransactionsInput, OrderUncheckedCreateWithoutTransactionsInput>
  }

  export type OrderUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    user?: UserUpdateOneRequiredWithoutOrdersInput
    ordersProducts?: OrderProductUpdateManyWithoutOrderInput
  }

  export type OrderUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    user_id?: StringFieldUpdateOperationsInput | string
    ordersProducts?: OrderProductUncheckedUpdateManyWithoutOrderInput
  }

  export type UserCreateWithoutProductsInfoInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person: PersonCreateNestedOneWithoutUsersInput
    prices?: PriceCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductsInfoInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person_id: string
    prices?: PriceUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductsInfoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductsInfoInput, UserUncheckedCreateWithoutProductsInfoInput>
  }

  export type ProductCreateWithoutProduct_infoInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price?: PriceCreateNestedOneWithoutActualProductInput
    description: DescriptionCreateNestedOneWithoutProductsInput
    subcategory: SubCategoryCreateNestedOneWithoutProductsInput
    categories?: CategoryProductCreateNestedManyWithoutProductInput
    photos?: PhotoCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    videos?: VideoCreateNestedManyWithoutProductInput
    stocks?: StockCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductCreateNestedManyWithoutProductInput
    prices?: PriceCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProduct_infoInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price_id?: string | null
    description_id: string
    subcategory_id: string
    categories?: CategoryProductUncheckedCreateNestedManyWithoutProductInput
    photos?: PhotoUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    videos?: VideoUncheckedCreateNestedManyWithoutProductInput
    stocks?: StockUncheckedCreateNestedManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    prices?: PriceUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProduct_infoInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProduct_infoInput, ProductUncheckedCreateWithoutProduct_infoInput>
  }

  export type UserUpsertWithoutProductsInfoInput = {
    update: XOR<UserUpdateWithoutProductsInfoInput, UserUncheckedUpdateWithoutProductsInfoInput>
    create: XOR<UserCreateWithoutProductsInfoInput, UserUncheckedCreateWithoutProductsInfoInput>
  }

  export type UserUpdateWithoutProductsInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person?: PersonUpdateOneRequiredWithoutUsersInput
    prices?: PriceUpdateManyWithoutUserInput
    orders?: OrderUpdateManyWithoutUserInput
    reviews?: ReviewUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutProductsInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person_id?: StringFieldUpdateOperationsInput | string
    prices?: PriceUncheckedUpdateManyWithoutUserInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    reviews?: ReviewUncheckedUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedUpdateManyWithoutUserInput
  }

  export type ProductUpsertWithoutProduct_infoInput = {
    update: XOR<ProductUpdateWithoutProduct_infoInput, ProductUncheckedUpdateWithoutProduct_infoInput>
    create: XOR<ProductCreateWithoutProduct_infoInput, ProductUncheckedCreateWithoutProduct_infoInput>
  }

  export type ProductUpdateWithoutProduct_infoInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price?: PriceUpdateOneWithoutActualProductInput
    description?: DescriptionUpdateOneRequiredWithoutProductsInput
    subcategory?: SubCategoryUpdateOneRequiredWithoutProductsInput
    categories?: CategoryProductUpdateManyWithoutProductInput
    photos?: PhotoUpdateManyWithoutProductInput
    reviews?: ReviewUpdateManyWithoutProductInput
    videos?: VideoUpdateManyWithoutProductInput
    stocks?: StockUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUpdateManyWithoutProductInput
    prices?: PriceUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutProduct_infoInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price_id?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: StringFieldUpdateOperationsInput | string
    subcategory_id?: StringFieldUpdateOperationsInput | string
    categories?: CategoryProductUncheckedUpdateManyWithoutProductInput
    photos?: PhotoUncheckedUpdateManyWithoutProductInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductInput
    videos?: VideoUncheckedUpdateManyWithoutProductInput
    stocks?: StockUncheckedUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedUpdateManyWithoutProductInput
    prices?: PriceUncheckedUpdateManyWithoutProductInput
  }

  export type UserCreateWithoutForgotTokenInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person: PersonCreateNestedOneWithoutUsersInput
    prices?: PriceCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutForgotTokenInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
    person_id: string
    prices?: PriceUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedCreateNestedManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedCreateNestedManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutForgotTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutForgotTokenInput, UserUncheckedCreateWithoutForgotTokenInput>
  }

  export type UserUpsertWithoutForgotTokenInput = {
    update: XOR<UserUpdateWithoutForgotTokenInput, UserUncheckedUpdateWithoutForgotTokenInput>
    create: XOR<UserCreateWithoutForgotTokenInput, UserUncheckedCreateWithoutForgotTokenInput>
  }

  export type UserUpdateWithoutForgotTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person?: PersonUpdateOneRequiredWithoutUsersInput
    prices?: PriceUpdateManyWithoutUserInput
    orders?: OrderUpdateManyWithoutUserInput
    reviews?: ReviewUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutForgotTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    person_id?: StringFieldUpdateOperationsInput | string
    prices?: PriceUncheckedUpdateManyWithoutUserInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    reviews?: ReviewUncheckedUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyPersonInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    password: string
    is_verified?: boolean
  }

  export type AddressPersonCreateManyPersonInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    number: number
    street: string
    complement?: string | null
    zip_code: string
    city: string
    state: string
    neighborhood: string
  }

  export type PhonePersonCreateManyPersonInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    phone: string
  }

  export type UserUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    prices?: PriceUpdateManyWithoutUserInput
    orders?: OrderUpdateManyWithoutUserInput
    reviews?: ReviewUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    prices?: PriceUncheckedUpdateManyWithoutUserInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    reviews?: ReviewUncheckedUpdateManyWithoutAuthorInput
    usersGroups?: UserGroupUncheckedUpdateManyWithoutUserInput
    refreshesTokens?: RefresheTokenUncheckedUpdateManyWithoutUserInput
    productsInfo?: ProductInfoUncheckedUpdateManyWithoutUserInput
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutUserInput
    ForgotToken?: ForgotTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AddressPersonUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    neighborhood?: StringFieldUpdateOperationsInput | string
    mainAddressPersons?: PersonUpdateManyWithoutAddressInput
  }

  export type AddressPersonUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    neighborhood?: StringFieldUpdateOperationsInput | string
    mainAddressPersons?: PersonUncheckedUpdateManyWithoutAddressInput
  }

  export type AddressPersonUncheckedUpdateManyWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    neighborhood?: StringFieldUpdateOperationsInput | string
  }

  export type PhonePersonUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    mainPhonePersons?: PersonUpdateManyWithoutPhoneInput
  }

  export type PhonePersonUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
    mainPhonePersons?: PersonUncheckedUpdateManyWithoutPhoneInput
  }

  export type PhonePersonUncheckedUpdateManyWithoutPhonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type PersonCreateManyAddressInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    email: string
    cpf?: string | null
    rg?: string | null
    rgss?: string | null
    birth_date?: Date | string | null
    status?: boolean
    privacy?: boolean
    avatar?: string | null
    phone_id?: string | null
  }

  export type PersonUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutPersonInput
    phone?: PhonePersonUpdateOneWithoutMainPhonePersonsInput
    addresses?: AddressPersonUpdateManyWithoutPersonInput
    phones?: PhonePersonUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutPersonInput
    phone_id?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: AddressPersonUncheckedUpdateManyWithoutPersonInput
    phones?: PhonePersonUncheckedUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateManyWithoutMainAddressPersonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonCreateManyPhoneInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    email: string
    cpf?: string | null
    rg?: string | null
    rgss?: string | null
    birth_date?: Date | string | null
    status?: boolean
    privacy?: boolean
    avatar?: string | null
    address_id?: string | null
  }

  export type PersonUpdateWithoutPhoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutPersonInput
    address?: AddressPersonUpdateOneWithoutMainAddressPersonsInput
    addresses?: AddressPersonUpdateManyWithoutPersonInput
    phones?: PhonePersonUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutPhoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutPersonInput
    address_id?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: AddressPersonUncheckedUpdateManyWithoutPersonInput
    phones?: PhonePersonUncheckedUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateManyWithoutMainPhonePersonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    rgss?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    privacy?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserGroupCreateManyGroupInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user_id: string
  }

  export type UserGroupUpdateWithoutGroupInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsersGroupsInput
  }

  export type UserGroupUncheckedUpdateWithoutGroupInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type UserGroupUncheckedUpdateManyWithoutUsersGroupsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type PriceCreateManyUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    product_id: string
  }

  export type OrderCreateManyUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    total: Decimal | number | string
    freight: Decimal | number | string
    canceled_at?: Date | string | null
    status?: StatusOrderEnum
  }

  export type ReviewCreateManyAuthorInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    comment: string
    status?: ReviewsStatusEnum
    product_id: string
  }

  export type UserGroupCreateManyUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    group_id: string
  }

  export type RefresheTokenCreateManyUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    refresh_token: string
    device: string
    expires_date: Date | string
  }

  export type ProductInfoCreateManyUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    freight: Decimal | number | string
    link: string
    stock: number
    company: string
    currency: string
  }

  export type OrderProductCreateManyUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    subtotal: Decimal | number | string
    quantity: number
    status?: StatusOrderEnum
    order_id: string
    product_id: string
    price_id: string
  }

  export type ForgotTokenCreateManyUserInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    token: string
    code: string
    expires_date: Date | string
  }

  export type PriceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    product?: ProductUpdateOneRequiredWithoutPricesInput
    actualProduct?: ProductUpdateManyWithoutPriceInput
    OrderProduct?: OrderProductUpdateManyWithoutPriceInput
  }

  export type PriceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    product_id?: StringFieldUpdateOperationsInput | string
    actualProduct?: ProductUncheckedUpdateManyWithoutPriceInput
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutPriceInput
  }

  export type PriceUncheckedUpdateManyWithoutPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    ordersProducts?: OrderProductUpdateManyWithoutOrderInput
    transactions?: TransactionUpdateManyWithoutOrderInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    ordersProducts?: OrderProductUncheckedUpdateManyWithoutOrderInput
    transactions?: TransactionUncheckedUpdateManyWithoutOrderInput
  }

  export type OrderUncheckedUpdateManyWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
  }

  export type ReviewUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewsStatusEnumFieldUpdateOperationsInput | ReviewsStatusEnum
    product?: ProductUpdateOneRequiredWithoutReviewsInput
  }

  export type ReviewUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewsStatusEnumFieldUpdateOperationsInput | ReviewsStatusEnum
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewUncheckedUpdateManyWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewsStatusEnumFieldUpdateOperationsInput | ReviewsStatusEnum
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type UserGroupUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutUsersGroupsInput
  }

  export type UserGroupUncheckedUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    group_id?: StringFieldUpdateOperationsInput | string
  }

  export type RefresheTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    expires_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefresheTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    expires_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefresheTokenUncheckedUpdateManyWithoutRefreshesTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    device?: StringFieldUpdateOperationsInput | string
    expires_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductInfoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    link?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneWithoutProduct_infoInput
  }

  export type ProductInfoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    link?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    product?: ProductUncheckedUpdateOneWithoutProduct_infoInput
  }

  export type ProductInfoUncheckedUpdateManyWithoutProductsInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    freight?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    link?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type OrderProductUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    order?: OrderUpdateOneRequiredWithoutOrdersProductsInput
    product?: ProductUpdateOneRequiredWithoutOrdersProductsInput
    price?: PriceUpdateOneRequiredWithoutOrderProductInput
  }

  export type OrderProductUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    order_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    price_id?: StringFieldUpdateOperationsInput | string
  }

  export type OrderProductUncheckedUpdateManyWithoutOrderProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    order_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    price_id?: StringFieldUpdateOperationsInput | string
  }

  export type ForgotTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForgotTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForgotTokenUncheckedUpdateManyWithoutForgotTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryProductCreateManyCategoryInput = {
    created_at?: Date | string
    updated_at?: Date | string
    product_id: string
  }

  export type CategoryProductUpdateWithoutCategoryInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCategoriesInput
  }

  export type CategoryProductUncheckedUpdateWithoutCategoryInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryProductUncheckedUpdateManyWithoutProductsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product_id?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateManySubcategoryInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price_id?: string | null
    description_id: string
    product_info_id: string
  }

  export type ProductUpdateWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price?: PriceUpdateOneWithoutActualProductInput
    description?: DescriptionUpdateOneRequiredWithoutProductsInput
    product_info?: ProductInfoUpdateOneRequiredWithoutProductInput
    categories?: CategoryProductUpdateManyWithoutProductInput
    photos?: PhotoUpdateManyWithoutProductInput
    reviews?: ReviewUpdateManyWithoutProductInput
    videos?: VideoUpdateManyWithoutProductInput
    stocks?: StockUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUpdateManyWithoutProductInput
    prices?: PriceUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price_id?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: StringFieldUpdateOperationsInput | string
    product_info_id?: StringFieldUpdateOperationsInput | string
    categories?: CategoryProductUncheckedUpdateManyWithoutProductInput
    photos?: PhotoUncheckedUpdateManyWithoutProductInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductInput
    videos?: VideoUncheckedUpdateManyWithoutProductInput
    stocks?: StockUncheckedUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedUpdateManyWithoutProductInput
    prices?: PriceUncheckedUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price_id?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: StringFieldUpdateOperationsInput | string
    product_info_id?: StringFieldUpdateOperationsInput | string
  }

  export type OrderProductCreateManyOrderInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    subtotal: Decimal | number | string
    quantity: number
    status?: StatusOrderEnum
    product_id: string
    user_id: string
    price_id: string
  }

  export type TransactionCreateManyOrderInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    transaction_id: string
    status: string
    brand: string
    authorization_code: string
    authorized_amount: Decimal | number | string
    tid: string
    installments: string
  }

  export type OrderProductUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    product?: ProductUpdateOneRequiredWithoutOrdersProductsInput
    user?: UserUpdateOneRequiredWithoutOrderProductInput
    price?: PriceUpdateOneRequiredWithoutOrderProductInput
  }

  export type OrderProductUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    product_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    price_id?: StringFieldUpdateOperationsInput | string
  }

  export type OrderProductUncheckedUpdateManyWithoutOrdersProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    product_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    price_id?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    authorization_code?: StringFieldUpdateOperationsInput | string
    authorized_amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    tid?: StringFieldUpdateOperationsInput | string
    installments?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    authorization_code?: StringFieldUpdateOperationsInput | string
    authorized_amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    tid?: StringFieldUpdateOperationsInput | string
    installments?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionUncheckedUpdateManyWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    authorization_code?: StringFieldUpdateOperationsInput | string
    authorized_amount?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    tid?: StringFieldUpdateOperationsInput | string
    installments?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryProductCreateManyProductInput = {
    created_at?: Date | string
    updated_at?: Date | string
    category_id: string
  }

  export type PhotoCreateManyProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    priority?: number
  }

  export type ReviewCreateManyProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    comment: string
    status?: ReviewsStatusEnum
    author_id?: string | null
  }

  export type VideoCreateManyProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    name: string
    slug: string
  }

  export type StockCreateManyProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    stock: number
    status?: StocksStatusEnum
    action?: StockActionEnum
  }

  export type OrderProductCreateManyProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    subtotal: Decimal | number | string
    quantity: number
    status?: StatusOrderEnum
    order_id: string
    user_id: string
    price_id: string
  }

  export type PriceCreateManyProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    price: Decimal | number | string
    price_promotion: Decimal | number | string
    user_id: string
  }

  export type CategoryProductUpdateWithoutProductInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsInput
  }

  export type CategoryProductUncheckedUpdateWithoutProductInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryProductUncheckedUpdateManyWithoutCategoriesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type PhotoUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type PhotoUncheckedUpdateManyWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewsStatusEnumFieldUpdateOperationsInput | ReviewsStatusEnum
    author?: UserUpdateOneWithoutReviewsInput
  }

  export type ReviewUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewsStatusEnumFieldUpdateOperationsInput | ReviewsStatusEnum
    author_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type VideoUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type VideoUncheckedUpdateManyWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type StockUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumStocksStatusEnumFieldUpdateOperationsInput | StocksStatusEnum
    action?: EnumStockActionEnumFieldUpdateOperationsInput | StockActionEnum
  }

  export type StockUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumStocksStatusEnumFieldUpdateOperationsInput | StocksStatusEnum
    action?: EnumStockActionEnumFieldUpdateOperationsInput | StockActionEnum
  }

  export type StockUncheckedUpdateManyWithoutStocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: IntFieldUpdateOperationsInput | number
    status?: EnumStocksStatusEnumFieldUpdateOperationsInput | StocksStatusEnum
    action?: EnumStockActionEnumFieldUpdateOperationsInput | StockActionEnum
  }

  export type OrderProductUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    order?: OrderUpdateOneRequiredWithoutOrdersProductsInput
    user?: UserUpdateOneRequiredWithoutOrderProductInput
    price?: PriceUpdateOneRequiredWithoutOrderProductInput
  }

  export type OrderProductUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    order_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    price_id?: StringFieldUpdateOperationsInput | string
  }

  export type PriceUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    actualProduct?: ProductUpdateManyWithoutPriceInput
    user?: UserUpdateOneRequiredWithoutPricesInput
    OrderProduct?: OrderProductUpdateManyWithoutPriceInput
  }

  export type PriceUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    price_promotion?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    actualProduct?: ProductUncheckedUpdateManyWithoutPriceInput
    user_id?: StringFieldUpdateOperationsInput | string
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutPriceInput
  }

  export type ProductCreateManyPriceInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    description_id: string
    subcategory_id: string
    product_info_id: string
  }

  export type OrderProductCreateManyPriceInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    subtotal: Decimal | number | string
    quantity: number
    status?: StatusOrderEnum
    order_id: string
    product_id: string
    user_id: string
  }

  export type ProductUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    description?: DescriptionUpdateOneRequiredWithoutProductsInput
    subcategory?: SubCategoryUpdateOneRequiredWithoutProductsInput
    product_info?: ProductInfoUpdateOneRequiredWithoutProductInput
    categories?: CategoryProductUpdateManyWithoutProductInput
    photos?: PhotoUpdateManyWithoutProductInput
    reviews?: ReviewUpdateManyWithoutProductInput
    videos?: VideoUpdateManyWithoutProductInput
    stocks?: StockUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUpdateManyWithoutProductInput
    prices?: PriceUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    description_id?: StringFieldUpdateOperationsInput | string
    subcategory_id?: StringFieldUpdateOperationsInput | string
    product_info_id?: StringFieldUpdateOperationsInput | string
    categories?: CategoryProductUncheckedUpdateManyWithoutProductInput
    photos?: PhotoUncheckedUpdateManyWithoutProductInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductInput
    videos?: VideoUncheckedUpdateManyWithoutProductInput
    stocks?: StockUncheckedUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedUpdateManyWithoutProductInput
    prices?: PriceUncheckedUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateManyWithoutActualProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    description_id?: StringFieldUpdateOperationsInput | string
    subcategory_id?: StringFieldUpdateOperationsInput | string
    product_info_id?: StringFieldUpdateOperationsInput | string
  }

  export type OrderProductUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    order?: OrderUpdateOneRequiredWithoutOrdersProductsInput
    product?: ProductUpdateOneRequiredWithoutOrdersProductsInput
    user?: UserUpdateOneRequiredWithoutOrderProductInput
  }

  export type OrderProductUncheckedUpdateWithoutPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusOrderEnumFieldUpdateOperationsInput | StatusOrderEnum
    order_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateManyDescriptionInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    sku?: string | null
    bar_code?: string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: Date | string | null
    status?: boolean
    status_freight?: boolean
    status_product?: boolean
    price_id?: string | null
    subcategory_id: string
    product_info_id: string
  }

  export type ProductUpdateWithoutDescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price?: PriceUpdateOneWithoutActualProductInput
    subcategory?: SubCategoryUpdateOneRequiredWithoutProductsInput
    product_info?: ProductInfoUpdateOneRequiredWithoutProductInput
    categories?: CategoryProductUpdateManyWithoutProductInput
    photos?: PhotoUpdateManyWithoutProductInput
    reviews?: ReviewUpdateManyWithoutProductInput
    videos?: VideoUpdateManyWithoutProductInput
    stocks?: StockUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUpdateManyWithoutProductInput
    prices?: PriceUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutDescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    bar_code?: NullableStringFieldUpdateOperationsInput | string | null
    other?: NullableJsonNullValueInput | InputJsonValue
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    status_freight?: BoolFieldUpdateOperationsInput | boolean
    status_product?: BoolFieldUpdateOperationsInput | boolean
    price_id?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory_id?: StringFieldUpdateOperationsInput | string
    product_info_id?: StringFieldUpdateOperationsInput | string
    categories?: CategoryProductUncheckedUpdateManyWithoutProductInput
    photos?: PhotoUncheckedUpdateManyWithoutProductInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductInput
    videos?: VideoUncheckedUpdateManyWithoutProductInput
    stocks?: StockUncheckedUpdateManyWithoutProductInput
    ordersProducts?: OrderProductUncheckedUpdateManyWithoutProductInput
    prices?: PriceUncheckedUpdateManyWithoutProductInput
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}